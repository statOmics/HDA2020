<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Lieven Clement" />


<title>3. Prediction with High Dimensional Predictors</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<script src="site_libs/accessible-code-block-0.0.1/empty-anchor.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<link href="site_libs/anchor-sections-1.0/anchor-sections.css" rel="stylesheet" />
<script src="site_libs/anchor-sections-1.0/anchor-sections.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
#rmd-source-code {
  display: none;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "î‰™";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "î‰™";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">HDA2020</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-chalkboard-teacher"></span>
     
    Lectures
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="intro.html">1. Introduction</a>
    </li>
    <li>
      <a href="svd.html">2. Singular Value Decomposition</a>
    </li>
    <li>
      <a href="prediction.html">3. Prediction with High Dimensional Predictors</a>
    </li>
    <li>
      <a href="sparseSvd.html">4. Sparse Singular Value Decomposition</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-laptop"></span>
     
    Practicals
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Lab1-Intro-SVD.html">Lab 1</a>
    </li>
    <li>
      <a href="Lab2-PCA.html">Lab 2</a>
    </li>
    <li>
      <a href="Lab3-Penalized-Regression.html">Lab 3</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/statOmics/HDA2020">
    <span class="fa fa-github"></span>
     
  </a>
</li>
<li>
  <a href="http://statomics.github.io/">statOmics</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">3. Prediction with High Dimensional Predictors</h1>
<h4 class="author">Lieven Clement</h4>
<h4 class="date">statOmics, Ghent University (<a href="https://statomics.github.io" class="uri">https://statomics.github.io</a>)</h4>

</div>


<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<div id="prediction-with-high-dimensional-predictors" class="section level2">
<h2><span class="header-section-number">1.1</span> Prediction with High Dimensional Predictors</h2>
<p>General setting:</p>
<ul>
<li><p>Aim: build a <strong>prediction model</strong> that gives a prediction of an outcome for a given set of predictors.</p></li>
<li><p>We use <span class="math inline">\(X\)</span> to refer to the predictors and <span class="math inline">\(Y\)</span> to refer to the outcome.</p></li>
<li><p>A <strong>training data set</strong> is available, say <span class="math inline">\((\mathbf{X},\mathbf{Y})\)</span>. It contains <span class="math inline">\(n\)</span> observations on outcomes and on <span class="math inline">\(p\)</span> predictors.</p></li>
<li><p>Using the training data, a prediction model is build, say <span class="math inline">\(\hat{m}(\mathbf{X})\)</span>. This typically involves <strong>model building (feature selection)</strong> and parameter estimation.</p></li>
<li><p>During the model building, potential <strong>models need to be evaluated</strong> in terms of their prediction quality.</p></li>
</ul>
</div>
<div id="example-toxicogenomics-in-early-drug-development" class="section level2">
<h2><span class="header-section-number">1.2</span> Example: Toxicogenomics in early drug development</h2>
<div id="background" class="section level3">
<h3><span class="header-section-number">1.2.1</span> Background</h3>
<ul>
<li><p>Effect of compound on gene expression.</p></li>
<li><p>Insight in action and toxicity of drug in early phase</p></li>
<li><p>Determine activity with bio-assay: e.g.Â binding affinity of compound to cell wall receptor (target, IC50).</p></li>
<li><p>Early phase: 20 to 50 compounds</p></li>
<li><p>Based on in vitro results one aims to get insight in how to build better compound (higher on-target activity less toxicity.</p></li>
<li><p>Small variations in molecular structure lead to variations in BA and gene expression.</p></li>
<li><p>Aim: Build model to predict bio-activity based on gene expression in liver cell line.</p></li>
</ul>
</div>
<div id="data" class="section level3">
<h3><span class="header-section-number">1.2.2</span> Data</h3>
<ul>
<li><p>30 chemical compounds have been screened for toxicity</p></li>
<li><p>Bioassay data on toxicity screening</p></li>
<li><p>Gene expressions in a liver cell line are profiled for each compound (4000 genes)</p></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>toxData &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/statOmics/HDA2020/data/toxDataCentered.csv&quot;</span>)</span></code></pre></div>
<pre><code>## 
## [36mâ”€â”€[39m [1m[1mColumn specification[1m[22m [36mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[39m
## cols(
##   .default = col_double()
## )
## [36mâ„¹[39m Use [30m[47m[30m[47m`spec()`[47m[30m[49m[39m for the full column specifications.</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>svdX &lt;-<span class="st"> </span><span class="kw">svd</span>(toxData[,<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div>
<p>Data is already centered:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>toxData <span class="op">%&gt;%</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="st">  </span>colMeans <span class="op">%&gt;%</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="st">  </span>range</span></code></pre></div>
<pre><code>## [1] -1.434038e-17  2.567391e-17</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a> toxData <span class="op">%&gt;%</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="st">  </span>names <span class="op">%&gt;%</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="st">  </span>head</span></code></pre></div>
<pre><code>## [1] &quot;BA&quot; &quot;X1&quot; &quot;X2&quot; &quot;X3&quot; &quot;X4&quot; &quot;X5&quot;</code></pre>
<ul>
<li>First column contains data on Bioassay.</li>
<li>The higher the score on Bioassay the more toxic the compound</li>
<li>Other columns contain data on gene expression X1, â€¦ , X4000</li>
</ul>
</div>
<div id="data-exploration" class="section level3">
<h3><span class="header-section-number">1.2.3</span> Data exploration</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>toxData <span class="op">%&gt;%</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x=</span><span class="st">&quot;&quot;</span>,<span class="dt">y=</span>BA)) <span class="op">+</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="dt">outlier.shape=</span><span class="ot">NA</span>) <span class="op">+</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">position=</span><span class="st">&quot;jitter&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>svdX &lt;-<span class="st"> </span>toxData[,<span class="op">-</span><span class="dv">1</span>] <span class="op">%&gt;%</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="st">  </span>svd</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a>k &lt;-<span class="st"> </span><span class="dv">2</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>Vk &lt;-<span class="st"> </span>svdX<span class="op">$</span>v[,<span class="dv">1</span><span class="op">:</span>k]</span>
<span id="cb9-6"><a href="#cb9-6"></a>Uk &lt;-<span class="st"> </span>svdX<span class="op">$</span>u[,<span class="dv">1</span><span class="op">:</span>k]</span>
<span id="cb9-7"><a href="#cb9-7"></a>Dk &lt;-<span class="st"> </span><span class="kw">diag</span>(svdX<span class="op">$</span>d[<span class="dv">1</span><span class="op">:</span>k])</span>
<span id="cb9-8"><a href="#cb9-8"></a>Zk &lt;-<span class="st"> </span>Uk<span class="op">%*%</span>Dk</span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="kw">colnames</span>(Zk) &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;Z&quot;</span>,<span class="dv">1</span><span class="op">:</span>k)</span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw">colnames</span>(Vk) &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;V&quot;</span>,<span class="dv">1</span><span class="op">:</span>k)</span>
<span id="cb9-11"><a href="#cb9-11"></a></span>
<span id="cb9-12"><a href="#cb9-12"></a>Zk <span class="op">%&gt;%</span></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="st">  </span>as.data.frame <span class="op">%&gt;%</span></span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">BA =</span> toxData <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pull</span>(BA)) <span class="op">%&gt;%</span></span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x=</span> Z1, <span class="dt">y =</span> Z2, <span class="dt">color =</span> BA)) <span class="op">+</span></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">3</span>) <span class="op">+</span></span>
<span id="cb9-17"><a href="#cb9-17"></a><span class="st">  </span><span class="kw">scale_colour_gradient2</span>(<span class="dt">low =</span> <span class="st">&quot;blue&quot;</span>,<span class="dt">mid=</span><span class="st">&quot;white&quot;</span>,<span class="dt">high=</span><span class="st">&quot;red&quot;</span>) <span class="op">+</span></span>
<span id="cb9-18"><a href="#cb9-18"></a><span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">3</span>, <span class="dt">pch =</span> <span class="dv">21</span>, <span class="dt">color =</span> <span class="st">&quot;black&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<ul>
<li>Scores on the first two principal components (or MDS plot).</li>
<li>Each point corresponds to a compound.</li>
<li>Color code refers to the toxicity score (higher score more toxic).</li>
<li>Clear separation between compounds according to toxicity.</li>
</ul>
<hr />
<ul>
<li>Next logic step in a PCA is to interpret the principal components.</li>
<li>We thus have to assess the loadings.</li>
<li>We can add a vector for each gene to get a biplot, but this would require plotting 4000 vectors, which would render the plot unreadable.</li>
</ul>
<p>Alternative graph to look at the many loadings of the first two PCs.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">grid.arrange</span>(</span>
<span id="cb10-2"><a href="#cb10-2"></a>  Vk <span class="op">%&gt;%</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="st">    </span>as.data.frame <span class="op">%&gt;%</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">geneID =</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(Vk)) <span class="op">%&gt;%</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="st">    </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> geneID, <span class="dt">y =</span> V1)) <span class="op">+</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="st">    </span><span class="kw">geom_point</span>(<span class="dt">pch=</span><span class="dv">21</span>) <span class="op">+</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="st">    </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">2</span>)<span class="op">*</span><span class="kw">sd</span>(Vk[,<span class="dv">1</span>]), <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>) ,</span>
<span id="cb10-8"><a href="#cb10-8"></a>  Vk <span class="op">%&gt;%</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="st">    </span>as.data.frame <span class="op">%&gt;%</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">geneID =</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(Vk)) <span class="op">%&gt;%</span></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="st">    </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> geneID, <span class="dt">y =</span> V2)) <span class="op">+</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="st">    </span><span class="kw">geom_point</span>(<span class="dt">pch=</span><span class="dv">21</span>) <span class="op">+</span></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="st">    </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">2</span>)<span class="op">*</span><span class="kw">sd</span>(Vk[,<span class="dv">2</span>]), <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>),</span>
<span id="cb10-14"><a href="#cb10-14"></a>  <span class="dt">ncol=</span><span class="dv">2</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<ul>
<li><p>It is almost impossible to interpret the PCs because there are 4000 genes contributing to each PC.</p></li>
<li><p>In an attempt to find the most important genes (in the sense that they drive the interpretation of the PCs), the plots show horizontal reference lines: the average of the loadings, and the average Â± twice the standard deviation of the loadings. In between the lines we expects about 95% of the loadings (if they were normally distributed).</p></li>
<li><p>The points outside the band come from the genes that have rather large loadings (in absolute value) and hence are important for the interpretation of the PCs.</p></li>
<li><p>Note, that particularly for the first PC, only a few genes show a markedly large loadings that are negative. This means that an upregulation of these genes will lead to low scores on PC1.</p></li>
<li><p>These genes will very likely play an important role in the toxicity mechanism.</p></li>
<li><p>Indeed, low scores on PC1 are in the direction of more toxicity.</p></li>
<li><p>In the next chapter we will introduce a method to obtain sparse PCs.</p></li>
</ul>
</div>
<div id="prediction-model" class="section level3">
<h3><span class="header-section-number">1.2.4</span> Prediction model</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>m1 &lt;-<span class="st"> </span><span class="kw">lm</span>(BA <span class="op">~</span><span class="st"> </span><span class="dv">-1</span> <span class="op">+</span><span class="st"> </span>., toxData)</span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a>m1 <span class="op">%&gt;%</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="st">  </span>coef <span class="op">%&gt;%</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="st">  </span><span class="kw">head</span>(<span class="dv">40</span>)</span></code></pre></div>
<pre><code>##          X1          X2          X3          X4          X5          X6 
##  -7.4569940   0.3571348  11.2492315  10.8354021 -13.7433891   5.6833874 
##          X7          X8          X9         X10         X11         X12 
##  65.5387777   4.3404555   7.9103924  37.0296057 -54.8368698 -55.5547845 
##         X13         X14         X15         X16         X17         X18 
##   5.7924667  23.1428002  -6.9610365 -28.5250571 -22.5509025 -97.9623731 
##         X19         X20         X21         X22         X23         X24 
## -30.4171782 -32.6991673 -14.2808834 -16.1431266 -22.7498681  73.1635178 
##         X25         X26         X27         X28         X29         X30 
##  -5.7065827  37.4745379 -20.1999102  14.9906821  99.6080955          NA 
##         X31         X32         X33         X34         X35         X36 
##          NA          NA          NA          NA          NA          NA 
##         X37         X38         X39         X40 
##          NA          NA          NA          NA</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>m1 <span class="op">%&gt;%</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="st">  </span>coef <span class="op">%&gt;%</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="st">  </span>is.na <span class="op">%&gt;%</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="st">  </span>sum</span></code></pre></div>
<pre><code>## [1] 3971</code></pre>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">summary</span>(m1)<span class="op">$</span>r.squared</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>Problem??</p>
</div>
</div>
<div id="brain-example" class="section level2">
<h2><span class="header-section-number">1.3</span> Brain example</h2>
<ul>
<li>Courtesy to Solomon Kurz. Statistical rethinking with brms, ggplot2, and the tidyverse version 1.2.0.</li>
</ul>
<p><a href="https://bookdown.org/content/3890/" class="uri">https://bookdown.org/content/3890/</a> <a href="https://github.com/ASKurz/Statistical_Rethinking_with_brms_ggplot2_and_the_tidyverse" class="uri">https://github.com/ASKurz/Statistical_Rethinking_with_brms_ggplot2_and_the_tidyverse</a></p>
<ul>
<li>Data with brain size and body size for seven species</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>brain &lt;-</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">tibble</span>(<span class="dt">species =</span> <span class="kw">c</span>(<span class="st">&quot;afarensis&quot;</span>, <span class="st">&quot;africanus&quot;</span>, <span class="st">&quot;habilis&quot;</span>, <span class="st">&quot;boisei&quot;</span>, <span class="st">&quot;rudolfensis&quot;</span>, <span class="st">&quot;ergaster&quot;</span>, <span class="st">&quot;sapiens&quot;</span>),</span>
<span id="cb17-3"><a href="#cb17-3"></a>       <span class="dt">brain   =</span> <span class="kw">c</span>(<span class="dv">438</span>, <span class="dv">452</span>, <span class="dv">612</span>, <span class="dv">521</span>, <span class="dv">752</span>, <span class="dv">871</span>, <span class="dv">1350</span>),</span>
<span id="cb17-4"><a href="#cb17-4"></a>       <span class="dt">mass    =</span> <span class="kw">c</span>(<span class="fl">37.0</span>, <span class="fl">35.5</span>, <span class="fl">34.5</span>, <span class="fl">41.5</span>, <span class="fl">55.5</span>, <span class="fl">61.0</span>, <span class="fl">53.5</span>))</span></code></pre></div>
<div id="data-exploration-1" class="section level3">
<h3><span class="header-section-number">1.3.1</span> Data exploration</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>brain</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["species"],"name":[1],"type":["chr"],"align":["left"]},{"label":["brain"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["mass"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"afarensis","2":"438","3":"37.0"},{"1":"africanus","2":"452","3":"35.5"},{"1":"habilis","2":"612","3":"34.5"},{"1":"boisei","2":"521","3":"41.5"},{"1":"rudolfensis","2":"752","3":"55.5"},{"1":"ergaster","2":"871","3":"61.0"},{"1":"sapiens","2":"1350","3":"53.5"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>p &lt;-<span class="st"> </span>brain <span class="op">%&gt;%</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span>  mass, <span class="dt">y =</span> brain, <span class="dt">label =</span> species)) <span class="op">+</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="st">  </span><span class="kw">geom_point</span>()</span>
<span id="cb19-4"><a href="#cb19-4"></a></span>
<span id="cb19-5"><a href="#cb19-5"></a>p <span class="op">+</span><span class="st"> </span><span class="kw">geom_text</span>(<span class="dt">nudge_y =</span> <span class="dv">40</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
</div>
<div id="models" class="section level3">
<h3><span class="header-section-number">1.3.2</span> Models</h3>
<p>Six models range in complexity from the simple univariate model</p>
<p><span class="math display">\[\begin{align*}
\text{brain}_i &amp; \sim \operatorname{Normal} (\mu_i, \sigma) \\
\mu_i &amp; = \beta_0 + \beta_1 \text{mass}_i,
\end{align*}\]</span></p>
<p>to the dizzying sixth-degree polynomial model</p>
<p><span class="math display">\[\begin{align*}
\text{brain}_i &amp; \sim \operatorname{Normal} (\mu_i, \sigma) \\
\mu_i &amp; = \beta_0 + \beta_1 \text{mass}_i + \beta_2 \text{mass}_i^2 + \beta_3 \text{mass}_i^3 + \beta_4 \text{mass}_i^4 + \beta_5 \text{mass}_i^5 + \beta_6 \text{mass}_i^6.
\end{align*}\]</span></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a>formulas &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="cf">function</span>(i)</span>
<span id="cb20-2"><a href="#cb20-2"></a>  <span class="kw">return</span>(</span>
<span id="cb20-3"><a href="#cb20-3"></a>     <span class="kw">paste0</span>(<span class="st">&quot;I(mass^&quot;</span>,<span class="dv">1</span><span class="op">:</span>i,<span class="st">&quot;)&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">paste</span>(<span class="dt">collapse=</span><span class="st">&quot; + &quot;</span>)</span>
<span id="cb20-4"><a href="#cb20-4"></a>    )  </span>
<span id="cb20-5"><a href="#cb20-5"></a>)</span>
<span id="cb20-6"><a href="#cb20-6"></a></span>
<span id="cb20-7"><a href="#cb20-7"></a>formulas &lt;-<span class="st"> </span><span class="kw">sapply</span>(</span>
<span id="cb20-8"><a href="#cb20-8"></a>  <span class="kw">paste0</span>(<span class="st">&quot;brain ~ &quot;</span>, formulas),</span>
<span id="cb20-9"><a href="#cb20-9"></a>  as.formula)</span>
<span id="cb20-10"><a href="#cb20-10"></a></span>
<span id="cb20-11"><a href="#cb20-11"></a>models &lt;-<span class="st"> </span><span class="kw">lapply</span>(formulas, lm , <span class="dt">data =</span> brain)</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">data.frame</span>(</span>
<span id="cb21-2"><a href="#cb21-2"></a>  <span class="dt">formula=</span>formulas <span class="op">%&gt;%</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="st">    </span>as.character,</span>
<span id="cb21-4"><a href="#cb21-4"></a>  <span class="dt">r2 =</span> <span class="kw">sapply</span>(</span>
<span id="cb21-5"><a href="#cb21-5"></a>    models,</span>
<span id="cb21-6"><a href="#cb21-6"></a>    <span class="cf">function</span>(mod) <span class="kw">summary</span>(mod)<span class="op">$</span>r.squared)</span>
<span id="cb21-7"><a href="#cb21-7"></a>  )  <span class="op">%&gt;%</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="st">  </span><span class="kw">ggplot</span>(</span>
<span id="cb21-9"><a href="#cb21-9"></a>    <span class="kw">aes</span>(<span class="dt">x =</span> r2,</span>
<span id="cb21-10"><a href="#cb21-10"></a>      <span class="dt">y =</span> formula,</span>
<span id="cb21-11"><a href="#cb21-11"></a>      <span class="dt">label =</span> r2 <span class="op">%&gt;%</span></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="st">        </span><span class="kw">round</span>(<span class="dv">2</span>) <span class="op">%&gt;%</span></span>
<span id="cb21-13"><a href="#cb21-13"></a><span class="st">        </span>as.character)</span>
<span id="cb21-14"><a href="#cb21-14"></a>  ) <span class="op">+</span></span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="st">  </span><span class="kw">geom_text</span>()</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<p>We plot the fit for each model individually and them arrange them together in one plot.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a>plots &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="cf">function</span>(i)</span>
<span id="cb22-2"><a href="#cb22-2"></a>{</span>
<span id="cb22-3"><a href="#cb22-3"></a>  p <span class="op">+</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="dt">formula =</span> y <span class="op">~</span><span class="st"> </span><span class="kw">poly</span>(x,i)) <span class="op">+</span></span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="st">  </span><span class="kw">ggtitle</span>(</span>
<span id="cb22-6"><a href="#cb22-6"></a>    <span class="kw">paste0</span>(</span>
<span id="cb22-7"><a href="#cb22-7"></a>      <span class="st">&quot;r2 = &quot;</span>,</span>
<span id="cb22-8"><a href="#cb22-8"></a>      <span class="kw">round</span>(<span class="kw">summary</span>(models[[i]])<span class="op">$</span>r.squared<span class="op">*</span><span class="dv">100</span>,<span class="dv">1</span>),</span>
<span id="cb22-9"><a href="#cb22-9"></a>      <span class="st">&quot;%&quot;</span>)</span>
<span id="cb22-10"><a href="#cb22-10"></a>    )</span>
<span id="cb22-11"><a href="#cb22-11"></a>})</span>
<span id="cb22-12"><a href="#cb22-12"></a></span>
<span id="cb22-13"><a href="#cb22-13"></a><span class="kw">do.call</span>(<span class="st">&quot;grid.arrange&quot;</span>,<span class="kw">c</span>(plots, <span class="dt">ncol =</span> <span class="dv">3</span>))</span></code></pre></div>
<pre><code>## Warning in qt((1 - level)/2, df): NaNs produced</code></pre>
<pre><code>## Warning in max(ids, na.rm = TRUE): no non-missing arguments to max; returning -
## Inf</code></pre>
<p><img src="prediction_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<ul>
<li><p>We clearly see that increasing the model complexity always produces a fit with a smaller SSE.</p></li>
<li><p>The problem of overfitting is very obvious. The more complex polynomial models will not generalise well for prediction!</p></li>
<li><p>We even have a model that fits the data perfectly, but that will make very absurd preditions!</p></li>
<li><p>Too few parameters hurts, too. Fit the underfit intercept-only model.</p></li>
</ul>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>m0 &lt;-<span class="st"> </span><span class="kw">lm</span>(brain <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, brain)</span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">summary</span>(m0)</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = brain ~ 1, data = brain)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -275.71 -227.21 -101.71   97.79  636.29 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)   
## (Intercept)    713.7      121.8    5.86  0.00109 **
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 322.2 on 6 degrees of freedom</code></pre>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a>p <span class="op">+</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="st">  </span><span class="kw">stat_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="dt">formula =</span> y <span class="op">~</span><span class="st"> </span><span class="dv">1</span>) <span class="op">+</span></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="st">  </span><span class="kw">ggtitle</span>(</span>
<span id="cb27-4"><a href="#cb27-4"></a>    <span class="kw">paste0</span>(</span>
<span id="cb27-5"><a href="#cb27-5"></a>      <span class="st">&quot;r2 = &quot;</span>,</span>
<span id="cb27-6"><a href="#cb27-6"></a>      <span class="kw">round</span>(<span class="kw">summary</span>(m0)<span class="op">$</span>r.squared<span class="op">*</span><span class="dv">100</span>,<span class="dv">1</span>),</span>
<span id="cb27-7"><a href="#cb27-7"></a>      <span class="st">&quot;%&quot;</span>)</span>
<span id="cb27-8"><a href="#cb27-8"></a>    )</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>The underfit model did not learn anything about the relation between mass and brain. It would also do a very poor job for predicting new data.</p>
</div>
</div>
<div id="overview" class="section level2">
<h2><span class="header-section-number">1.4</span> Overview</h2>
<p>We will make a distinction between continuous and discrete outcomes. In this course we focus on</p>
<ul>
<li><p>Linear regression models for continous outcomes</p>
<ul>
<li>Penalised regression: Lasso and ridge</li>
<li>Principal component regression (PCR)</li>
</ul></li>
<li><p>Logistic regression models for binary outcomes</p>
<ul>
<li>Penalised regression: Lasso and ridge</li>
</ul></li>
</ul>
<p>For all types of model, we will discuss feature selection methods.</p>
</div>
</div>
<div id="linear-regression-for-high-dimensional-data" class="section level1">
<h1><span class="header-section-number">2</span> Linear Regression for High Dimensional Data</h1>
<p>Consider linear regression model (for double centered data) <span class="math display">\[
  Y_i = \beta_1X_{i1} + \beta_2 X_{i2} + \cdots + \beta_pX_{ip} + \epsilon_i ,
\]</span> with <span class="math inline">\(\text{E}\left[\epsilon \mid \mathbf{X}\right]=0\)</span> and <span class="math inline">\(\text{var}\left[\epsilon \mid \mathbf{X}\right]=\sigma^2\)</span>.</p>
<p>In matrix notation the model becomes <span class="math display">\[
  \mathbf{Y} = \mathbf{X}\mathbf\beta + \mathbf\epsilon.
\]</span> The least squares estimator of <span class="math inline">\(\mathbf\beta\)</span> is given by <span class="math display">\[
  \hat{\mathbf\beta} = (\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{Y} ,
\]</span> and the variance of <span class="math inline">\(\hat{\mathbf\beta}\)</span> equals <span class="math display">\[
  \text{var}\left[\hat{\mathbf\beta}\right] = (\mathbf{X}^T\mathbf{X})^{-1}\sigma^2.
\]</span> <span class="math inline">\(\longrightarrow\)</span> the <span class="math inline">\(p \times p\)</span> matrix <span class="math inline">\((\mathbf{X}^T\mathbf{X})^{-1}\)</span> is crucial</p>
<p>Note, that</p>
<ul>
<li><p>with double centered data it is meant that both the responses are centered (mean of <span class="math inline">\(\mathbf{Y}\)</span> is zero) and that all predictors are centered (columns of <span class="math inline">\(\mathbf{X}\)</span> have zero mean). With double centered data the intercept in a linear regression model is always exactly equal to zero and hence the intercept must not be included in the model.</p></li>
<li><p>we do not assume that the residuals are normally distributed. For prediction purposes this is often not required (normality is particularly important for statistical inference in small samples).</p></li>
</ul>
<div id="linear-regression-for-multivariate-data-vs-high-dimensional-data" class="section level2">
<h2><span class="header-section-number">2.1</span> Linear Regression for multivariate data vs High Dimensional Data</h2>
<ul>
<li><p><span class="math inline">\(\mathbf{X^TX}\)</span> and <span class="math inline">\((\mathbf{X^TX})^{-1}\)</span> are <span class="math inline">\(p \times p\)</span> matrices</p></li>
<li><p><span class="math inline">\(\mathbf{X^TX}\)</span> can only be inverted if it has rank <span class="math inline">\(p\)</span></p></li>
<li><p>Rank of a matrix of form <span class="math inline">\(\mathbf{X^TX}\)</span>, with <span class="math inline">\(\mathbf{X}\)</span> and <span class="math inline">\(n\times p\)</span> matrix, can never be larger than <span class="math inline">\(\min(n,p)\)</span>.</p></li>
<li><p>in most regression problems <span class="math inline">\(n&gt;p\)</span> and rank of <span class="math inline">\((\mathbf{X^TX})\)</span> equals <span class="math inline">\(p\)</span></p></li>
<li><p>in high dimensional regression problems <span class="math inline">\(p &gt;&gt;&gt; n\)</span> and rank of <span class="math inline">\((\mathbf{X^TX})\)</span> equals <span class="math inline">\(n&lt;p\)</span></p></li>
<li><p>in the toxicogenomics example <span class="math inline">\(n=30&lt;p=4000\)</span> and <span class="math inline">\(\text{rank}(\mathbf{X^TX})\leq n=30\)</span>. <span class="math inline">\(\longrightarrow\)</span> <span class="math inline">\((\mathbf{X^TX})^{-1}\)</span> does not exist, and neither does <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>.</p></li>
</ul>
</div>
<div id="can-svd-help" class="section level2">
<h2><span class="header-section-number">2.2</span> Can SVD help?</h2>
<ul>
<li><p>Since the columns of <span class="math inline">\(\mathbf{X}\)</span> are centered, <span class="math inline">\(\mathbf{X^TX} \propto \text{var}\left[\mathbf{X}\right]\)</span>.</p></li>
<li><p>if <span class="math inline">\(\text{rank}(\mathbf{X^TX})=n=30\)</span>, the PCA will give 30 components, each being a linear combination of <span class="math inline">\(p=4000\)</span> variables. These 30 PCs contain all information present in the original <span class="math inline">\(\mathbf{X}\)</span> data.</p></li>
<li><p>if <span class="math inline">\(\text{rank}(\mathbf{X})=n=30\)</span>, the SVD of <span class="math inline">\(\mathbf{X}\)</span> is given by <span class="math display">\[
   \mathbf{X} = \sum_{i=1}^n \delta_i \mathbf{u}_i \mathbf{v}_i^T = \mathbf{U} \boldsymbol{\Delta} \mathbf{V}^T = \mathbf{ZV}^T,
  \]</span> with <span class="math inline">\(\mathbf{Z}\)</span> the <span class="math inline">\(n\times n\)</span> matrix with the scores on the <span class="math inline">\(n\)</span> PCs.</p></li>
<li><p>Still problematic because if we use all PCs <span class="math inline">\(n=p\)</span>.</p></li>
</ul>
</div>
</div>
<div id="principal-component-regression" class="section level1">
<h1><span class="header-section-number">3</span> Principal Component Regression</h1>
<p>A principal component regression (PCR) consists of</p>
<ol style="list-style-type: decimal">
<li><p>transforming <span class="math inline">\(p=4000\)</span> dimensional <span class="math inline">\(X\)</span>-variable to the <span class="math inline">\(n=30\)</span> dimensional <span class="math inline">\(Z\)</span>-variable (PC scores). The <span class="math inline">\(n\)</span> PCs are mutually uncorrelated.</p></li>
<li><p>using the <span class="math inline">\(n\)</span> PC-variables as regressors in a linear regression model</p></li>
<li><p>performing feature selection to select the most important regressors (PC).</p></li>
</ol>
<p>Feature selection is key, because we donâ€™t want to have as many regressors as there are observations in the data. This would result in zero residual degrees of freedom. (see later)</p>
<hr />
<p>To keep the exposition general so that we allow for a feature selection to have taken place, I use the notation <span class="math inline">\(\mathbf{U}_S\)</span> to denote a matrix with left-singular column vectors <span class="math inline">\(\mathbf{u}_i\)</span>, with <span class="math inline">\(i \in {\cal{S}}\)</span> (<span class="math inline">\({\cal{S}}\)</span> an index set referring to the PCs to be included in the regression model).</p>
<p>For example, suppose that a feature selection method has resulted in the selection of PCs 1, 3 and 12 for inclusion in the prediction model, then <span class="math inline">\({\cal{S}}=\{1,3,12\}\)</span> and <span class="math display">\[
 \mathbf{U}_S = \begin{pmatrix}
  \mathbf{u}_1 &amp; \mathbf{u}_3 &amp; \mathbf{u}_{12}
 \end{pmatrix}.
\]</span></p>
<hr />
<div id="example-model-based-on-first-4-pcs" class="section level3">
<h3><span class="header-section-number">3.0.1</span> Example model based on first 4 PCs</h3>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a>k &lt;-<span class="st"> </span><span class="dv">30</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>Uk &lt;-<span class="st"> </span>svdX<span class="op">$</span>u[,<span class="dv">1</span><span class="op">:</span>k]</span>
<span id="cb28-3"><a href="#cb28-3"></a>Dk &lt;-<span class="st"> </span><span class="kw">diag</span>(svdX<span class="op">$</span>d[<span class="dv">1</span><span class="op">:</span>k])</span>
<span id="cb28-4"><a href="#cb28-4"></a>Zk &lt;-<span class="st"> </span>Uk<span class="op">%*%</span>Dk</span>
<span id="cb28-5"><a href="#cb28-5"></a>Y &lt;-<span class="st"> </span>toxData <span class="op">%&gt;%</span></span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="st">  </span><span class="kw">pull</span>(BA)</span>
<span id="cb28-7"><a href="#cb28-7"></a></span>
<span id="cb28-8"><a href="#cb28-8"></a>m4 &lt;-<span class="st"> </span><span class="kw">lm</span>(Y<span class="op">~</span>Zk[,<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>])</span>
<span id="cb28-9"><a href="#cb28-9"></a><span class="kw">summary</span>(m4)</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = Y ~ Zk[, 1:4])
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -2.1438 -0.7033 -0.1222  0.7255  2.2997 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -2.068e-16  2.081e-01   0.000   1.0000    
## Zk[, 1:4]1  -5.275e-01  7.725e-02  -6.828 3.72e-07 ***
## Zk[, 1:4]2  -1.231e-02  8.262e-02  -0.149   0.8828    
## Zk[, 1:4]3  -1.759e-01  8.384e-02  -2.098   0.0461 *  
## Zk[, 1:4]4  -3.491e-02  8.396e-02  -0.416   0.6811    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1.14 on 25 degrees of freedom
## Multiple R-squared:  0.672,  Adjusted R-squared:  0.6195 
## F-statistic:  12.8 on 4 and 25 DF,  p-value: 8.352e-06</code></pre>
<p>Note:</p>
<ul>
<li>the intercept is estimated as zero. (Why?) The model could have been fitted as</li>
</ul>
<pre><code>m4 &lt;- lm(Y~-1+Zk[,1:4])</code></pre>
<ul>
<li><p>the PC-predictors are uncorrelated (by construction)</p></li>
<li><p>first PC-predictors are not necessarily the most important predictors</p></li>
<li><p><span class="math inline">\(p\)</span>-values are not very meaningful when prediction is the objective</p></li>
</ul>
<p>Methods for feature selection will be discussed later.</p>
</div>
</div>
<div id="ridge-regression" class="section level1">
<h1><span class="header-section-number">4</span> Ridge Regression</h1>
<div id="penalty" class="section level2">
<h2><span class="header-section-number">4.1</span> Penalty</h2>
<p>The ridge parameter estimator is defined as the parameter <span class="math inline">\(\mathbf\beta\)</span> that minimises the <strong>penalised least squares criterion</strong></p>
<p><span class="math display">\[
 \text{SSE}_\text{pen}=\Vert\mathbf{Y} - \mathbf{X\beta}\Vert_2^2 + \lambda \Vert \boldsymbol{\beta} \Vert_2^2
\]</span></p>
<ul>
<li><p><span class="math inline">\(\Vert \boldsymbol{\beta} \Vert_2^2=\sum_{j=1}^p \beta_j^2\)</span> is the <strong><span class="math inline">\(L_2\)</span> penalty term</strong></p></li>
<li><p><span class="math inline">\(\lambda&gt;0\)</span> is the penalty parameter (to be chosen by the user).</p></li>
</ul>
<p>Note, that that is equivalent to minimizing <span class="math display">\[
\Vert\mathbf{Y} - \mathbf{X\beta}\Vert_2^2 \text{ subject to } \Vert \boldsymbol{\beta}\Vert^2_2\leq s
\]</span></p>
<p>Note, that <span class="math inline">\(s\)</span> has a one-to-one correspondence with <span class="math inline">\(\lambda\)</span></p>
</div>
<div id="graphical-interpretation" class="section level2">
<h2><span class="header-section-number">4.2</span> Graphical interpretation</h2>
<p><img src="prediction_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
</div>
<div id="solution" class="section level2">
<h2><span class="header-section-number">4.3</span> Solution</h2>
<p>The solution is given by <span class="math display">\[
  \hat{\boldsymbol{\beta}} = (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} \mathbf{X^T Y}.
\]</span> It can be shown that <span class="math inline">\((\mathbf{X^TX}+\lambda \mathbf{I})\)</span> is always of rank <span class="math inline">\(p\)</span> if <span class="math inline">\(\lambda&gt;0\)</span>.</p>
<p>Hence, <span class="math inline">\((\mathbf{X^TX}+\lambda \mathbf{I})\)</span> is invertible and <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> exists even if <span class="math inline">\(p&gt;&gt;&gt;n\)</span>.</p>
<p>We also find <span class="math display">\[
  \text{var}\left[\hat{\mathbf\beta}\right] = (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} \mathbf{X}^T\mathbf{X} (\mathbf{X^TX}+\lambda \mathbf{I})^{-1}\sigma^2
\]</span></p>
<p>However, it can be shown that improved intervals that also account for the bias can be constructed by using:</p>
<p><span class="math display">\[
  \text{var}\left[\hat{\mathbf\beta}\right] = (\mathbf{X^TX}+\lambda \mathbf{I})^{-1}  \sigma^2.
\]</span></p>
<div id="proof" class="section level3">
<h3><span class="header-section-number">4.3.1</span> Proof</h3>
<p>The criterion to be minimised is <span class="math display">\[
   \text{SSE}_\text{pen}=\Vert\mathbf{Y} - \mathbf{X\beta}\Vert_2^2 + \lambda \Vert \boldsymbol{\beta} \Vert_2^2.
 \]</span> First we re-express SSE in matrix notation: <span class="math display">\[
   \text{SSE}_\text{pen} = (\mathbf{Y}-\mathbf{X\beta})^T(\mathbf{Y}-\mathbf{X\beta}) + \lambda \boldsymbol{\beta}^T\boldsymbol{\beta}.
 \]</span> The partial derivative w.r.t. <span class="math inline">\(\boldsymbol{\beta}\)</span> is <span class="math display">\[
   \frac{\partial}{\partial \boldsymbol{\beta}}\text{SSE}_\text{pen} = -2\mathbf{X}^T(\mathbf{Y}-\mathbf{X\beta})+2\lambda\boldsymbol{\beta}.
 \]</span> Solving <span class="math inline">\(\frac{\partial}{\partial \boldsymbol{\beta}}\text{SSE}_\text{pen}=0\)</span> gives <span class="math display">\[
   \hat{\boldsymbol{\beta}} = (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} \mathbf{X^T Y}.
 \]</span> (assumption: <span class="math inline">\((\mathbf{X^TX}+\lambda \mathbf{I})\)</span> is of rank <span class="math inline">\(p\)</span>. This is always true if <span class="math inline">\(\lambda&gt;0\)</span>)</p>
</div>
</div>
<div id="link-with-svd" class="section level2">
<h2><span class="header-section-number">4.4</span> Link with SVD</h2>
<div id="svd-and-inverse" class="section level3">
<h3><span class="header-section-number">4.4.1</span> SVD and inverse</h3>
<p>Write the SVD of <span class="math inline">\(\mathbf{X}\)</span> (<span class="math inline">\(p&gt;n\)</span>) as <span class="math display">\[
   \mathbf{X} = \sum_{i=1}^n \delta_i \mathbf{u}_i \mathbf{v}_i^T = \sum_{i=1}^p \delta_i \mathbf{u}_i \mathbf{v}_i^T  = \mathbf{U}\boldsymbol{\Delta} \mathbf{V}^T ,
\]</span> with</p>
<ul>
<li><p><span class="math inline">\(\delta_{n+1}=\delta_{n+2}= \cdots = \delta_p=0\)</span></p></li>
<li><p><span class="math inline">\(\boldsymbol{\Delta}\)</span> a <span class="math inline">\(p\times p\)</span> diagonal matrix of the <span class="math inline">\(\delta_1,\ldots, \delta_p\)</span></p></li>
<li><p><span class="math inline">\(\mathbf{U}\)</span> an <span class="math inline">\(n\times p\)</span> matrix and <span class="math inline">\(\mathbf{V}\)</span> a <span class="math inline">\(p \times p\)</span> matrix. Note that only the first <span class="math inline">\(n\)</span> columns of <span class="math inline">\(\mathbf{U}\)</span> and <span class="math inline">\(\mathbf{V}\)</span> are informative.</p></li>
</ul>
<p>With the SVD of <span class="math inline">\(\mathbf{X}\)</span> we write <span class="math display">\[
   \mathbf{X}^T\mathbf{X} = \mathbf{V}\boldsymbol{\Delta
     }^2\mathbf{V}^T.
 \]</span> The inverse of <span class="math inline">\(\mathbf{X}^T\mathbf{X}\)</span> is then given by <span class="math display">\[
   (\mathbf{X}^T\mathbf{X})^{-1} = \mathbf{V}\boldsymbol{\Delta}^{-2}\mathbf{V}^T.
 \]</span> Since <span class="math inline">\(\boldsymbol{\Delta}\)</span> has <span class="math inline">\(\delta_{n+1}=\delta_{n+2}= \cdots = \delta_p=0\)</span>, it is not invertible.</p>
</div>
<div id="svd-of-penalised-matrix-mathbfxtxlambda-mathbfi" class="section level3">
<h3><span class="header-section-number">4.4.2</span> SVD of penalised matrix <span class="math inline">\(\mathbf{X^TX}+\lambda \mathbf{I}\)</span></h3>
<p>It can be shown that <span class="math display">\[
  \mathbf{X^TX}+\lambda \mathbf{I} = \mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I}) \mathbf{V}^T ,
\]</span> i.e.Â adding a constant to the diagonal elements does not affect the eigenvectors, and all eigenvalues are increased by this constant. <span class="math inline">\(\longrightarrow\)</span> zero eigenvalues become <span class="math inline">\(\lambda\)</span>.</p>
<p>Hence, <span class="math display">\[
  (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} = \mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I})^{-1} \mathbf{V}^T ,
\]</span> which can be computed even when some eigenvalues in <span class="math inline">\(\boldsymbol{\Delta}^2\)</span> are zero.</p>
<p>Note, that for high dimensional data (<span class="math inline">\(p&gt;&gt;&gt;n\)</span>) many eigenvalues are zero because <span class="math inline">\(\mathbf{X^TX}\)</span> is a <span class="math inline">\(p \times p\)</span> matrix and has rank <span class="math inline">\(n\)</span>.</p>
<p>The identity <span class="math inline">\(\mathbf{X^TX}+\lambda \mathbf{I} = \mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I}) \mathbf{V}^T\)</span> is easily checked: <span class="math display">\[
  \mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I}) \mathbf{V}^T = \mathbf{V}\boldsymbol{\Delta}^2\mathbf{V}^T + \lambda \mathbf{VV}^T  = \mathbf{V}\boldsymbol{\Delta}^2\mathbf{V}^T + \lambda \mathbf{I} = \mathbf{X^TX}+\lambda \mathbf{I}.
\]</span></p>
</div>
</div>
<div id="properties" class="section level2">
<h2><span class="header-section-number">4.5</span> Properties</h2>
<ul>
<li><p>The Ridge estimator is biased! The <span class="math inline">\(\boldsymbol{\beta}\)</span> are shrunken to zero! <span class="math display">\[\begin{eqnarray}
 \text{E}[\hat{\boldsymbol{\beta}}] &amp;=&amp; (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} \mathbf{X}^T \text{E}[\mathbf{Y}]\\
&amp;=&amp; (\mathbf{X}^T\mathbf{X}+\lambda \mathbf{I})^{-1} \mathbf{X}^T \mathbf{X}\boldsymbol{\beta}\\
\end{eqnarray}\]</span></p></li>
<li><p>Note, that the shrinkage is larger in the direction of the smaller eigenvalues.</p></li>
</ul>
<p><span class="math display">\[\begin{eqnarray}
\text{E}[\hat{\boldsymbol{\beta}}]&amp;=&amp;\mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I})^{-1} \mathbf{V}^T \mathbf{V} \boldsymbol{\Delta}^2 \mathbf{V}^T\boldsymbol{\beta}\\
&amp;=&amp;\mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I})^{-1} \boldsymbol{\Delta}^2 \mathbf{V}^T\boldsymbol{\beta}\\
&amp;=&amp; \mathbf{V}
\left[\begin{array}{ccc}
\frac{\delta_1^2}{\delta_1^2+\lambda}&amp;\ldots&amp;0 \\
&amp;\vdots&amp;\\
0&amp;\ldots&amp;\frac{\delta_r^2}{\delta_r^2+\lambda}
\end{array}\right]
\mathbf{V}^T\boldsymbol{\beta}
\end{eqnarray}\]</span></p>
<ul>
<li><p>the variance of the prediction <span class="math inline">\(\hat{{Y}}(\mathbf{x})=\mathbf{x}^T\hat\beta\)</span>, <span class="math display">\[
 \text{var}\left[\hat{{Y}}(\mathbf{x})\mid \mathbf{x}\right] = \mathbf{x}^T(\mathbf{X^TX}+\lambda \mathbf{I})^{-1}\mathbf{x}
  \]</span> is smaller than with the least-squares estimator.</p></li>
<li><p>through the bias-variance trade-off it is hoped that better predictions in terms of expected conditional test error can be obtained, for an appropriate choice of <span class="math inline">\(\lambda\)</span>.</p></li>
</ul>
<p>Recall the expression of the expected conditional test error <span class="math display">\[\begin{eqnarray}
  Err(\mathbf{x}) &amp;=&amp; \text{E}\left[(\hat{Y} - Y^*)^2\mid \mathbf{x}\right]\\
  &amp;=&amp;
  \text{var}\left[\hat{Y}\mid \mathbf{x}\right] + \text{bias}^2(\mathbf{x})+
  \text{var}\left[Y^*\mid \mathbf{x}\right]
\end{eqnarray}\]</span> where</p>
<ul>
<li><span class="math inline">\(\hat{Y}=\hat{Y}(\mathbf{x})=\mathbf{x}^T\hat{\boldsymbol{\beta}}\)</span> is the prediction at <span class="math inline">\(\mathbf{x}\)</span></li>
<li><span class="math inline">\(Y^*\)</span> is an outcome at predictor <span class="math inline">\(\mathbf{x}\)</span></li>
<li><span class="math inline">\(\mu(\mathbf{x}) = \text{E}\left[\hat{Y}\mid \mathbf{x}\right] \text{ and } \mu^*(x)=\text{E}\left[Y^*\mid \mathbf{x}\right]\)</span></li>
<li><span class="math inline">\(\text{bias}(\mathbf{x})=\mu(\mathbf{x})-\mu^*(\mathbf{x})\)</span></li>
<li><span class="math inline">\(\text{var}\left[Y^*\mid \mathbf{x}\right]\)</span> the irreducible error that does not depend on the model. It simply originates from observations that randomly fluctuate around the true mean <span class="math inline">\(\mu^*(x)\)</span>.</li>
</ul>
</div>
<div id="toxicogenomics-example" class="section level2">
<h2><span class="header-section-number">4.6</span> Toxicogenomics example</h2>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">library</span>(glmnet)</span>
<span id="cb31-2"><a href="#cb31-2"></a>mRidge &lt;-<span class="st"> </span><span class="kw">glmnet</span>(</span>
<span id="cb31-3"><a href="#cb31-3"></a>  <span class="dt">x =</span> toxData[,<span class="op">-</span><span class="dv">1</span>] <span class="op">%&gt;%</span></span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="st">    </span>as.matrix,</span>
<span id="cb31-5"><a href="#cb31-5"></a>  <span class="dt">y =</span> toxData <span class="op">%&gt;%</span></span>
<span id="cb31-6"><a href="#cb31-6"></a><span class="st">    </span><span class="kw">pull</span>(BA),</span>
<span id="cb31-7"><a href="#cb31-7"></a>  <span class="dt">alpha =</span> <span class="dv">0</span>) <span class="co"># ridge: alpha = 0  </span></span>
<span id="cb31-8"><a href="#cb31-8"></a></span>
<span id="cb31-9"><a href="#cb31-9"></a><span class="kw">plot</span>(mRidge, <span class="dt">xvar=</span><span class="st">&quot;lambda&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>The R function  uses  to refer to the penalty parameter. In this course we use <span class="math inline">\(\lambda\)</span>, because <span class="math inline">\(\lambda\)</span> is often used as eigenvalues.</p>
<p>The graph shows that with increasing penalty parameter, the parameter estimates are shrunken towards zero. The estimates will only reach zero for <span class="math inline">\(\lambda \rightarrow \infty\)</span>. The stronger the shrinkage, the larger the bias (towards zero) and the smaller the variance of the parameter estimators (and hence also smaller variance of the predictions).</p>
<p>Another (informal) viewpoint is the following. By shrinking the estimates towards zero, the estimates loose some of their ``degrees of freedomâ€™â€™ so that the parameters become estimable with only <span class="math inline">\(n&lt;p\)</span> data points. Even with a very small <span class="math inline">\(\lambda&gt;0\)</span>, the parameters regain their estimability. However, note that the variance of the estimator is given by <span class="math display">\[
  \text{var}\left[\hat{\mathbf\beta}\right] = (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} \sigma^2 = \mathbf{V}(\boldsymbol{\Delta}^2+\lambda\mathbf{I})^{-1}\mathbf{V}^T\sigma^2.
\]</span> Hence, a small <span class="math inline">\(\lambda\)</span> will result in large variances of the parameter estimators. The larger <span class="math inline">\(\lambda\)</span>, the smaller the variances become. In the limit, as <span class="math inline">\(\lambda\rightarrow\infty\)</span>, the estimates are converged to zero and show no variability any longer.</p>
</div>
</div>
<div id="lasso-regression" class="section level1">
<h1><span class="header-section-number">5</span> Lasso Regression</h1>
<ul>
<li><p>The Lasso is another example of penalised regression.</p></li>
<li><p>The lasso estimator of <span class="math inline">\(\boldsymbol{\beta}\)</span> is the solution to minimising the penalised SSE <span class="math display">\[
 \text{SSE}_\text{pen} = \sum_{i=1}^n (Y_i - \mathbf{x}_i^T\boldsymbol{\beta})^2 + \lambda \sum_{j=1}^p \vert \beta_j\vert.
\]</span></p></li>
</ul>
<p>or, equivalently, minimising</p>
<p><span class="math display">\[
\text{SSE}  = \Vert \mathbf{Y} - \mathbf{X\beta}\Vert_2^2 \text{ subject to } \Vert \mathbf\beta\Vert_1 \leq c
\]</span> with</p>
<ul>
<li><p><span class="math inline">\(\Vert \mathbf\beta\Vert_1 = \sum\limits_{j=1}^p \vert \beta_j \vert\)</span></p></li>
<li><p>Despite strong similarity between ridge and lasso regression (<span class="math inline">\(L_2\)</span> versus <span class="math inline">\(L_1\)</span> norm in penalty term), there is no analytical solution of the lasso parameter estimate of <span class="math inline">\(\mathbf\beta\)</span>.</p></li>
<li><p>Fortunately, computational efficient algorithms have been implemented in statistical software</p></li>
<li><p>The Lasso estimator of <span class="math inline">\(\boldsymbol{\beta}\)</span> is biased and generally has a smaller variance then the least-squares estimator.</p></li>
<li><p>Hence, the bias-variance trade-off may here also help in finding better predictions with biased estimators.</p></li>
<li><p>In contrast to ridge regression, however, the lasso estimator can give at most <span class="math inline">\(\min(p,n)\)</span> non-zero <span class="math inline">\(\beta\)</span>-estimates.</p></li>
<li><p>Hence, at first sight the lasso is not directly appropriate for high-dimensional settings.</p></li>
<li><p>An important advantage of the lasso is that choosing an appropriate value for <span class="math inline">\(\lambda\)</span> is a kind a model building or feature selection procedure (see further).</p></li>
</ul>
<div id="graphical-interpretation-of-lasso-vs-ridge" class="section level2">
<h2><span class="header-section-number">5.1</span> Graphical interpretation of Lasso vs ridge</h2>
<p>Note that the lasso is a constrained regression problem with</p>
<p><span class="math display">\[
\Vert \mathbf{Y} - \mathbf{X\beta}\Vert_2^2 \text{ subject to } \Vert \mathbf\beta\Vert_1 \leq c
\]</span> and ridge <span class="math display">\[
\Vert \mathbf{Y} - \mathbf{X\beta}\Vert_2^2 \text{ subject to } \Vert \mathbf\beta\Vert^2_2 \leq c
\]</span></p>
<p><img src="prediction_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>Note, that</p>
<ul>
<li>parameters for the lasso can never switch sign, they are set at zero! Selection!</li>
<li>ridge regression can lead to parameters that switch sign.</li>
</ul>
</div>
<div id="toxicogenomics-example-1" class="section level2">
<h2><span class="header-section-number">5.2</span> Toxicogenomics example</h2>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a>mLasso &lt;-<span class="st"> </span><span class="kw">glmnet</span>(</span>
<span id="cb32-2"><a href="#cb32-2"></a>  <span class="dt">x =</span> toxData[,<span class="op">-</span><span class="dv">1</span>] <span class="op">%&gt;%</span></span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="st">    </span>as.matrix,</span>
<span id="cb32-4"><a href="#cb32-4"></a>  <span class="dt">y =</span> toxData <span class="op">%&gt;%</span></span>
<span id="cb32-5"><a href="#cb32-5"></a><span class="st">    </span><span class="kw">pull</span>(BA),</span>
<span id="cb32-6"><a href="#cb32-6"></a><span class="dt">alpha =</span> <span class="dv">1</span>)</span>
<span id="cb32-7"><a href="#cb32-7"></a><span class="kw">plot</span>(mLasso, <span class="dt">xvar =</span> <span class="st">&quot;lambda&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<ul>
<li><p>The graph with the paths of the parameter estimates nicely illustrates the typical behaviour of the lasso estimates as a function of <span class="math inline">\(\lambda\)</span>: when <span class="math inline">\(\lambda\)</span> increases the estimates are shrunken towards zero.</p></li>
<li><p>When an estimate hits zero, it remains exactly equal to zero when <span class="math inline">\(\gamma\)</span> further increases. A parameter estimate equal to zero, say <span class="math inline">\(\hat\beta_j=0\)</span>, implies that the corresponding predictor <span class="math inline">\(x_j\)</span> is no longer included in the model (i.e.Â <span class="math inline">\(\beta_jx_j=0\)</span>).</p></li>
<li><p>The model fit is known as a sparse model fit (many zeroes). Hence, choosing a appropriate value for <span class="math inline">\(\gamma\)</span> is like choosing the important predictors in the model (feature selection).</p></li>
</ul>
</div>
</div>
<div id="splines-and-the-connection-to-ridge-regression." class="section level1">
<h1><span class="header-section-number">6</span> Splines and the connection to ridge regression.</h1>
<div id="lidar-dataset" class="section level2">
<h2><span class="header-section-number">6.1</span> Lidar dataset</h2>
<ul>
<li><p>LIDAR (light detection and ranging) uses the reflection of laser-emitted light to detect chemical compounds in the atmosphere.</p></li>
<li><p>The LIDAR technique has proven to be an efficient tool for monitoring the distribution of several atmospheric pollutants of importance; see Sigrist (1994).</p></li>
<li><p>The range is the distance traveled before the light is reflected back to its source.</p></li>
<li><p>The logratio is the logarithm of the ratio of received light from two laser sources.</p>
<ul>
<li><p>One source had a frequency equal to the resonance frequency of the compound of interest, which was mercury in this study.</p></li>
<li><p>The other source had a frequency off this resonance frequency.</p></li>
<li><p>The concentration of mercury can be derived from a regression model of the logratio in function of the range for each range x.</p></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">library</span>(<span class="st">&quot;SemiPar&quot;</span>)</span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="kw">data</span>(lidar)</span>
<span id="cb33-3"><a href="#cb33-3"></a>pLidar &lt;-<span class="st"> </span>lidar <span class="op">%&gt;%</span></span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> range, <span class="dt">y =</span> logratio)) <span class="op">+</span></span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span></span>
<span id="cb33-6"><a href="#cb33-6"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;range (m)&quot;</span>)</span>
<span id="cb33-7"><a href="#cb33-7"></a></span>
<span id="cb33-8"><a href="#cb33-8"></a>pLidar <span class="op">+</span></span>
<span id="cb33-9"><a href="#cb33-9"></a><span class="st">  </span><span class="kw">geom_smooth</span>()</span></code></pre></div>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code></pre>
<p><img src="prediction_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<ul>
<li>The data is non-linear</li>
<li>Linear regression will not work!</li>
<li>The data shows a smooth relation between the logratio and the range</li>
</ul>
</div>
<div id="basis-expansion" class="section level2">
<h2><span class="header-section-number">6.2</span> Basis expansion</h2>
<p><span class="math display">\[y_i=f(x_i)+\epsilon_i,\]</span> with <span class="math display">\[f(x)=\sum\limits_{k=1}^K \theta_k b_k(x)\]</span></p>
<ul>
<li><p>Select set of basis functions <span class="math inline">\(b_k(x)\)</span></p></li>
<li><p>Select number of basis functions <span class="math inline">\(K\)</span></p></li>
<li><p>Examples</p>
<ul>
<li>Polynomial model: <span class="math inline">\(x^k\)</span></li>
<li>Orthogonal series: Fourier, Legendre polynomials, Wavelets</li>
<li>Polynomial splines: <span class="math inline">\(1, x, (x-t_m)_+\)</span> with <span class="math inline">\(m=1, \ldots, K-2\)</span> knots <span class="math inline">\(t_m\)</span></li>
<li>â€¦</li>
</ul></li>
</ul>
<div id="trunctated-line-basis" class="section level3">
<h3><span class="header-section-number">6.2.1</span> Trunctated line basis</h3>
<p><span class="math display">\[y_i=f(x_i)+\epsilon_i,\]</span></p>
<ul>
<li>One of the most simple basis expansions</li>
<li><span class="math inline">\(f(x_i)=\beta_0+\beta_1x_i+\sum\limits_{m=1}^{K-2}\theta_m(x_i-t_m)_+\)</span> with <span class="math inline">\((.)_+\)</span> the operator that takes the positive part.</li>
<li>Note, that better basis expansions exist, which are orthogonal, computational more stable and/or continuous derivative beyond first order</li>
<li>We will use this basis for didactical purposes</li>
<li>We can use OLS to fit y w.r.t. the basis.</li>
</ul>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1"></a>knots &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">400</span>,<span class="dv">700</span>,<span class="fl">12.5</span>)</span>
<span id="cb35-2"><a href="#cb35-2"></a></span>
<span id="cb35-3"><a href="#cb35-3"></a>basis &lt;-<span class="st"> </span><span class="kw">sapply</span>(knots,</span>
<span id="cb35-4"><a href="#cb35-4"></a>  <span class="cf">function</span>(k,y) (y<span class="op">-</span>k)<span class="op">*</span>(y<span class="op">&gt;</span>k),</span>
<span id="cb35-5"><a href="#cb35-5"></a>  <span class="dt">y=</span> lidar <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pull</span>(range)</span>
<span id="cb35-6"><a href="#cb35-6"></a>  )</span>
<span id="cb35-7"><a href="#cb35-7"></a></span>
<span id="cb35-8"><a href="#cb35-8"></a>basisExp &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dv">1</span>, <span class="dt">range =</span> lidar <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pull</span>(range), basis)</span>
<span id="cb35-9"><a href="#cb35-9"></a></span>
<span id="cb35-10"><a href="#cb35-10"></a>splineFitLs &lt;-<span class="st"> </span><span class="kw">lm</span>(logratio <span class="op">~</span><span class="st"> </span><span class="dv">-1</span> <span class="op">+</span><span class="st"> </span>basisExp, lidar)</span>
<span id="cb35-11"><a href="#cb35-11"></a></span>
<span id="cb35-12"><a href="#cb35-12"></a>pBasis &lt;-<span class="st"> </span>basisExp[,<span class="op">-</span><span class="dv">1</span>] <span class="op">%&gt;%</span></span>
<span id="cb35-13"><a href="#cb35-13"></a><span class="st">  </span>data.frame <span class="op">%&gt;%</span></span>
<span id="cb35-14"><a href="#cb35-14"></a><span class="st">  </span><span class="kw">gather</span>(<span class="st">&quot;basis&quot;</span>,<span class="st">&quot;values&quot;</span>,<span class="op">-</span><span class="dv">1</span>) <span class="op">%&gt;%</span></span>
<span id="cb35-15"><a href="#cb35-15"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> range, <span class="dt">y =</span> values, <span class="dt">color =</span> basis)) <span class="op">+</span></span>
<span id="cb35-16"><a href="#cb35-16"></a><span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span></span>
<span id="cb35-17"><a href="#cb35-17"></a><span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position=</span><span class="st">&quot;none&quot;</span>) <span class="op">+</span></span>
<span id="cb35-18"><a href="#cb35-18"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;basis&quot;</span>)</span>
<span id="cb35-19"><a href="#cb35-19"></a></span>
<span id="cb35-20"><a href="#cb35-20"></a><span class="kw">grid.arrange</span>(</span>
<span id="cb35-21"><a href="#cb35-21"></a>  pLidar <span class="op">+</span></span>
<span id="cb35-22"><a href="#cb35-22"></a><span class="st">    </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">x =</span> lidar<span class="op">$</span>range, <span class="dt">y =</span> splineFitLs<span class="op">$</span>fitted), <span class="dt">lwd =</span> <span class="dv">2</span>),</span>
<span id="cb35-23"><a href="#cb35-23"></a>  pBasis,</span>
<span id="cb35-24"><a href="#cb35-24"></a>  <span class="dt">ncol=</span><span class="dv">1</span>)</span></code></pre></div>
<pre><code>## Warning: Use of `lidar$range` is discouraged. Use `range` instead.</code></pre>
<p><img src="prediction_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<ul>
<li>Note, that the model is overfitting!</li>
<li>The fit is very wiggly and is tuned too much to the data.</li>
<li>The fit has a large variance and low bias.</li>
<li>It will therefore not generalise well to predict the logratio of future observations.</li>
</ul>
<div id="solution-for-overfitting" class="section level4">
<h4><span class="header-section-number">6.2.1.1</span> Solution for overfitting?</h4>
<ul>
<li><p>We could perform model selection on the basis to select the important basis functions to model the signal. But, this will have the undesired property that the fit will no longer be smooth.</p></li>
<li><p>We can also adopt a ridge penalty!</p></li>
<li><p>However, we do not want to penalise the intercept and the linear term.<br />
</p></li>
<li><p>Ridge criterion</p></li>
</ul>
<p><span class="math display">\[\Vert\mathbf{Y}-\mathbf{X\beta}\Vert^2+\lambda\boldsymbol{\beta}^T\mathbf{D}\boldsymbol{\beta}
\]</span></p>
<p>With <span class="math inline">\(\mathbf{D}\)</span> with dimensions (K,K): <span class="math inline">\(\mathbf{D}=\left[\begin{array}{cc}\mathbf{0}_{2\times2}&amp; \mathbf{0}_{2\times K-2}\\ \mathbf{0}_{K-2\times2}&amp;\mathbf{I}_{K-2\times K-2}\end{array}\right]\)</span></p>
<ul>
<li>Here we will set the penalty at 900.</li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1"></a>D &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="kw">ncol</span>(basisExp))</span>
<span id="cb37-2"><a href="#cb37-2"></a>D[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>] &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb37-3"><a href="#cb37-3"></a>lambda &lt;-<span class="st"> </span><span class="dv">900</span></span>
<span id="cb37-4"><a href="#cb37-4"></a>betaRidge &lt;-<span class="st"> </span><span class="kw">solve</span>(<span class="kw">t</span>(basisExp)<span class="op">%*%</span>basisExp<span class="op">+</span>(lambda<span class="op">*</span>D))<span class="op">%*%</span><span class="kw">t</span>(basisExp)<span class="op">%*%</span>lidar<span class="op">$</span>logratio</span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="kw">grid.arrange</span>(</span>
<span id="cb37-6"><a href="#cb37-6"></a>  pLidar <span class="op">+</span></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="st">    </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">x =</span> lidar<span class="op">$</span>range, <span class="dt">y =</span> <span class="kw">c</span>(basisExp <span class="op">%*%</span><span class="st"> </span>betaRidge)), <span class="dt">lwd =</span> <span class="dv">2</span>),</span>
<span id="cb37-8"><a href="#cb37-8"></a>  pBasis,</span>
<span id="cb37-9"><a href="#cb37-9"></a>  <span class="dt">ncol=</span><span class="dv">1</span>)</span></code></pre></div>
<pre><code>## Warning: Use of `lidar$range` is discouraged. Use `range` instead.</code></pre>
<p><img src="prediction_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<p>How do we choose <span class="math inline">\(\lambda\)</span>?</p>
<hr />
</div>
</div>
</div>
</div>
<div id="evaluation-of-prediction-models" class="section level1">
<h1><span class="header-section-number">7</span> Evaluation of Prediction Models</h1>
<p>Predictions are calculated with the fitted model <span class="math display">\[
   \hat{Y}(\mathbf{x}) = \hat{m}(\mathbf{x})=\mathbf{x}^T\hat{\beta}
 \]</span> when focussing on prediction, we want the prediction error to be as small as possible.</p>
<p>The <strong>prediction error</strong> for a prediction at covariate pattern <span class="math inline">\(\mathbf{x}\)</span> is given by <span class="math display">\[
     \hat{Y}(\mathbf{x}) - Y^*,
  \]</span> where</p>
<ul>
<li><p><span class="math inline">\(\hat{Y}(\mathbf{x})=\mathbf{x}^T\hat{\boldsymbol{\beta}}\)</span> is the prediction at <span class="math inline">\(\mathbf{x}\)</span></p></li>
<li><p><span class="math inline">\(Y^*\)</span> is an outcome at covariate pattern <span class="math inline">\(\mathbf{x}\)</span></p></li>
</ul>
<p>Prediction is typically used to predict an outcome before it is observed.</p>
<ul>
<li>Hence, the outcome <span class="math inline">\(Y^*\)</span> is not observed yet, and</li>
<li>the prediction error cannot be computed.</li>
</ul>
<hr />
<ul>
<li><p>Recall that the prediction model <span class="math inline">\(\hat{Y}(\mathbf{x})\)</span> is estimated by using data in the training data set <span class="math inline">\((\mathbf{X},\mathbf{Y})\)</span>, and</p></li>
<li><p>that the outcome <span class="math inline">\(Y^*\)</span> is an outcome at <span class="math inline">\(\mathbf{x}\)</span> which is assumed to be independent of the training data.</p></li>
<li><p>Goal is to use prediction model for predicting a future observation (<span class="math inline">\(Y^*\)</span>), i.e.Â an observation that still has to be realised/observed (otherwise prediction seems rather useless).</p></li>
<li><p>Hence, <span class="math inline">\(Y^*\)</span> can never be part of the training data set.</p></li>
</ul>
<hr />
<p>Here we provide definitions and we show how the prediction performance of a prediction model can be evaluated from data.</p>
<p>Let <span class="math inline">\({\cal{T}}=(\mathbf{Y},\mathbf{X})\)</span> denote the training data, from which the prediction model <span class="math inline">\(\hat{Y}(\cdot)\)</span> is build. This building process typically involves feature selection and parameter estimation.</p>
<p>We will use a more general notation for the prediction model: <span class="math inline">\(\hat{m}(\mathbf{x})=\hat{Y}(\mathbf{x})\)</span>.</p>
<hr />
<div id="test-or-generalisation-error" class="section level2">
<h2><span class="header-section-number">7.1</span> Test or Generalisation Error</h2>
<p>The test or generalisation error for prediction model <span class="math inline">\(\hat{m}(\cdot)\)</span> is given by <span class="math display">\[
    \text{Err}_{\cal{T}} = \text{E}_{Y^*,X^*}\left[(\hat{m}(\mathbf{X}^*) - Y^*)^2\mid {\cal{T}}\right]
  \]</span> where <span class="math inline">\((Y^*,X^*)\)</span> is independent of the training data.</p>
<hr />
<ul>
<li>Note that the test error is conditional on the training data <span class="math inline">\({\cal{T}}\)</span>.</li>
<li>Hence, the test error evaluates the performance of the single model build from the observed training data.</li>
<li>This is the ultimate target of the model assessment, because it is exactly this prediction model that will be used in practice and applied to future predictors <span class="math inline">\(\mathbf{X}^*\)</span> to predict <span class="math inline">\(Y^*\)</span>.</li>
<li>The test error is defined as an average over all such future observations <span class="math inline">\((Y^*,\mathbf{X}^*)\)</span>.</li>
</ul>
<hr />
</div>
<div id="conditional-test-error" class="section level2">
<h2><span class="header-section-number">7.2</span> Conditional test error</h2>
<p>Sometimes the conditional test error is used:</p>
<p>The conditional test error in <span class="math inline">\(\mathbf{x}\)</span> for prediction model <span class="math inline">\(\hat{m}(\mathbf{x})\)</span> is given by <span class="math display">\[
   \text{Err}_{\cal{T}}(\mathbf{x}) = \text{E}_{Y^*}\left[(\hat{m}(\mathbf{x}) - Y^*)^2\mid {\cal{T}}, \mathbf{x}\right]
 \]</span> where <span class="math inline">\(Y^*\)</span> is an outcome at predictor <span class="math inline">\(\mathbf{x}\)</span>, independent of the training data.</p>
<p>Hence, <span class="math display">\[
   \text{Err}_{\cal{T}} = \text{E}_{X^*}\left[\text{Err}_{\cal{T}}(\mathbf{X}^*)\right].
 \]</span></p>
<p>A closely related error is the <strong>insample error</strong>.</p>
<hr />
</div>
<div id="insample-error" class="section level2">
<h2><span class="header-section-number">7.3</span> Insample Error</h2>
<p>The insample error for prediction model <span class="math inline">\(\hat{m}(\mathbf{x})\)</span> is given by <span class="math display">\[
   \text{Err}_{\text{in} \cal{T}} = \frac{1}{n}\sum_{i=1}^n \text{Err}_{\cal{T}}(\mathbf{x}_i),
 \]</span></p>
<p>i.e.Â the insample error is the sample average of the conditional test errors evaluated in the <span class="math inline">\(n\)</span> training dataset predictors <span class="math inline">\(\mathbf{x}_i\)</span>.</p>
<p>Since <span class="math inline">\(\text{Err}_{\cal{T}}\)</span> is an average over all <span class="math inline">\(\mathbf{X}\)</span>, even over those predictors not observed in the training dataset, it is sometimes referred to as the <strong>outsample error</strong>.</p>
<hr />
</div>
<div id="estimation-of-the-insample-error" class="section level2">
<h2><span class="header-section-number">7.4</span> Estimation of the insample error</h2>
<p>We start with introducing the training error rate, which is closely related to the MSE in linear models.</p>
<div id="training-error" class="section level3">
<h3><span class="header-section-number">7.4.1</span> Training error</h3>
<p>The training error is given by <span class="math display">\[
   \overline{\text{err}} = \frac{1}{n}\sum_{i=1}^n (Y_i - \hat{m}(\mathbf{x}_i))^2 ,
 \]</span> where the <span class="math inline">\((Y_i,\mathbf{x}_i)\)</span> from the training dataset which is also used for the calculation of <span class="math inline">\(\hat{m}\)</span>.</p>
<ul>
<li><p>The training error is an overly optimistic estimate of the test error <span class="math inline">\(\text{Err}_{\cal{T}}\)</span>.</p></li>
<li><p>The training error will never increases when the model becomes more complex. <span class="math inline">\(\longrightarrow\)</span> cannot be used directly as a model selection criterion.</p></li>
</ul>
<p>Indeed, model parameters are often estimated by minimising the training error (cfr. SSE).</p>
<ul>
<li>Hence the fitted model adapts to the training data, and</li>
<li>training error will be an overly optimistic estimate of the test error <span class="math inline">\(\text{Err}_{\cal{T}}\)</span>.</li>
</ul>
<hr />
<p>It can be shown that the training error is related to the insample test error via</p>
<p><span class="math display">\[
\text{E}_\mathbf{Y}
\left[\text{Err}_{\text{in}{\cal{T}}}\right] = \text{E}_\mathbf{Y}\left[\overline{\text{err}}\right] + \frac{2}{n}\sum_{i=1}^n \text{cov}_\mathbf{Y}\left[\hat{m}(\mathbf{x}_i),Y_i\right],
\]</span></p>
<p>Note, that for linear models <span class="math display">\[ \hat{m}(\mathbf{x}_i) = \mathbf{X}\hat{\boldsymbol{\beta}}= \mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{Y} = \mathbf{HY}
\]</span> with</p>
<ul>
<li><span class="math inline">\(\mathbf{H}\)</span> the hat matrix and</li>
<li>all <span class="math inline">\(Y_i\)</span> are assumed to be independently distributed <span class="math inline">\(N(\mathbf{X}\boldsymbol{\beta},\sigma^2)\)</span></li>
</ul>
<p>Hence, for linear models with independent observations</p>
<p><span class="math display">\[\begin{eqnarray}
\text{cov}_\mathbf{Y}\left[\hat{m}(\mathbf{x}_i),Y_i)\right] &amp;=&amp;
\text{cov}_\mathbf{Y}\left[\mathbf{H}_{i}^T\mathbf{Y},Y_i)\right]\\
&amp;=&amp; \text{cov}_\mathbf{Y}\left[h_{ii} Y_i,Y_i\right]\\
&amp;=&amp; h_{ii} \text{cov}_\mathbf{Y}\left[Y_i,Y_i\right]\\
&amp;=&amp; h_{ii} \sigma^2\\
\end{eqnarray}\]</span></p>
<p>And we can thus estimate the insample error by Mallowâ€™s <span class="math inline">\(C_p\)</span></p>
<p><span class="math display">\[\begin{eqnarray}
C_p &amp;=&amp; \overline{\text{err}} + \frac{2\sigma^2}{n}\text{tr}(\mathbf{H})\\
&amp;=&amp; \overline{\text{err}} + \frac{2\sigma^2p}{n}
\end{eqnarray}\]</span></p>
<p>with <span class="math inline">\(p\)</span> the number of predictors.</p>
<ul>
<li>Mallowâ€™s <span class="math inline">\(C_p\)</span> is often used for model selection.</li>
<li>Note, that we can also consider it as a kind of penalized least squares:</li>
</ul>
<p><span class="math display">\[
n \times C_p = \Vert \mathbf{Y} - \mathbf{X}\boldsymbol{\beta}\Vert_2^2 + 2\sigma^2 \Vert \boldsymbol{\beta} \Vert_0
\]</span> with <span class="math inline">\(L_0\)</span> norm <span class="math inline">\(\Vert \boldsymbol{\beta} \Vert_0 = \sum_{j=1}^p \beta_p^0 = p\)</span>.</p>
<hr />
</div>
</div>
<div id="expected-test-error" class="section level2">
<h2><span class="header-section-number">7.5</span> Expected test error</h2>
<p>The test or generalisation error was defined conditionally on the training data. By averaging over the distribution of training datasets, the expected test error arises.</p>
<p><span class="math display">\[\begin{eqnarray*}
   \text{E}_{\cal{T}}\left[\text{Err}_{{\cal{T}}}\right]
     &amp;=&amp; \text{E}_{\cal{T}}\left[\text{E}_{Y^*,X^*}\left[(\hat{m}(\mathbf{X}^*) - Y^*)^2\mid {\cal{T}}\right]\right] \\
     &amp;=&amp; \text{E}_{Y^*,X^*,{\cal{T}}}\left[(\hat{m}(\mathbf{X}^*) - Y^*)^2\right].
 \end{eqnarray*}\]</span></p>
<ul>
<li><p>The expected test error may not be of direct interest when the goal is to assess the prediction performance of a single prediction model <span class="math inline">\(\hat{m}(\cdot)\)</span>.</p></li>
<li><p>The expected test error averages the test errors of all models that can be build from all training datasets, and hence this may be less relevant when the interest is in evaluating one particular model that resulted from a single observed training dataset.</p></li>
<li><p>Also note that building a prediction model involves both parameter estimation and feature selection.</p></li>
<li><p>Hence the expected test error also evaluates the feature selection procedure (on average).</p></li>
<li><p>If the expected test error is small, it is an indication that the model building process gives good predictions for future observations <span class="math inline">\((Y^*,\mathbf{X}^*)\)</span> on average.</p></li>
</ul>
<div id="estimating-the-expected-test-error" class="section level3">
<h3><span class="header-section-number">7.5.1</span> Estimating the Expected test error</h3>
<p>The expected test error may be estimated by cross validation (CV).</p>
<div id="leave-one-out-cross-validation-loocv" class="section level4">
<h4><span class="header-section-number">7.5.1.1</span> Leave one out cross validation (LOOCV)}</h4>
<p>The LOOCV estimator of the expected test error (or expected outsample error) is given by <span class="math display">\[
     \text{CV} = \frac{1}{n} \sum_{i=1}^n \left(Y_i - \hat{m}^{-i}(\mathbf{x}_i)\right)^2 ,
  \]</span> where</p>
<ul>
<li>the <span class="math inline">\((Y_i,\mathbf{x}_i)\)</span> form the training dataset</li>
<li><span class="math inline">\(\hat{m}^{-i}\)</span> is the fitted model based on all training data, except observation <span class="math inline">\(i\)</span></li>
<li><span class="math inline">\(\hat{m}^{-i}(\mathbf{x}_i)\)</span> is the prediction at <span class="math inline">\(\mathbf{x}_i\)</span>, which is the observation left out the training data before building model <span class="math inline">\(m\)</span>.</li>
</ul>
<p>Some rationale as to why LOOCV offers a good estimator of the outsample error:</p>
<ul>
<li><p>the prediction error <span class="math inline">\(Y^*-\hat{m}(\mathbf{x})\)</span> is mimicked by not using one of the training outcomes <span class="math inline">\(Y_i\)</span> for the estimation of the model so that this <span class="math inline">\(Y_i\)</span> plays the role of <span class="math inline">\(Y^*\)</span>, and, consequently, the fitted model <span class="math inline">\(\hat{m}^{-i}\)</span> is independent of <span class="math inline">\(Y_i\)</span></p></li>
<li><p>the sum in <span class="math inline">\(CV\)</span> is over all <span class="math inline">\(\mathbf{x}_i\)</span> in the training dataset, but each term <span class="math inline">\(\mathbf{x}_i\)</span> was left out once for the calculation of <span class="math inline">\(\hat{m}^{-i}\)</span>. Hence, <span class="math inline">\(\hat{m}^{-i}(\mathbf{x}_i)\)</span> mimics an outsample prediction.</p></li>
<li><p>the sum in CV is over <span class="math inline">\(n\)</span> different training datasets (each one with a different observation removed), and hence CV is an estimator of the <em>expected</em> test error.</p></li>
<li><p>For linear models the LOOCV can be readily obtained from the fitted model: i.e.</p></li>
</ul>
<p><span class="math display">\[\text{CV} = \frac{1}{n}\sum\limits_{i=1}^n \frac{e_i^2}{(1-h_{ii})^2}\]</span></p>
<p>with <span class="math inline">\(e_i\)</span> the residuals from the model that is fitted based on all training data.</p>
<hr />
<p>An alternative to LOOCV is the <span class="math inline">\(k\)</span>-fold cross validation procedure. It also gives an estimate of the expected outsample error.</p>
</div>
<div id="k-fold-cross-validation" class="section level4">
<h4><span class="header-section-number">7.5.1.2</span> <span class="math inline">\(k\)</span>-fold cross validation</h4>
<ul>
<li><p>Randomly divide the training dataset into <span class="math inline">\(k\)</span> approximately equal subsets . Let <span class="math inline">\(S_j\)</span> denote the index set of the <span class="math inline">\(j\)</span>th subset (referred to as a <strong>fold</strong>). Let <span class="math inline">\(n_j\)</span> denote the number of observations in fold <span class="math inline">\(j\)</span>.</p></li>
<li><p>The <span class="math inline">\(k\)</span>-fold cross validation estimator of the expected outsample error is given by <span class="math display">\[
   \text{CV}_k = \frac{1}{k}\sum_{j=1}^k \frac{1}{n_j} \sum_{i\in S_j} \left(Y_i - \hat{m}^{-S_j}(\mathbf{x}_i)\right)^2
 \]</span> where <span class="math inline">\(\hat{m}^{-S_j}\)</span> is the model fitted using all training data, except observations in fold <span class="math inline">\(j\)</span> (i.e.Â observations <span class="math inline">\(i \in S_j\)</span>).</p></li>
</ul>
<hr />
<p>The cross validation estimators of the expected outsample error are nearly unbiased. One argument that helps to understand where the bias comes from is the fact that e.g.Â in de LOOCV estimator the model is fit on only <span class="math inline">\(n-1\)</span> observations, whereas we are aiming at estimating the outsample error of a model fit on all <span class="math inline">\(n\)</span> training observations. Fortunately, the bias is often small and is in practice hardly a concern.</p>
<p><span class="math inline">\(k\)</span>-fold CV is computationally more complex.</p>
<p>Since CV and CV<span class="math inline">\(_k\)</span> are estimators, they also show sampling variability. Standard errors of the CV or CV<span class="math inline">\(_k\)</span> can be computed. We donâ€™t show the details, but in the example this is illustrated.</p>
</div>
</div>
<div id="bias-variance-trade-off" class="section level3">
<h3><span class="header-section-number">7.5.2</span> Bias Variance trade-off</h3>
<p>For the expected conditional test error in <span class="math inline">\(\mathbf{x}\)</span>, it holds that <span class="math display">\[\begin{eqnarray*}
  \text{E}_{\cal{T}}\left[\text{Err}_{\cal{T}}(\mathbf{x})\right]
    &amp;=&amp; \text{E}_{Y^*,{\cal{T}}}\left[(\hat{m}(\mathbf{x})-Y^*)^2 \mid \mathbf{x}\right] \\
    &amp;=&amp;  \text{var}_{\mathbf{Y}}\left[\hat{Y}(\mathbf{x})\mid \mathbf{x}\right] +(\mu(\mathbf{x})-\mu^*(\mathbf{x}))^2+\text{var}_{Y^*}\left[Y^*\mid \mathbf{x}\right]
\end{eqnarray*}\]</span> where <span class="math inline">\(\mu(\mathbf{x}) = \text{E}_{\mathbf{Y}}\left[\hat{Y}(\mathbf{x})\mid \mathbf{x}\right] \text{ and } \mu^*(\mathbf{x})=\text{E}_{Y^*}\left[Y^*\mid \mathbf{x}\right]\)</span>.</p>
<ul>
<li><p><strong>bias</strong>: <span class="math inline">\(\text{bias}(\mathbf{x})=\mu(\mathbf{x})-\mu^*(\mathbf{x})\)</span></p></li>
<li><p><span class="math inline">\(\text{var}_{Y^*}\left[Y^*\mid \mathbf{x}\right]\)</span> does not depend on the model, and is referred to as the <strong>irreducible variance</strong>.</p></li>
</ul>
<hr />
<p>The importance of the bias-variance trade-off can be seen from a model selection perspective. When we agree that a good model is a model that has a small expected conditional test error at some point <span class="math inline">\(\mathbf{x}\)</span>, then the bias-variance trade-off shows us that a model may be biased as long as it has a small variance to compensate for the bias. It often happens that a biased model has a substantial smaller variance. When these two are combined, a small expected test error may occur.</p>
<p>Also note that the model <span class="math inline">\(m\)</span> which forms the basis of the prediction model <span class="math inline">\(\hat{m}(\mathbf{x})\)</span> does NOT need to satisfy <span class="math inline">\(m(\mathbf{x})=\mu(\mathbf{x})\)</span> or <span class="math inline">\(m(\mathbf{x})=\mu^*(\mathbf{x})\)</span>. The model <span class="math inline">\(m\)</span> is known by the data-analyst (its the basis of the prediction model), whereas <span class="math inline">\(\mu(\mathbf{x})\)</span> and <span class="math inline">\(\mu^*(\mathbf{x})\)</span> are generally unknown to the data-analyst. We only hope that <span class="math inline">\(m\)</span> serves well as a prediction model.</p>
<hr />
</div>
<div id="in-practice" class="section level3">
<h3><span class="header-section-number">7.5.3</span> In practice</h3>
<p>We use cross validation to estimate the lambda penalty for penalised regression:</p>
<ul>
<li>Ridge Regression</li>
<li>Lasso</li>
<li>Build models, e.g.Â select the number of PCs for PCA regression</li>
<li>Splines</li>
</ul>
</div>
<div id="toxicogenomics-example-2" class="section level3">
<h3><span class="header-section-number">7.5.4</span> Toxicogenomics example</h3>
<div id="lasso" class="section level4">
<h4><span class="header-section-number">7.5.4.1</span> Lasso</h4>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">set.seed</span>(<span class="dv">15</span>)</span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="kw">library</span>(glmnet)</span>
<span id="cb39-3"><a href="#cb39-3"></a>mCvLasso &lt;-<span class="st"> </span><span class="kw">cv.glmnet</span>(</span>
<span id="cb39-4"><a href="#cb39-4"></a>  <span class="dt">x =</span> toxData[,<span class="op">-</span><span class="dv">1</span>] <span class="op">%&gt;%</span></span>
<span id="cb39-5"><a href="#cb39-5"></a><span class="st">    </span>as.matrix,</span>
<span id="cb39-6"><a href="#cb39-6"></a>  <span class="dt">y =</span> toxData <span class="op">%&gt;%</span></span>
<span id="cb39-7"><a href="#cb39-7"></a><span class="st">    </span><span class="kw">pull</span>(BA),</span>
<span id="cb39-8"><a href="#cb39-8"></a>  <span class="dt">alpha =</span> <span class="dv">1</span>)  <span class="co"># lasso alpha=1</span></span>
<span id="cb39-9"><a href="#cb39-9"></a></span>
<span id="cb39-10"><a href="#cb39-10"></a><span class="kw">plot</span>(mCvLasso)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<p>Default CV procedure in  is <span class="math inline">\(k=10\)</span>-fold CV.</p>
<p>The Graphs shows</p>
<ul>
<li>10-fold CV estimates of the extra-sample error as a function of the lasso penalty parameter <span class="math inline">\(\lambda\)</span>.</li>
<li>estimate plus and minus once the estimated standard error of the CV estimate (grey bars)</li>
<li>On top the number of non-zero regression parameter estimates are shown.</li>
</ul>
<p>Two vertical reference lines are added to the graph. They correspond to</p>
<ul>
<li>the <span class="math inline">\(\log(\lambda)\)</span> that gives the smallest CV estimate of the extra-sample error, and</li>
<li>the largest <span class="math inline">\(\log(\lambda)\)</span> that gives a CV estimate of the extra-sample error that is within one standard error from the smallest error estimate.</li>
<li>The latter choice of <span class="math inline">\(\lambda\)</span> has no firm theoretical basis, except that it somehow accounts for the imprecision of the error estimate. One could loosely say that this <span class="math inline">\(\gamma\)</span> corresponds to the smallest model (i.e.Â least number of predictors) that gives an error that is within margin of error of the error of the best model.</li>
</ul>
<hr />
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a>mLassoOpt &lt;-<span class="st"> </span><span class="kw">glmnet</span>(</span>
<span id="cb40-2"><a href="#cb40-2"></a>  <span class="dt">x =</span> toxData[,<span class="op">-</span><span class="dv">1</span>] <span class="op">%&gt;%</span></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="st">    </span>as.matrix,</span>
<span id="cb40-4"><a href="#cb40-4"></a>  <span class="dt">y =</span> toxData <span class="op">%&gt;%</span></span>
<span id="cb40-5"><a href="#cb40-5"></a><span class="st">    </span><span class="kw">pull</span>(BA),</span>
<span id="cb40-6"><a href="#cb40-6"></a>    <span class="dt">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb40-7"><a href="#cb40-7"></a>    <span class="dt">lambda =</span> mCvLasso<span class="op">$</span>lambda.min)</span>
<span id="cb40-8"><a href="#cb40-8"></a></span>
<span id="cb40-9"><a href="#cb40-9"></a><span class="kw">summary</span>(<span class="kw">coef</span>(mLassoOpt))</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["i"],"name":[1],"type":["int"],"align":["right"]},{"label":["j"],"name":[2],"type":["int"],"align":["right"]},{"label":["x"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"1.780154e-16"},{"1":"7","2":"1","3":"7.723008e-01"},{"1":"105","2":"1","3":"6.745130e-01"},{"1":"147","2":"1","3":"-7.480144e-01"},{"1":"420","2":"1","3":"1.275626e+00"},{"1":"453","2":"1","3":"4.271345e-02"},{"1":"1720","2":"1","3":"-4.548228e-01"},{"1":"1952","2":"1","3":"3.650587e-01"},{"1":"2032","2":"1","3":"1.233149e-04"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>With the optimal <span class="math inline">\(\lambda\)</span> (smallest error estimate) the output shows the 9 non-zero estimated regression coefficients (sparse solution).</p>
<hr />
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1"></a>mLasso1se &lt;-<span class="st"> </span><span class="kw">glmnet</span>(</span>
<span id="cb41-2"><a href="#cb41-2"></a>  <span class="dt">x =</span> toxData[,<span class="op">-</span><span class="dv">1</span>] <span class="op">%&gt;%</span></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="st">    </span>as.matrix,</span>
<span id="cb41-4"><a href="#cb41-4"></a>    <span class="dt">y=</span> toxData <span class="op">%&gt;%</span></span>
<span id="cb41-5"><a href="#cb41-5"></a><span class="st">      </span><span class="kw">pull</span>(BA),</span>
<span id="cb41-6"><a href="#cb41-6"></a>    <span class="dt">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb41-7"><a href="#cb41-7"></a>    <span class="dt">lambda =</span> mCvLasso<span class="op">$</span>lambda<span class="fl">.1</span>se)</span>
<span id="cb41-8"><a href="#cb41-8"></a></span>
<span id="cb41-9"><a href="#cb41-9"></a>mLasso1se <span class="op">%&gt;%</span></span>
<span id="cb41-10"><a href="#cb41-10"></a><span class="st">  </span>coef <span class="op">%&gt;%</span></span>
<span id="cb41-11"><a href="#cb41-11"></a><span class="st">  </span>summary</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["i"],"name":[1],"type":["int"],"align":["right"]},{"label":["j"],"name":[2],"type":["int"],"align":["right"]},{"label":["x"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"1.324855e-16"},{"1":"7","2":"1","3":"6.255918e-01"},{"1":"147","2":"1","3":"-1.767770e-02"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>This shows the solution for the largest <span class="math inline">\(\lambda\)</span> within one standard error of the optimal model. Now only 3 non-zero estimates result.</p>
<hr />
</div>
<div id="ridge" class="section level4">
<h4><span class="header-section-number">7.5.4.2</span> Ridge</h4>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1"></a>mCvRidge &lt;-<span class="st"> </span><span class="kw">cv.glmnet</span>(</span>
<span id="cb42-2"><a href="#cb42-2"></a>  <span class="dt">x =</span> toxData[,<span class="op">-</span><span class="dv">1</span>] <span class="op">%&gt;%</span></span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="st">    </span>as.matrix,</span>
<span id="cb42-4"><a href="#cb42-4"></a>    <span class="dt">y =</span> toxData <span class="op">%&gt;%</span></span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="st">      </span><span class="kw">pull</span>(BA),</span>
<span id="cb42-6"><a href="#cb42-6"></a>      <span class="dt">alpha =</span> <span class="dv">0</span>)  <span class="co"># ridge alpha=0</span></span>
<span id="cb42-7"><a href="#cb42-7"></a></span>
<span id="cb42-8"><a href="#cb42-8"></a><span class="kw">plot</span>(mCvRidge)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<ul>
<li>Ridge does not seem to have optimal solution.</li>
<li>10-fold CV is also larger than for lasso.</li>
</ul>
<hr />
</div>
<div id="pca-regression" class="section level4">
<h4><span class="header-section-number">7.5.4.3</span> PCA regression</h4>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">set.seed</span>(<span class="dv">1264</span>)</span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="kw">library</span>(DAAG)</span></code></pre></div>
<pre><code>## Loading required package: lattice</code></pre>
<pre><code>## 
## Attaching package: &#39;lattice&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:boot&#39;:
## 
##     melanoma</code></pre>
<pre><code>## The following object is masked from &#39;package:fda&#39;:
## 
##     melanoma</code></pre>
<pre><code>## 
## Attaching package: &#39;DAAG&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:plyr&#39;:
## 
##     ozone</code></pre>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1"></a>tox &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</span>
<span id="cb50-2"><a href="#cb50-2"></a>  <span class="dt">Y =</span> toxData <span class="op">%&gt;%</span></span>
<span id="cb50-3"><a href="#cb50-3"></a><span class="st">    </span><span class="kw">pull</span>(BA),</span>
<span id="cb50-4"><a href="#cb50-4"></a>  <span class="dt">PC =</span> Zk)</span>
<span id="cb50-5"><a href="#cb50-5"></a></span>
<span id="cb50-6"><a href="#cb50-6"></a>PC.seq &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">25</span></span>
<span id="cb50-7"><a href="#cb50-7"></a>Err &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">25</span>)</span>
<span id="cb50-8"><a href="#cb50-8"></a></span>
<span id="cb50-9"><a href="#cb50-9"></a>mCvPca &lt;-<span class="st"> </span><span class="kw">cv.lm</span>(</span>
<span id="cb50-10"><a href="#cb50-10"></a>  Y<span class="op">~</span>PC<span class="fl">.1</span>,</span>
<span id="cb50-11"><a href="#cb50-11"></a>  <span class="dt">data =</span> tox,</span>
<span id="cb50-12"><a href="#cb50-12"></a>  <span class="dt">m =</span> <span class="dv">5</span>,</span>
<span id="cb50-13"><a href="#cb50-13"></a>  <span class="dt">printit =</span> <span class="ot">FALSE</span>)</span>
<span id="cb50-14"><a href="#cb50-14"></a></span>
<span id="cb50-15"><a href="#cb50-15"></a>Err[<span class="dv">1</span>]&lt;-<span class="kw">attr</span>(mCvPca,<span class="st">&quot;ms&quot;</span>)</span>
<span id="cb50-16"><a href="#cb50-16"></a></span>
<span id="cb50-17"><a href="#cb50-17"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="dv">25</span>) {</span>
<span id="cb50-18"><a href="#cb50-18"></a>  mCvPca &lt;-<span class="st"> </span><span class="kw">cv.lm</span>(</span>
<span id="cb50-19"><a href="#cb50-19"></a>    <span class="kw">as.formula</span>(</span>
<span id="cb50-20"><a href="#cb50-20"></a>      <span class="kw">paste</span>(<span class="st">&quot;Y ~ PC.1 + &quot;</span>,</span>
<span id="cb50-21"><a href="#cb50-21"></a>        <span class="kw">paste</span>(<span class="st">&quot;PC.&quot;</span>, <span class="dv">2</span><span class="op">:</span>i, <span class="dt">collapse =</span> <span class="st">&quot;+&quot;</span>, <span class="dt">sep=</span><span class="st">&quot;&quot;</span>),</span>
<span id="cb50-22"><a href="#cb50-22"></a>        <span class="dt">sep=</span><span class="st">&quot;&quot;</span></span>
<span id="cb50-23"><a href="#cb50-23"></a>      )</span>
<span id="cb50-24"><a href="#cb50-24"></a>    ),</span>
<span id="cb50-25"><a href="#cb50-25"></a>    <span class="dt">data =</span> tox,</span>
<span id="cb50-26"><a href="#cb50-26"></a>    <span class="dt">m =</span> <span class="dv">5</span>,</span>
<span id="cb50-27"><a href="#cb50-27"></a>    <span class="dt">printit =</span> <span class="ot">FALSE</span>)</span>
<span id="cb50-28"><a href="#cb50-28"></a>  Err[i]&lt;-<span class="kw">attr</span>(mCvPca,<span class="st">&quot;ms&quot;</span>)</span>
<span id="cb50-29"><a href="#cb50-29"></a>}</span></code></pre></div>
<ul>
<li><p>Here we illustrate principal component regression.</p></li>
<li><p>The most important PCs are selected in a forward model selection procedure.</p></li>
<li><p>Within the model selection procedure the models are evaluated with 5-fold CV estimates of the outsample error.</p></li>
<li><p>It is important to realise that a forward model selection procedure will not necessarily result in the best prediction model, particularly because the order of the PCs is generally not related to the importance of the PCs for predicting the outcome.</p></li>
<li><p>A supervised PC would be better.</p></li>
</ul>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1"></a>pPCreg &lt;-<span class="st"> </span><span class="kw">data.frame</span>(PC.seq, Err) <span class="op">%&gt;%</span></span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> PC.seq, <span class="dt">y =</span> Err)) <span class="op">+</span></span>
<span id="cb51-3"><a href="#cb51-3"></a><span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span></span>
<span id="cb51-4"><a href="#cb51-4"></a><span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span></span>
<span id="cb51-5"><a href="#cb51-5"></a><span class="st">  </span><span class="kw">geom_hline</span>(</span>
<span id="cb51-6"><a href="#cb51-6"></a>    <span class="dt">yintercept =</span> <span class="kw">c</span>(</span>
<span id="cb51-7"><a href="#cb51-7"></a>      mCvLasso<span class="op">$</span>cvm[mCvLasso<span class="op">$</span>lambda<span class="op">==</span>mCvLasso<span class="op">$</span>lambda.min],</span>
<span id="cb51-8"><a href="#cb51-8"></a>      mCvLasso<span class="op">$</span>cvm[mCvLasso<span class="op">$</span>lambda<span class="op">==</span>mCvLasso<span class="op">$</span>lambda<span class="fl">.1</span>se]),</span>
<span id="cb51-9"><a href="#cb51-9"></a>    <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>) <span class="op">+</span></span>
<span id="cb51-10"><a href="#cb51-10"></a><span class="st">  </span><span class="kw">xlim</span>(<span class="dv">1</span>,<span class="dv">26</span>)</span>
<span id="cb51-11"><a href="#cb51-11"></a></span>
<span id="cb51-12"><a href="#cb51-12"></a><span class="kw">grid.arrange</span>(</span>
<span id="cb51-13"><a href="#cb51-13"></a>  pPCreg,</span>
<span id="cb51-14"><a href="#cb51-14"></a>  pPCreg <span class="op">+</span><span class="st"> </span><span class="kw">ylim</span>(<span class="dv">0</span>,<span class="dv">5</span>),</span>
<span id="cb51-15"><a href="#cb51-15"></a>  <span class="dt">ncol=</span><span class="dv">2</span>)</span></code></pre></div>
<pre><code>## Warning: Removed 6 row(s) containing missing values (geom_path).</code></pre>
<pre><code>## Warning: Removed 6 rows containing missing values (geom_point).</code></pre>
<p><img src="prediction_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<ul>
<li><p>The graph shows the CV estimate of the outsample error as a function of the number of sparse PCs included in the model.</p></li>
<li><p>A very small error is obtained with the model with only the first PC. The best model with 3 PCs.</p></li>
<li><p>The two vertical reference lines correspond to the error estimates obtained with lasso (optimal <span class="math inline">\(\lambda\)</span> and largest <span class="math inline">\(\lambda\)</span> within one standard error).</p></li>
<li><p>Thus although there was a priori no guarantee that the first PCs are the most predictive, it seems to be the case here (we were lucky!).</p></li>
<li><p>Moreover, the first PC resulted in a small outsample error.</p></li>
<li><p>Note that the graph does not indicate the variability of the error estimates (no error bars).</p></li>
<li><p>Also note that the graph clearly illustrates the effect of overfitting: including too many PCs causes a large outsample error.</p></li>
</ul>
</div>
</div>
<div id="lidar-example-splines" class="section level3">
<h3><span class="header-section-number">7.5.5</span> Lidar Example: splines</h3>
<ul>
<li>We use the mgcv package to fit the spline model to the lidar data.</li>
<li>A better basis is used than the truncated spline basis</li>
<li>Thin plate splines are also linear smoothers, i.e.<br />
<span class="math inline">\(\hat{Y} = \hat{m}(\mathbf{X}) = \mathbf{SY}\)</span></li>
<li>So their variance can be easily calculated.</li>
<li>The ridge/smoothness penalty is chosen by generalized cross validation.</li>
</ul>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">library</span>(mgcv)</span></code></pre></div>
<pre><code>## Loading required package: nlme</code></pre>
<pre><code>## 
## Attaching package: &#39;nlme&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:IRanges&#39;:
## 
##     collapse</code></pre>
<pre><code>## The following object is masked from &#39;package:dplyr&#39;:
## 
##     collapse</code></pre>
<pre><code>## This is mgcv 1.8-33. For overview type &#39;help(&quot;mgcv-package&quot;)&#39;.</code></pre>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1"></a>gamfit &lt;-<span class="st"> </span><span class="kw">gam</span>(logratio <span class="op">~</span><span class="st"> </span><span class="kw">s</span>(range), <span class="dt">data =</span> lidar)</span>
<span id="cb60-2"><a href="#cb60-2"></a>gamfit<span class="op">$</span>sp</span></code></pre></div>
<pre><code>##    s(range) 
## 0.006114634</code></pre>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1"></a>pLidar <span class="op">+</span></span>
<span id="cb62-2"><a href="#cb62-2"></a><span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">x =</span> lidar<span class="op">$</span>range, <span class="dt">y =</span> gamfit<span class="op">$</span>fitted), <span class="dt">lwd =</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## Warning: Use of `lidar$range` is discouraged. Use `range` instead.</code></pre>
<p><img src="prediction_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
</div>
</div>
<div id="more-general-error-definitions" class="section level2">
<h2><span class="header-section-number">7.6</span> More general error definitions</h2>
<p>So far we only looked at continuous outcomes <span class="math inline">\(Y\)</span> and errors defined in terms of the squared loss <span class="math inline">\((\hat{m}(\mathbf{x})-Y^*)^2\)</span>.</p>
<p>More generally, a <strong>loss function</strong> measures an discrepancy between the prediction <span class="math inline">\(\hat{m}(\mathbf{x})\)</span> and an independent outcome <span class="math inline">\(Y^*\)</span> that corresponds to <span class="math inline">\(\mathbf{x}\)</span>.</p>
<p>Some examples for continuous <span class="math inline">\(Y\)</span>: <span class="math display">\[\begin{eqnarray*}
  L(Y^*,\hat{m}(\mathbf{x}))
    &amp;=&amp; (\hat{m}(\mathbf{x})-Y^*)^2 \;\;\text{(squared error)} \\
  L(Y^*,\hat{m}(\mathbf{x}))
    &amp;=&amp; \vert\hat{m}(\mathbf{x})-Y^*\vert \;\;\text{(absolute error)} \\
   L(Y^*,\hat{m}(\mathbf{x}))
    &amp;=&amp; 2 \int_{\cal{Y}} f_y(y) \log\frac{f_y(y)}{f_{\hat{m}}(y)} dy \;\;\text{(deviance)}.
\end{eqnarray*}\]</span></p>
<p>In the expression of the deviance</p>
<ul>
<li><span class="math inline">\(f_y\)</span> denotes the density function of a distribution with mean set to <span class="math inline">\(y\)</span> (cfr. perfect fit), and</li>
<li><span class="math inline">\(f_{\hat{m}}\)</span> is the density function of the same distribution but with mean set to the predicted outcome <span class="math inline">\(\hat{m}(\mathbf{x})\)</span>.</li>
</ul>
<hr />
<p>With a given loss function, the errors are defined as follows: - Test or generalisation or outsample error <span class="math display">\[
      \text{Err}_{\cal{T}} = \text{E}_{Y^*,X^*}\left[L(Y^*,\hat{m}(\mathbf{X}^*))\right]
    \]</span></p>
<ul>
<li><p>Training error <span class="math display">\[
  \overline{\text{err}} = \frac{1}{n}\sum_{i=1}^n L(Y_i,\hat{m}(\mathbf{x}_i))
\]</span></p></li>
<li><p><span class="math inline">\(\ldots\)</span></p></li>
</ul>
<hr />
<p>When an exponential family distribution is assumed for the outcome distribution, and when the deviance loss is used, the insample error can be estimated by means of the AIC and BIC.</p>
<div id="akaikes-information-criterion-aic" class="section level3">
<h3><span class="header-section-number">7.6.1</span> Akaikeâ€™s Information Criterion (AIC)</h3>
<p>The AIC for a model <span class="math inline">\(m\)</span> is given by <span class="math display">\[
\text{AIC} = -2 \ln \hat{L}(m) +2p
\]</span> where <span class="math inline">\(\hat{L}(m)\)</span> is the maximised likelihood for model <span class="math inline">\(m\)</span>.</p>
<p>When assuming normally distributed error terms and homoscedasticity, the AIC becomes <span class="math display">\[
\text{AIC} = n\ln \text{SSE}(m) +2p = n\ln(n\overline{\text{err}}(m)) + 2p
\]</span> with <span class="math inline">\(\text{SSE}(m)\)</span> the residual sum of squares of model <span class="math inline">\(m\)</span>.</p>
<p>In linear models with normal error terms, Mallowâ€™s <span class="math inline">\(C_p\)</span> criterion (statistic) is a linearised version of AIC and it is an unbiased estimator of the in-sample error.</p>
<hr />
</div>
<div id="bayesian-information-criterion-bic" class="section level3">
<h3><span class="header-section-number">7.6.2</span> Bayesian Information Criterion (BIC)}</h3>
<p>The BIC for a model <span class="math inline">\(m\)</span> is given by <span class="math display">\[
\text{BIC} = -2 \ln \hat{L}(m) +p\ln(n)
\]</span> where <span class="math inline">\(\hat{L}(m)\)</span> is the maximised likelihood for model <span class="math inline">\(m\)</span>.</p>
<p>When assuming normally distributed error terms and homoscedasticity, the BIC becomes <span class="math display">\[
\text{BIC} = n\ln \text{SSE}(m) +p\ln(n) = n\ln(n\overline{\text{err}}(m)) + p\ln(n)
\]</span> with <span class="math inline">\(\text{SSE}(m)\)</span> the residual sum of squares of model <span class="math inline">\(m\)</span>.</p>
<p>When large datasets are used, the BIC will favour smaller models than the AIC.</p>
<hr />
</div>
</div>
<div id="training-and-test-sets" class="section level2">
<h2><span class="header-section-number">7.7</span> Training and test sets</h2>
<p>Sometimes, when a large (training) dataset is available, one may decide the split the dataset randomly in a</p>
<ul>
<li><p><strong>training dataset</strong>: data are used for model fitting and for model building or feature selection (this may require e.g.Â cross validation)</p></li>
<li><p><strong>test dataset</strong>: this data are used to evaluate the final model (result of model building). An unbiased estimate of the outsample error (i.e.Â test or generalisation error) based on this test data is <span class="math display">\[
   \frac{1}{m} \sum_{i=1}^m \left(\hat{m}(\mathbf{x}_i)-Y_i\right)^2,
\]</span> where</p>
<ul>
<li><p><span class="math inline">\((Y_1,\mathbf{x}_1), \ldots, (Y_m,\mathbf{x}_m)\)</span> denote the <span class="math inline">\(m\)</span> observations in the test dataset</p></li>
<li><p><span class="math inline">\(\hat{m}\)</span> is estimated from using the training data (this may also be the result from model building, using only the training data).</p></li>
</ul></li>
</ul>
<hr />
<p>Note that the training dataset is used for model building or feature selection. This also requires the evaluation of models. For these evaluations the methods from the previous slides can be used (e.g.Â cross validation, <span class="math inline">\(k\)</span>-fold CV, Mallowâ€™s <span class="math inline">\(C_p\)</span>). The test dataset is only used for the evaluation of the final model (estimated and build from using only the training data). The estimate of the outsample error based on the test dataset is the best possible estimate in the sense that it is unbiased. The observations used for this estimation are independent of the observations in the training data. However, if the number of data points in the test dataset (<span class="math inline">\(m\)</span>) is small, the estimate of the outsample error may show large variance and hence is not reliable.</p>
</div>
</div>
<div id="logistic-regression-analysis-for-high-dimensional-data" class="section level1">
<h1><span class="header-section-number">8</span> Logistic Regression Analysis for High Dimensional Data</h1>
<div id="cancer-example" class="section level2">
<h2><span class="header-section-number">8.1</span> Cancer Example</h2>
<ul>
<li><p>Schmidt <em>et al.</em>, 2008, Cancer Research, {}, 5405-5413</p></li>
<li><p>Gene expression patterns in <span class="math inline">\(n=200\)</span> breast tumors were investigated (<span class="math inline">\(p=22283\)</span> genes)</p></li>
<li><p>After surgery the tumors were graded by a pathologist (stage 1,2,3)</p></li>
<li><p>Here the objective is to predict stage 3 from the gene expression data (prediction of binary outcome)</p></li>
<li><p>If the prediction model works well, it can be used to predict the stage from a biopsy sample.</p></li>
</ul>
<hr />
</div>
<div id="logistic-regression-models" class="section level2">
<h2><span class="header-section-number">8.2</span> Logistic regression models</h2>
<p>Binary outcomes are often analysed with <strong>logistic regression models</strong>.</p>
<p>Let <span class="math inline">\(Y\)</span> denote the binary (1/0, case/control, positive/negative) outcome, and <span class="math inline">\(\mathbf{x}\)</span> the <span class="math inline">\(p\)</span>-dimensional predictor.</p>
<p>Logistic regression assumes <span class="math display">\[
   Y \mid \mathbf{x} \sim \text{Bernoulli}(\pi(\mathbf{x}))
\]</span> with <span class="math inline">\(\pi(\mathbf{x}) = \text{P}\left[Y=1\mid \mathbf{x}\right]\)</span> and <span class="math display">\[
   \ln \frac{\pi(\mathbf{x})}{1-\pi(\mathbf{x})}=\beta_0 + \boldsymbol{\beta}^T\mathbf{x}.
\]</span></p>
<p>The parameters are typically estimated by maximising the log-likelihood, which is denoted by <span class="math inline">\(l(\mathbf{ \beta})\)</span>, i.e. <span class="math display">\[
   \hat{\boldsymbol{\beta}} = \text{ArgMax}_\beta l(\boldsymbol{\beta}).
\]</span></p>
<ul>
<li><p>Maximum likelihood is only applicable when <span class="math inline">\(n&gt;p\)</span>.</p></li>
<li><p>When <span class="math inline">\(p&gt;n\)</span> penalised maximum likelihood methods are applicable.</p></li>
</ul>
<hr />
</div>
<div id="penalized-maximum-likelihood" class="section level2">
<h2><span class="header-section-number">8.3</span> Penalized maximum likelihood</h2>
<p>Penalised estimation methods (e.g.Â lasso and ridge) can als be applied to maximum likelihood, resulting in the <strong>penalised maximum likelihood estimate</strong>.</p>
<p>Lasso: <span class="math display">\[
  \hat{\boldsymbol{\beta}} = \text{ArgMax}_\beta l(\boldsymbol{\beta}) -\lambda \Vert \boldsymbol{\beta}\Vert_1.
\]</span></p>
<p>Ridge: <span class="math display">\[
  \hat{\boldsymbol{\beta}} = \text{ArgMax}_\beta l(\boldsymbol{\beta}) -\lambda \Vert \boldsymbol{\beta}\Vert_2^2.
\]</span></p>
<p>Once the parameters are estimated, the model may be used to compute <span class="math display">\[
  \hat{\pi}(\mathbf{x}) = \hat{\text{P}}\left[Y=1\mid \mathbf{x}\right].
\]</span> With these estimated probabilities the prediction rule becomes <span class="math display">\[\begin{eqnarray*}
  \hat{\pi}(\mathbf{x}) &amp;\leq c&amp; \text{predict } Y=0 \\
  \hat{\pi}(\mathbf{x}) &amp;&gt;c &amp; \text{predict } Y=1
\end{eqnarray*}\]</span> with <span class="math inline">\(0&lt;c&lt;1\)</span> a threshold that either is fixed (e.g.Â <span class="math inline">\(c=1/2\)</span>), depends on prior probabilities, or is empirically determined by optimising e.g.Â the Area Under the ROC Curve (AUC) or by finding a good compromise between sensitivity and specificity.</p>
<p>Note that logistic regression directly models the <strong>Posterior probability</strong> that an observation belongs to class <span class="math inline">\(Y=1\)</span>, given the predictor <span class="math inline">\(\mathbf{x}\)</span>.</p>
</div>
<div id="model-evaluation" class="section level2">
<h2><span class="header-section-number">8.4</span> Model evaluation</h2>
<p>Common model evaluation criteria for binary prediction models are:</p>
<ul>
<li><p>sensitivity = true positive rate (TPR)</p></li>
<li><p>specificity = true negative rate (TNR)</p></li>
<li><p>misclassification error</p></li>
<li><p>area under the ROC curve (AUC)</p></li>
</ul>
<p>These criteria can again be estimated via cross validation or via splitting of the data into training and test/validation data.</p>
<div id="sensitivity-of-a-model-pi-with-threshold-c" class="section level3">
<h3><span class="header-section-number">8.4.1</span> Sensitivity of a model <span class="math inline">\(\pi\)</span> with threshold <span class="math inline">\(c\)</span></h3>
<p>Sensitivity is the probability to correctly predict a positive outcome: <span class="math display">\[
\text{sens}(\pi,c)=\text{P}_{X^*}\left[\hat\pi(\mathbf{X}^*)&gt;c \mid Y^*=1 \mid {\cal{T}}\right].
\]</span></p>
<p>It is also known as the true positive rate (TPR).</p>
</div>
<div id="specificity-of-a-model-pi-with-threshold-c" class="section level3">
<h3><span class="header-section-number">8.4.2</span> Specificity of a model <span class="math inline">\(\pi\)</span> with threshold <span class="math inline">\(c\)</span></h3>
<p>Specificity is the probability to correctly predict a negative outcome: <span class="math display">\[
\text{spec}(\pi,c)=\text{P}_{X^*}\left[\hat\pi(\mathbf{X}^*)\leq c \mid Y^*=0 \mid {\cal{T}}\right].
\]</span></p>
<p>It is also known as the true negative rate (TNR).</p>
<hr />
</div>
<div id="misclassification-error-of-a-model-pi-with-threshold-c" class="section level3">
<h3><span class="header-section-number">8.4.3</span> Misclassification error of a model <span class="math inline">\(\pi\)</span> with threshold <span class="math inline">\(c\)</span></h3>
<p>The misclassification error is the probability to incorrectly predict an outcome: <span class="math display">\[\begin{eqnarray*}
\text{mce}(\pi,c) &amp;=&amp;\text{P}_{X^*,Y^*}\left[\hat\pi(\mathbf{X})\leq c \text{ and } Y^*=1 \mid {\cal{T}}\right] \\
&amp;  &amp; + \text{P}_{X^*,Y^*}\left[\hat\pi(\mathbf{X})&gt; c \text{ and } Y^*=0 \mid {\cal{T}}\right].
\end{eqnarray*}\]</span></p>
<p>Note that in the definitions of sensitivity, specificity and the misclassification error, the probabilities refer to the distribution of the <span class="math inline">\((\mathbf{X}^*,Y^*)\)</span>, which is independent of the training data, conditional on the training data. This is in line with the test or generalisation error. The misclassification error is actually the test error when a 0/1 loss function is used. Just as before, the sensitivity, specificity and the misclassification error can also be averaged over the distribution of the training data set, which is in line with the expected test error which has been discussed earlier.</p>
<hr />
</div>
<div id="roc-curve-of-a-model-pi" class="section level3">
<h3><span class="header-section-number">8.4.4</span> ROC curve of a model <span class="math inline">\(\pi\)</span></h3>
<p>The Receiver Operating Characteristic (ROC) curve for model <span class="math inline">\(\pi\)</span> is given by the function</p>
<p><span class="math display">\[
\text{ROC}: [0,1] \rightarrow [0,1]\times [0,1]: c \mapsto (1-\text{spec}(\pi,c), \text{sens}(\pi,c)).
\]</span></p>
<p>For when <span class="math inline">\(c\)</span> moves from 1 to 0, the ROC function defines a curve in the plane <span class="math inline">\([0,1]\times [0,1]\)</span>, moving from <span class="math inline">\((0,0)\)</span> for <span class="math inline">\(c=1\)</span> to <span class="math inline">\((1,1)\)</span> for <span class="math inline">\(c=0\)</span>.</p>
<p>The horizontal axis of the ROC curve shows 1-specificity. This is also known as the False Positive Rate (FPR).</p>
<hr />
</div>
<div id="area-under-the-curve-auc-of-a-model-pi" class="section level3">
<h3><span class="header-section-number">8.4.5</span> Area under the curve (AUC) of a model <span class="math inline">\(\pi\)</span></h3>
<p>The area under the curve (AUC) for model <span class="math inline">\(\pi\)</span> is area under the ROC curve and is given by <span class="math display">\[
\int_0^1 \text{ROC}(c) dc.
\]</span></p>
<p>Some notes about the AUC:</p>
<ul>
<li><p>AUC=0.5 results when the ROC curve is the diagonal. This corresponds to flipping a coin, i.e.Â a complete random prediction.</p></li>
<li><p>AUC=1 results from the perfect ROC curve, which is the ROC curve through the points <span class="math inline">\((0,0)\)</span>, <span class="math inline">\((0,1)\)</span> and <span class="math inline">\((1,1)\)</span>. This ROC curve includes a threshold <span class="math inline">\(c\)</span> such that sensitivity and specificity are equal to one.</p></li>
</ul>
</div>
</div>
<div id="breast-cancer-example" class="section level2">
<h2><span class="header-section-number">8.5</span> Breast cancer example</h2>
<div id="data-1" class="section level3">
<h3><span class="header-section-number">8.5.1</span> Data</h3>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1"></a><span class="kw">library</span>(glmnet)</span>
<span id="cb64-2"><a href="#cb64-2"></a></span>
<span id="cb64-3"><a href="#cb64-3"></a><span class="co">#BiocManager::install(&quot;genefu&quot;)</span></span>
<span id="cb64-4"><a href="#cb64-4"></a><span class="co">#BiocManager::install(&quot;breastCancerMAINZ&quot;)</span></span>
<span id="cb64-5"><a href="#cb64-5"></a></span>
<span id="cb64-6"><a href="#cb64-6"></a><span class="kw">library</span>(genefu)</span>
<span id="cb64-7"><a href="#cb64-7"></a><span class="kw">library</span>(breastCancerMAINZ)</span>
<span id="cb64-8"><a href="#cb64-8"></a><span class="kw">data</span>(mainz)</span>
<span id="cb64-9"><a href="#cb64-9"></a></span>
<span id="cb64-10"><a href="#cb64-10"></a>X &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">exprs</span>(mainz)) <span class="co"># gene expressions</span></span>
<span id="cb64-11"><a href="#cb64-11"></a>n &lt;-<span class="st"> </span><span class="kw">nrow</span>(X)</span>
<span id="cb64-12"><a href="#cb64-12"></a>H &lt;-<span class="st"> </span><span class="kw">diag</span>(n)<span class="op">-</span><span class="dv">1</span><span class="op">/</span>n<span class="op">*</span><span class="kw">matrix</span>(<span class="dv">1</span>,<span class="dt">ncol=</span>n,<span class="dt">nrow=</span>n)</span>
<span id="cb64-13"><a href="#cb64-13"></a>X &lt;-<span class="st"> </span>H<span class="op">%*%</span>X</span>
<span id="cb64-14"><a href="#cb64-14"></a>Y &lt;-<span class="st"> </span><span class="kw">ifelse</span>(<span class="kw">pData</span>(mainz)<span class="op">$</span>grade<span class="op">==</span><span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb64-15"><a href="#cb64-15"></a><span class="kw">table</span>(Y)</span></code></pre></div>
<pre><code>## Y
##   0   1 
## 165  35</code></pre>
<hr />
<p>From the table of the outcomes in Y we read that</p>
<ul>
<li>35 tumors were graded as stage 3 and</li>
<li>165 tumors were graded as stage 1 or 2.</li>
</ul>
<p>In this the stage 3 tumors are referred to as cases or postives and the stage 1 and 2 tumors as controls or negatives.</p>
<hr />
</div>
<div id="training-and-test-dataset" class="section level3">
<h3><span class="header-section-number">8.5.2</span> Training and test dataset</h3>
<p>The use of the lasso logistic regression for the prediction of stage 3 breast cancer is illustrated here by</p>
<ul>
<li><p>randomly splitting the dataset into a training dataset (<span class="math inline">\(80\%\)</span> of data = 160 tumors) and a test dataset (40 tumors)</p></li>
<li><p>using the training data to select a good <span class="math inline">\(\lambda\)</span> value in the lasso logistic regression model (through 10-fold CV)</p></li>
<li><p>evaluating the final model by means of the test dataset (ROC Curve, AUC).</p></li>
</ul>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1"></a><span class="co">## Used to provide same results as in previous R version</span></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="kw">RNGkind</span>(<span class="dt">sample.kind =</span> <span class="st">&quot;Rounding&quot;</span>)</span></code></pre></div>
<pre><code>## Warning in RNGkind(sample.kind = &quot;Rounding&quot;): non-uniform &#39;Rounding&#39; sampler
## used</code></pre>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1"></a><span class="kw">set.seed</span>(<span class="dv">6977326</span>)</span>
<span id="cb68-2"><a href="#cb68-2"></a><span class="co">####</span></span>
<span id="cb68-3"><a href="#cb68-3"></a></span>
<span id="cb68-4"><a href="#cb68-4"></a>n &lt;-<span class="st"> </span><span class="kw">nrow</span>(X)</span>
<span id="cb68-5"><a href="#cb68-5"></a>nTrain &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="fl">0.8</span><span class="op">*</span>n)</span>
<span id="cb68-6"><a href="#cb68-6"></a>nTrain</span></code></pre></div>
<pre><code>## [1] 160</code></pre>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1"></a>indTrain &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>n,nTrain)</span>
<span id="cb70-2"><a href="#cb70-2"></a>XTrain &lt;-<span class="st"> </span>X[indTrain,]</span>
<span id="cb70-3"><a href="#cb70-3"></a>YTrain &lt;-<span class="st"> </span>Y[indTrain]</span>
<span id="cb70-4"><a href="#cb70-4"></a>XTest &lt;-<span class="st"> </span>X[<span class="op">-</span>indTrain,]</span>
<span id="cb70-5"><a href="#cb70-5"></a>YTest &lt;-<span class="st"> </span>Y[<span class="op">-</span>indTrain]</span>
<span id="cb70-6"><a href="#cb70-6"></a><span class="kw">table</span>(YTest)</span></code></pre></div>
<pre><code>## YTest
##  0  1 
## 32  8</code></pre>
<p>Note that the randomly selected test data has 20% cases of stage 3 tumors. This is a bit higher than the 17.5% in the complete data.</p>
<p>One could also perform the random splitting among the positives and the negatives separately (stratified splitting).</p>
</div>
<div id="model-fitting-based-on-training-data" class="section level3">
<h3><span class="header-section-number">8.5.3</span> Model fitting based on training data</h3>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1"></a>mLasso &lt;-<span class="st"> </span><span class="kw">glmnet</span>(</span>
<span id="cb72-2"><a href="#cb72-2"></a>  <span class="dt">x =</span> XTrain,</span>
<span id="cb72-3"><a href="#cb72-3"></a>  <span class="dt">y =</span> YTrain,</span>
<span id="cb72-4"><a href="#cb72-4"></a>  <span class="dt">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb72-5"><a href="#cb72-5"></a>  <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>)  <span class="co"># lasso: alpha = 1</span></span>
<span id="cb72-6"><a href="#cb72-6"></a></span>
<span id="cb72-7"><a href="#cb72-7"></a><span class="kw">plot</span>(mLasso, <span class="dt">xvar =</span> <span class="st">&quot;lambda&quot;</span>, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="op">-</span><span class="dv">6</span>,<span class="op">-</span><span class="fl">1.5</span>))</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p>
<hr />
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1"></a>mCvLasso &lt;-<span class="st"> </span><span class="kw">cv.glmnet</span>(</span>
<span id="cb73-2"><a href="#cb73-2"></a>  <span class="dt">x =</span> XTrain,</span>
<span id="cb73-3"><a href="#cb73-3"></a>  <span class="dt">y =</span> YTrain,</span>
<span id="cb73-4"><a href="#cb73-4"></a>  <span class="dt">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb73-5"><a href="#cb73-5"></a>  <span class="dt">type.measure =</span> <span class="st">&quot;class&quot;</span>,</span>
<span id="cb73-6"><a href="#cb73-6"></a>    <span class="dt">family =</span> <span class="st">&quot;binomial&quot;</span>)  <span class="co"># lasso alpha = 1</span></span>
<span id="cb73-7"><a href="#cb73-7"></a></span>
<span id="cb73-8"><a href="#cb73-8"></a><span class="kw">plot</span>(mCvLasso)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1"></a>mCvLasso</span></code></pre></div>
<pre><code>## 
## Call:  cv.glmnet(x = XTrain, y = YTrain, type.measure = &quot;class&quot;, alpha = 1,      family = &quot;binomial&quot;) 
## 
## Measure: Misclassification Error 
## 
##     Lambda Measure      SE Nonzero
## min 0.1044  0.1437 0.03366      18
## 1se 0.1911  0.1688 0.03492       0</code></pre>
<p>The total misclassification error is used here to select a good value for <span class="math inline">\(\lambda\)</span>.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1"></a><span class="co"># BiocManager::install(&quot;plotROC&quot;)</span></span>
<span id="cb76-2"><a href="#cb76-2"></a><span class="kw">library</span>(plotROC)</span>
<span id="cb76-3"><a href="#cb76-3"></a></span>
<span id="cb76-4"><a href="#cb76-4"></a>dfLassoOpt &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</span>
<span id="cb76-5"><a href="#cb76-5"></a>  <span class="dt">pi =</span> <span class="kw">predict</span>(mCvLasso,</span>
<span id="cb76-6"><a href="#cb76-6"></a>    <span class="dt">newx =</span> XTest,</span>
<span id="cb76-7"><a href="#cb76-7"></a>    <span class="dt">s =</span> mCvLasso<span class="op">$</span>lambda.min,</span>
<span id="cb76-8"><a href="#cb76-8"></a>    <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">c</span>(.),</span>
<span id="cb76-9"><a href="#cb76-9"></a>  <span class="dt">known.truth =</span> YTest)</span>
<span id="cb76-10"><a href="#cb76-10"></a></span>
<span id="cb76-11"><a href="#cb76-11"></a>roc &lt;-</span>
<span id="cb76-12"><a href="#cb76-12"></a><span class="st">  </span>dfLassoOpt  <span class="op">%&gt;%</span></span>
<span id="cb76-13"><a href="#cb76-13"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">d =</span> known.truth, <span class="dt">m =</span> pi)) <span class="op">+</span></span>
<span id="cb76-14"><a href="#cb76-14"></a><span class="st">  </span><span class="kw">geom_roc</span>(<span class="dt">n.cuts =</span> <span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb76-15"><a href="#cb76-15"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;1-specificity (FPR)&quot;</span>) <span class="op">+</span></span>
<span id="cb76-16"><a href="#cb76-16"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;sensitivity (TPR)&quot;</span>)</span>
<span id="cb76-17"><a href="#cb76-17"></a></span>
<span id="cb76-18"><a href="#cb76-18"></a>roc</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1"></a><span class="kw">calc_auc</span>(roc)</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["PANEL"],"name":[1],"type":["fct"],"align":["left"]},{"label":["group"],"name":[2],"type":["int"],"align":["right"]},{"label":["AUC"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"-1","3":"0.8320312"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<ul>
<li><p>The ROC curve is shown for the model based on <span class="math inline">\(\lambda\)</span> with the smallest misclassification error. The model has an AUC of 0.83.</p></li>
<li><p>Based on this ROC curve an appropriate threshold <span class="math inline">\(c\)</span> can be chosen. For example, from the ROC curve we see that it is possible to attain a specificity and a sensitivity of 75%.</p></li>
<li><p>The sensitivities and specificities in the ROC curve are unbiased (independent test dataset) for the prediction model build from the training data. The estimates of sensitivity and specificity, however, are based on only 40 observations.</p></li>
</ul>
<hr />
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1"></a>mLambdaOpt &lt;-<span class="st"> </span><span class="kw">glmnet</span>(<span class="dt">x =</span> XTrain,</span>
<span id="cb78-2"><a href="#cb78-2"></a>  <span class="dt">y =</span> YTrain,</span>
<span id="cb78-3"><a href="#cb78-3"></a>  <span class="dt">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb78-4"><a href="#cb78-4"></a>  <span class="dt">lambda =</span> mCvLasso<span class="op">$</span>lambda.min,</span>
<span id="cb78-5"><a href="#cb78-5"></a>  <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>)</span>
<span id="cb78-6"><a href="#cb78-6"></a></span>
<span id="cb78-7"><a href="#cb78-7"></a><span class="kw">qplot</span>(</span>
<span id="cb78-8"><a href="#cb78-8"></a>  <span class="kw">summary</span>(<span class="kw">coef</span>(mLambdaOpt))[<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>],</span>
<span id="cb78-9"><a href="#cb78-9"></a>  <span class="kw">summary</span>(<span class="kw">coef</span>(mLambdaOpt))[<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>]) <span class="op">+</span></span>
<span id="cb78-10"><a href="#cb78-10"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;gene ID&quot;</span>) <span class="op">+</span></span>
<span id="cb78-11"><a href="#cb78-11"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;beta-hat&quot;</span>) <span class="op">+</span></span>
<span id="cb78-12"><a href="#cb78-12"></a><span class="st">  </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">0</span>, <span class="dt">color =</span> <span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-35-1.png" width="672" /></p>
<ul>
<li>The model with the optimal <span class="math inline">\(\lambda\)</span> has only 19 non-zero parameter estimates.</li>
<li>Thus only 19 genes are involved in the prediction model.</li>
<li>These 19 parameter estimates are plotting in the graph. A listing of the model output would show the names of the genes.</li>
</ul>
<hr />
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1"></a>dfLasso1se &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</span>
<span id="cb79-2"><a href="#cb79-2"></a>  <span class="dt">pi =</span> <span class="kw">predict</span>(mCvLasso,</span>
<span id="cb79-3"><a href="#cb79-3"></a>    <span class="dt">newx =</span> XTest,</span>
<span id="cb79-4"><a href="#cb79-4"></a>    <span class="dt">s =</span> mCvLasso<span class="op">$</span>lambda<span class="fl">.1</span>se,</span>
<span id="cb79-5"><a href="#cb79-5"></a>    <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">c</span>(.),</span>
<span id="cb79-6"><a href="#cb79-6"></a>  <span class="dt">known.truth =</span> YTest)</span>
<span id="cb79-7"><a href="#cb79-7"></a></span>
<span id="cb79-8"><a href="#cb79-8"></a>roc &lt;-</span>
<span id="cb79-9"><a href="#cb79-9"></a><span class="st">  </span><span class="kw">rbind</span>(</span>
<span id="cb79-10"><a href="#cb79-10"></a>    dfLassoOpt <span class="op">%&gt;%</span></span>
<span id="cb79-11"><a href="#cb79-11"></a><span class="st">      </span><span class="kw">mutate</span>(<span class="dt">method =</span> <span class="st">&quot;min&quot;</span>),</span>
<span id="cb79-12"><a href="#cb79-12"></a>    dfLasso1se <span class="op">%&gt;%</span></span>
<span id="cb79-13"><a href="#cb79-13"></a><span class="st">      </span><span class="kw">mutate</span>(<span class="dt">method =</span> <span class="st">&quot;1se&quot;</span>)</span>
<span id="cb79-14"><a href="#cb79-14"></a>  ) <span class="op">%&gt;%</span></span>
<span id="cb79-15"><a href="#cb79-15"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">d =</span> known.truth, <span class="dt">m =</span> pi, <span class="dt">color =</span> method)) <span class="op">+</span></span>
<span id="cb79-16"><a href="#cb79-16"></a><span class="st">  </span><span class="kw">geom_roc</span>(<span class="dt">n.cuts =</span> <span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb79-17"><a href="#cb79-17"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;1-specificity (FPR)&quot;</span>) <span class="op">+</span></span>
<span id="cb79-18"><a href="#cb79-18"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;sensitivity (TPR)&quot;</span>)</span>
<span id="cb79-19"><a href="#cb79-19"></a></span>
<span id="cb79-20"><a href="#cb79-20"></a>roc</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-36-1.png" width="672" /></p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1"></a><span class="kw">calc_auc</span>(roc)</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["PANEL"],"name":[1],"type":["fct"],"align":["left"]},{"label":["group"],"name":[2],"type":["int"],"align":["right"]},{"label":["AUC"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"0.5000000"},{"1":"1","2":"2","3":"0.8320312"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<ul>
<li><p>When using the <span class="math inline">\(\lambda\)</span> of the optimal model up to 1 standard deviation, a diagonal ROC curve is obtained and hence AUC is <span class="math inline">\(0.5\)</span>.</p></li>
<li><p>This prediction model is thus equivalent to flipping a coin for making the prediction.</p></li>
<li><p>The reason is that with this choice of <span class="math inline">\(\lambda\)</span> (strong penalisation) almost all predictors are removed from the model.</p></li>
<li><p>Therefore, do never blindly choose for the ``optimalâ€™â€™ <span class="math inline">\(\lambda\)</span> as defined here, but assess the performance of the model first.</p></li>
</ul>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1"></a>mLambda1se &lt;-<span class="st"> </span><span class="kw">glmnet</span>(<span class="dt">x =</span> XTrain,</span>
<span id="cb81-2"><a href="#cb81-2"></a>  <span class="dt">y =</span> YTrain,</span>
<span id="cb81-3"><a href="#cb81-3"></a>  <span class="dt">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb81-4"><a href="#cb81-4"></a>  <span class="dt">lambda =</span> mCvLasso<span class="op">$</span>lambda<span class="fl">.1</span>se,</span>
<span id="cb81-5"><a href="#cb81-5"></a>  <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>)</span>
<span id="cb81-6"><a href="#cb81-6"></a></span>
<span id="cb81-7"><a href="#cb81-7"></a>mLambda1se <span class="op">%&gt;%</span></span>
<span id="cb81-8"><a href="#cb81-8"></a><span class="st">  </span>coef <span class="op">%&gt;%</span></span>
<span id="cb81-9"><a href="#cb81-9"></a><span class="st">  </span>summary</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["i"],"name":[1],"type":["int"],"align":["right"]},{"label":["j"],"name":[2],"type":["int"],"align":["right"]},{"label":["x"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"-1.594512"},{"1":"2","2":"1","3":"0.000000"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<hr />
</div>
</div>
<div id="the-elastic-net" class="section level2">
<h2><span class="header-section-number">8.6</span> The Elastic Net</h2>
<p>The lasso and ridge regression have positive and negative properties.</p>
<ul>
<li><p>Lasso</p>
<ul>
<li><p>positive: sparse solution</p></li>
<li><p>negative: at most <span class="math inline">\(\min(n,p)\)</span> predictors can be selected</p></li>
<li><p>negative: tend to select one predictor among a group of highly correlated predictors</p></li>
</ul></li>
<li><p>Ridge</p>
<ul>
<li>negative: no sparse solution</li>
<li>positive: more than <span class="math inline">\(\min(n,p)\)</span> predictors can be selected</li>
</ul></li>
</ul>
<p>A compromise between lasso and ridge: the <strong>elastic net</strong>: <span class="math display">\[
  \hat{\boldsymbol{\beta}} = \text{ArgMax}_\beta l(\boldsymbol{\beta}) -\gamma_1 \vert \boldsymbol\beta\vert -\gamma_2 \Vert \boldsymbol\beta\Vert_2^2.
\]</span></p>
<p>The elastic gives a sparse solution with potentially more than <span class="math inline">\(\min(n,p)\)</span> predictors.</p>
<hr />
<p>The <code>glmnet</code> R function uses the following parameterisation, <span class="math display">\[
  \hat{\boldsymbol{\beta}} = \text{ArgMax}_\beta l(\boldsymbol{\beta}) -\lambda\alpha \Vert \boldsymbol\beta\Vert_0 -\lambda(1-\alpha) \Vert \boldsymbol\beta\Vert_2^2.
\]</span></p>
<ul>
<li><p><span class="math inline">\(\alpha\)</span> parameter gives weight to <span class="math inline">\(L_1\)</span> penalty term (hence <span class="math inline">\(\alpha=1\)</span> gives the lasso, and <span class="math inline">\(\alpha=0\)</span> gives ridge).</p></li>
<li><p>a <span class="math inline">\(\lambda\)</span> parameter to give weight to the penalisation</p></li>
<li><p>Note that the combination of <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(\alpha\)</span> gives the same flexibility as the combination of the parameters <span class="math inline">\(\lambda_1\)</span> and <span class="math inline">\(\lambda_2\)</span>.</p></li>
</ul>
<hr />
<div id="breast-cancer-example-1" class="section level3">
<h3><span class="header-section-number">8.6.1</span> Breast cancer example</h3>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1"></a>mElastic &lt;-<span class="st"> </span><span class="kw">glmnet</span>(</span>
<span id="cb82-2"><a href="#cb82-2"></a>  <span class="dt">x =</span> XTrain,</span>
<span id="cb82-3"><a href="#cb82-3"></a>  <span class="dt">y =</span> YTrain,</span>
<span id="cb82-4"><a href="#cb82-4"></a>  <span class="dt">alpha =</span> <span class="fl">0.5</span>,</span>
<span id="cb82-5"><a href="#cb82-5"></a>  <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>)  <span class="co"># elastic net</span></span>
<span id="cb82-6"><a href="#cb82-6"></a></span>
<span id="cb82-7"><a href="#cb82-7"></a><span class="kw">plot</span>(mElastic, <span class="dt">xvar =</span> <span class="st">&quot;lambda&quot;</span>,<span class="dt">xlim=</span><span class="kw">c</span>(<span class="op">-</span><span class="fl">5.5</span>,<span class="op">-</span><span class="dv">1</span>))</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-38-1.png" width="672" /></p>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1"></a>mCvElastic &lt;-<span class="st"> </span><span class="kw">cv.glmnet</span>(<span class="dt">x =</span> XTrain,</span>
<span id="cb83-2"><a href="#cb83-2"></a>  <span class="dt">y =</span> YTrain,</span>
<span id="cb83-3"><a href="#cb83-3"></a>  <span class="dt">alpha =</span> <span class="fl">0.5</span>,</span>
<span id="cb83-4"><a href="#cb83-4"></a>  <span class="dt">family =</span> <span class="st">&quot;binomial&quot;</span>,</span>
<span id="cb83-5"><a href="#cb83-5"></a>    <span class="dt">type.measure =</span> <span class="st">&quot;class&quot;</span>)  <span class="co"># elastic net</span></span>
<span id="cb83-6"><a href="#cb83-6"></a></span>
<span id="cb83-7"><a href="#cb83-7"></a><span class="kw">plot</span>(mCvElastic)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-39-1.png" width="672" /></p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1"></a>mCvElastic</span></code></pre></div>
<pre><code>## 
## Call:  cv.glmnet(x = XTrain, y = YTrain, type.measure = &quot;class&quot;, alpha = 0.5,      family = &quot;binomial&quot;) 
## 
## Measure: Misclassification Error 
## 
##      Lambda Measure      SE Nonzero
## min 0.01859  0.1313 0.02708     148
## 1se 0.21876  0.1562 0.03391      26</code></pre>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1"></a>dfElast &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</span>
<span id="cb86-2"><a href="#cb86-2"></a>  <span class="dt">pi =</span> <span class="kw">predict</span>(mElastic,</span>
<span id="cb86-3"><a href="#cb86-3"></a>    <span class="dt">newx =</span> XTest,</span>
<span id="cb86-4"><a href="#cb86-4"></a>    <span class="dt">s =</span> mCvElastic<span class="op">$</span>lambda.min,</span>
<span id="cb86-5"><a href="#cb86-5"></a>    <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">c</span>(.),</span>
<span id="cb86-6"><a href="#cb86-6"></a>  <span class="dt">known.truth =</span> YTest)</span>
<span id="cb86-7"><a href="#cb86-7"></a></span>
<span id="cb86-8"><a href="#cb86-8"></a>roc &lt;-<span class="st"> </span><span class="kw">rbind</span>(</span>
<span id="cb86-9"><a href="#cb86-9"></a>  dfLassoOpt <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">method =</span> <span class="st">&quot;lasso&quot;</span>),</span>
<span id="cb86-10"><a href="#cb86-10"></a>  dfElast <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">method =</span> <span class="st">&quot;elast. net&quot;</span>)) <span class="op">%&gt;%</span></span>
<span id="cb86-11"><a href="#cb86-11"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">d =</span> known.truth, <span class="dt">m =</span> pi, <span class="dt">color =</span> method)) <span class="op">+</span></span>
<span id="cb86-12"><a href="#cb86-12"></a><span class="st">  </span><span class="kw">geom_roc</span>(<span class="dt">n.cuts =</span> <span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb86-13"><a href="#cb86-13"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;1-specificity (FPR)&quot;</span>) <span class="op">+</span></span>
<span id="cb86-14"><a href="#cb86-14"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;sensitivity (TPR)&quot;</span>)</span>
<span id="cb86-15"><a href="#cb86-15"></a></span>
<span id="cb86-16"><a href="#cb86-16"></a>roc</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-40-1.png" width="672" /></p>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1"></a><span class="kw">calc_auc</span>(roc)</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["PANEL"],"name":[1],"type":["fct"],"align":["left"]},{"label":["group"],"name":[2],"type":["int"],"align":["right"]},{"label":["AUC"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"0.8398438"},{"1":"1","2":"2","3":"0.8320312"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<ul>
<li>More parameters are used than for the lasso, but the performance does not improve.</li>
</ul>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1"></a>mElasticOpt &lt;-<span class="st"> </span><span class="kw">glmnet</span>(<span class="dt">x =</span> XTrain,</span>
<span id="cb88-2"><a href="#cb88-2"></a>  <span class="dt">y =</span> YTrain,</span>
<span id="cb88-3"><a href="#cb88-3"></a>  <span class="dt">alpha =</span> <span class="fl">0.5</span>,</span>
<span id="cb88-4"><a href="#cb88-4"></a>  <span class="dt">lambda =</span> mCvElastic<span class="op">$</span>lambda.min,</span>
<span id="cb88-5"><a href="#cb88-5"></a>  <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>)</span>
<span id="cb88-6"><a href="#cb88-6"></a></span>
<span id="cb88-7"><a href="#cb88-7"></a><span class="kw">qplot</span>(</span>
<span id="cb88-8"><a href="#cb88-8"></a>  <span class="kw">summary</span>(<span class="kw">coef</span>(mElasticOpt))[<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>],</span>
<span id="cb88-9"><a href="#cb88-9"></a>  <span class="kw">summary</span>(<span class="kw">coef</span>(mElasticOpt))[<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>]) <span class="op">+</span></span>
<span id="cb88-10"><a href="#cb88-10"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;gene ID&quot;</span>) <span class="op">+</span></span>
<span id="cb88-11"><a href="#cb88-11"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;beta-hat&quot;</span>) <span class="op">+</span></span>
<span id="cb88-12"><a href="#cb88-12"></a><span class="st">  </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">0</span>, <span class="dt">color =</span> <span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-41-1.png" width="672" /></p>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiMy4gUHJlZGljdGlvbiB3aXRoIEhpZ2ggRGltZW5zaW9uYWwgUHJlZGljdG9ycyIKYXV0aG9yOiAiTGlldmVuIENsZW1lbnQiCmRhdGU6ICJzdGF0T21pY3MsIEdoZW50IFVuaXZlcnNpdHkgKGh0dHBzOi8vc3RhdG9taWNzLmdpdGh1Yi5pbykiCm91dHB1dDoKICAgIGh0bWxfZG9jdW1lbnQ6CiAgICAgIGNvZGVfZG93bmxvYWQ6IHRydWUKICAgICAgdGhlbWU6IGNvc21vCiAgICAgIHRvYzogdHJ1ZQogICAgICB0b2NfZmxvYXQ6IHRydWUKICAgICAgaGlnaGxpZ2h0OiB0YW5nbwogICAgICBudW1iZXJfc2VjdGlvbnM6IHRydWUKLS0tCgpgYGB7ciBlY2hvPUZBTFNFLCBtZXNzYWdlPSBGQUxTRX0KbGlicmFyeSh0aWR5dmVyc2UpCmxpYnJhcnkoZ3JpZEV4dHJhKQpgYGAKCiMgSW50cm9kdWN0aW9uCgojIyBQcmVkaWN0aW9uIHdpdGggSGlnaCBEaW1lbnNpb25hbCBQcmVkaWN0b3JzCgpHZW5lcmFsIHNldHRpbmc6CgotICAgQWltOiBidWlsZCBhICoqcHJlZGljdGlvbiBtb2RlbCoqIHRoYXQgZ2l2ZXMgYSBwcmVkaWN0aW9uIG9mIGFuIG91dGNvbWUgZm9yIGEgZ2l2ZW4gc2V0IG9mIHByZWRpY3RvcnMuCgotIFdlIHVzZSAkWCQgdG8gcmVmZXIgdG8gdGhlIHByZWRpY3RvcnMgYW5kICRZJCB0byByZWZlciB0byB0aGUgb3V0Y29tZS4KCgotIEEgKip0cmFpbmluZyBkYXRhIHNldCoqIGlzIGF2YWlsYWJsZSwgc2F5ICQoXG1hdGhiZntYfSxcbWF0aGJme1l9KSQuIEl0IGNvbnRhaW5zICRuJCBvYnNlcnZhdGlvbnMgb24gb3V0Y29tZXMgYW5kIG9uICRwJCBwcmVkaWN0b3JzLgoKLSBVc2luZyB0aGUgdHJhaW5pbmcgZGF0YSwgYSBwcmVkaWN0aW9uIG1vZGVsIGlzIGJ1aWxkLCBzYXkgJFxoYXR7bX0oXG1hdGhiZntYfSkkLiBUaGlzIHR5cGljYWxseSBpbnZvbHZlcyAqKm1vZGVsIGJ1aWxkaW5nIChmZWF0dXJlIHNlbGVjdGlvbikqKiBhbmQgcGFyYW1ldGVyIGVzdGltYXRpb24uCgoKLSAgIER1cmluZyB0aGUgbW9kZWwgYnVpbGRpbmcsIHBvdGVudGlhbCAqKm1vZGVscyBuZWVkIHRvIGJlIGV2YWx1YXRlZCoqIGluIHRlcm1zIG9mIHRoZWlyIHByZWRpY3Rpb24gcXVhbGl0eS4KCiMjIEV4YW1wbGU6IFRveGljb2dlbm9taWNzIGluIGVhcmx5IGRydWcgZGV2ZWxvcG1lbnQKCiMjIyBCYWNrZ3JvdW5kCgotIEVmZmVjdCBvZiBjb21wb3VuZCBvbiBnZW5lIGV4cHJlc3Npb24uCgotIEluc2lnaHQgaW4gYWN0aW9uIGFuZCB0b3hpY2l0eSBvZiBkcnVnIGluIGVhcmx5IHBoYXNlCi0gRGV0ZXJtaW5lIGFjdGl2aXR5IHdpdGggYmlvLWFzc2F5OiBlLmcuIGJpbmRpbmcgYWZmaW5pdHkgb2YgY29tcG91bmQgdG8gY2VsbCB3YWxsIHJlY2VwdG9yICh0YXJnZXQsIElDNTApLgotIEVhcmx5IHBoYXNlOiAgMjAgdG8gNTAgY29tcG91bmRzCi0gQmFzZWQgb24gaW4gdml0cm8gcmVzdWx0cyBvbmUgYWltcyB0byBnZXQgaW5zaWdodCBpbiBob3cgdG8gYnVpbGQgYmV0dGVyIGNvbXBvdW5kIChoaWdoZXIgb24tdGFyZ2V0IGFjdGl2aXR5IGxlc3MgdG94aWNpdHkuCi0gU21hbGwgdmFyaWF0aW9ucyBpbiBtb2xlY3VsYXIgc3RydWN0dXJlIGxlYWQgdG8gdmFyaWF0aW9ucyBpbiBCQSBhbmQgZ2VuZSBleHByZXNzaW9uLgotIEFpbTogQnVpbGQgbW9kZWwgdG8gcHJlZGljdCBiaW8tYWN0aXZpdHkgYmFzZWQgb24gZ2VuZSBleHByZXNzaW9uIGluIGxpdmVyIGNlbGwgbGluZS4KCiMjIyBEYXRhCgotIDMwIGNoZW1pY2FsIGNvbXBvdW5kcyBoYXZlIGJlZW4gc2NyZWVuZWQgZm9yIHRveGljaXR5CgotIEJpb2Fzc2F5IGRhdGEgb24gdG94aWNpdHkgc2NyZWVuaW5nCgotIEdlbmUgZXhwcmVzc2lvbnMgaW4gYSBsaXZlciBjZWxsIGxpbmUgYXJlIHByb2ZpbGVkIGZvciBlYWNoIGNvbXBvdW5kICg0MDAwIGdlbmVzKQoKCmBgYHtyfQp0b3hEYXRhIDwtIHJlYWRfY3N2KCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RhdE9taWNzL0hEQTIwMjAvZGF0YS90b3hEYXRhQ2VudGVyZWQuY3N2IikKc3ZkWCA8LSBzdmQodG94RGF0YVssLTFdKQpgYGAKCkRhdGEgaXMgYWxyZWFkeSBjZW50ZXJlZDoKCmBgYHtyfQp0b3hEYXRhICU+JQogIGNvbE1lYW5zICU+JQogIHJhbmdlCmBgYAoKYGBge3J9CiB0b3hEYXRhICU+JQogIG5hbWVzICU+JQogIGhlYWQKYGBgCgotIEZpcnN0IGNvbHVtbiBjb250YWlucyBkYXRhIG9uIEJpb2Fzc2F5LgotIFRoZSBoaWdoZXIgdGhlIHNjb3JlIG9uIEJpb2Fzc2F5IHRoZSBtb3JlIHRveGljIHRoZSBjb21wb3VuZAotIE90aGVyIGNvbHVtbnMgY29udGFpbiBkYXRhIG9uIGdlbmUgZXhwcmVzc2lvbiBYMSwgLi4uICwgWDQwMDAKCiMjIyBEYXRhIGV4cGxvcmF0aW9uCgpgYGB7cn0KdG94RGF0YSAlPiUKICBnZ3Bsb3QoYWVzKHg9IiIseT1CQSkpICsKICBnZW9tX2JveHBsb3Qob3V0bGllci5zaGFwZT1OQSkgKwogIGdlb21fcG9pbnQocG9zaXRpb249ImppdHRlciIpCmBgYAoKYGBge3J9CnN2ZFggPC0gdG94RGF0YVssLTFdICU+JQogIHN2ZAoKayA8LSAyClZrIDwtIHN2ZFgkdlssMTprXQpVayA8LSBzdmRYJHVbLDE6a10KRGsgPC0gZGlhZyhzdmRYJGRbMTprXSkKWmsgPC0gVWslKiVEawpjb2xuYW1lcyhaaykgPC0gcGFzdGUwKCJaIiwxOmspCmNvbG5hbWVzKFZrKSA8LSBwYXN0ZTAoIlYiLDE6aykKClprICU+JQogIGFzLmRhdGEuZnJhbWUgJT4lCiAgbXV0YXRlKEJBID0gdG94RGF0YSAlPiUgcHVsbChCQSkpICU+JQogIGdncGxvdChhZXMoeD0gWjEsIHkgPSBaMiwgY29sb3IgPSBCQSkpICsKICBnZW9tX3BvaW50KHNpemUgPSAzKSArCiAgc2NhbGVfY29sb3VyX2dyYWRpZW50Mihsb3cgPSAiYmx1ZSIsbWlkPSJ3aGl0ZSIsaGlnaD0icmVkIikgKwogIGdlb21fcG9pbnQoc2l6ZSA9IDMsIHBjaCA9IDIxLCBjb2xvciA9ICJibGFjayIpCmBgYAoKLSBTY29yZXMgb24gdGhlIGZpcnN0IHR3byBwcmluY2lwYWwgY29tcG9uZW50cyAob3IgTURTIHBsb3QpLgotIEVhY2ggcG9pbnQgY29ycmVzcG9uZHMgdG8gYSBjb21wb3VuZC4KLSBDb2xvciBjb2RlIHJlZmVycyB0byB0aGUgdG94aWNpdHkgc2NvcmUgKGhpZ2hlciBzY29yZSBtb3JlIHRveGljKS4KLSBDbGVhciBzZXBhcmF0aW9uIGJldHdlZW4gY29tcG91bmRzIGFjY29yZGluZyB0byB0b3hpY2l0eS4KCi0tLQoKLSBOZXh0IGxvZ2ljIHN0ZXAgaW4gYSBQQ0EgaXMgdG8gaW50ZXJwcmV0IHRoZSBwcmluY2lwYWwgY29tcG9uZW50cy4KLSBXZSB0aHVzIGhhdmUgdG8gYXNzZXNzIHRoZSBsb2FkaW5ncy4KLSBXZSBjYW4gYWRkIGEgdmVjdG9yIGZvciBlYWNoIGdlbmUgdG8gZ2V0IGEgYmlwbG90LCBidXQgdGhpcyB3b3VsZCByZXF1aXJlIHBsb3R0aW5nIDQwMDAgdmVjdG9ycywgd2hpY2ggd291bGQgcmVuZGVyIHRoZSBwbG90IHVucmVhZGFibGUuCgpBbHRlcm5hdGl2ZSBncmFwaCB0byBsb29rIGF0IHRoZSBtYW55IGxvYWRpbmdzIG9mIHRoZSBmaXJzdCB0d28gUENzLgoKYGBge3J9CmdyaWQuYXJyYW5nZSgKICBWayAlPiUKICAgIGFzLmRhdGEuZnJhbWUgJT4lCiAgICBtdXRhdGUoZ2VuZUlEID0gMTpucm93KFZrKSkgJT4lCiAgICBnZ3Bsb3QoYWVzKHggPSBnZW5lSUQsIHkgPSBWMSkpICsKICAgIGdlb21fcG9pbnQocGNoPTIxKSArCiAgICBnZW9tX2hsaW5lKHlpbnRlcmNlcHQgPSBjKC0yLDAsMikqc2QoVmtbLDFdKSwgY29sID0gInJlZCIpICwKICBWayAlPiUKICAgIGFzLmRhdGEuZnJhbWUgJT4lCiAgICBtdXRhdGUoZ2VuZUlEID0gMTpucm93KFZrKSkgJT4lCiAgICBnZ3Bsb3QoYWVzKHggPSBnZW5lSUQsIHkgPSBWMikpICsKICAgIGdlb21fcG9pbnQocGNoPTIxKSArCiAgICBnZW9tX2hsaW5lKHlpbnRlcmNlcHQgPSBjKC0yLDAsMikqc2QoVmtbLDJdKSwgY29sID0gInJlZCIpLAogIG5jb2w9MikKYGBgCgotIEl0IGlzIGFsbW9zdCBpbXBvc3NpYmxlIHRvIGludGVycHJldCB0aGUgUENzIGJlY2F1c2UgdGhlcmUgYXJlIDQwMDAgZ2VuZXMgY29udHJpYnV0aW5nIHRvIGVhY2ggUEMuCgotIEluIGFuIGF0dGVtcHQgdG8gZmluZCB0aGUgbW9zdCBpbXBvcnRhbnQgZ2VuZXMgKGluIHRoZSBzZW5zZSB0aGF0IHRoZXkgZHJpdmUgdGhlIGludGVycHJldGF0aW9uIG9mIHRoZSBQQ3MpLCB0aGUgcGxvdHMgc2hvdyBob3Jpem9udGFsIHJlZmVyZW5jZSBsaW5lczogdGhlIGF2ZXJhZ2Ugb2YgdGhlIGxvYWRpbmdzLCBhbmQgdGhlIGF2ZXJhZ2UgwrEgdHdpY2UgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgbG9hZGluZ3MuIEluIGJldHdlZW4gdGhlIGxpbmVzIHdlIGV4cGVjdHMgYWJvdXQgOTUlIG9mIHRoZSBsb2FkaW5ncyAoaWYgdGhleSB3ZXJlIG5vcm1hbGx5IGRpc3RyaWJ1dGVkKS4KCi0gVGhlIHBvaW50cyBvdXRzaWRlIHRoZSBiYW5kIGNvbWUgZnJvbSB0aGUgZ2VuZXMgdGhhdCBoYXZlIHJhdGhlciBsYXJnZSBsb2FkaW5ncyAoaW4gYWJzb2x1dGUgdmFsdWUpIGFuZCBoZW5jZSBhcmUgaW1wb3J0YW50IGZvciB0aGUgaW50ZXJwcmV0YXRpb24gb2YgdGhlIFBDcy4KCi0gTm90ZSwgdGhhdCBwYXJ0aWN1bGFybHkgZm9yIHRoZSBmaXJzdCBQQywgb25seSBhIGZldyBnZW5lcyBzaG93IGEgbWFya2VkbHkgbGFyZ2UgbG9hZGluZ3MgdGhhdCBhcmUgbmVnYXRpdmUuIFRoaXMgbWVhbnMgdGhhdCBhbiB1cHJlZ3VsYXRpb24gb2YgdGhlc2UgZ2VuZXMgd2lsbCBsZWFkIHRvIGxvdyBzY29yZXMgb24gUEMxLgotIFRoZXNlIGdlbmVzIHdpbGwgdmVyeSBsaWtlbHkgcGxheSBhbiBpbXBvcnRhbnQgcm9sZSBpbiB0aGUgdG94aWNpdHkgbWVjaGFuaXNtLgotIEluZGVlZCwgbG93IHNjb3JlcyBvbiBQQzEgYXJlIGluIHRoZSBkaXJlY3Rpb24gb2YgbW9yZSB0b3hpY2l0eS4KLSBJbiB0aGUgbmV4dCBjaGFwdGVyIHdlIHdpbGwgaW50cm9kdWNlIGEgbWV0aG9kIHRvIG9idGFpbiBzcGFyc2UgUENzLgoKIyMjIFByZWRpY3Rpb24gbW9kZWwKCmBgYHtyfQptMSA8LSBsbShCQSB+IC0xICsgLiwgdG94RGF0YSkKCm0xICU+JQogIGNvZWYgJT4lCiAgaGVhZCg0MCkKCm0xICU+JQogIGNvZWYgJT4lCiAgaXMubmEgJT4lCiAgc3VtCgpzdW1tYXJ5KG0xKSRyLnNxdWFyZWQKYGBgCgpQcm9ibGVtPz8KCiMjIEJyYWluIGV4YW1wbGUKCi0gQ291cnRlc3kgdG8gU29sb21vbiBLdXJ6LiBTdGF0aXN0aWNhbCByZXRoaW5raW5nIHdpdGggYnJtcywgZ2dwbG90MiwgYW5kIHRoZSB0aWR5dmVyc2UgdmVyc2lvbiAxLjIuMC4KCmh0dHBzOi8vYm9va2Rvd24ub3JnL2NvbnRlbnQvMzg5MC8KaHR0cHM6Ly9naXRodWIuY29tL0FTS3Vyei9TdGF0aXN0aWNhbF9SZXRoaW5raW5nX3dpdGhfYnJtc19nZ3Bsb3QyX2FuZF90aGVfdGlkeXZlcnNlCgotIERhdGEgd2l0aCBicmFpbiBzaXplIGFuZCBib2R5IHNpemUgZm9yIHNldmVuIHNwZWNpZXMKCmBgYHtyfQpicmFpbiA8LQp0aWJibGUoc3BlY2llcyA9IGMoImFmYXJlbnNpcyIsICJhZnJpY2FudXMiLCAiaGFiaWxpcyIsICJib2lzZWkiLCAicnVkb2xmZW5zaXMiLCAiZXJnYXN0ZXIiLCAic2FwaWVucyIpLAogICAgICAgYnJhaW4gICA9IGMoNDM4LCA0NTIsIDYxMiwgNTIxLCA3NTIsIDg3MSwgMTM1MCksCiAgICAgICBtYXNzICAgID0gYygzNy4wLCAzNS41LCAzNC41LCA0MS41LCA1NS41LCA2MS4wLCA1My41KSkKYGBgCgojIyMgRGF0YSBleHBsb3JhdGlvbgoKYGBge3J9CmJyYWluCgpwIDwtIGJyYWluICU+JQogIGdncGxvdChhZXMoeCA9ICBtYXNzLCB5ID0gYnJhaW4sIGxhYmVsID0gc3BlY2llcykpICsKICBnZW9tX3BvaW50KCkKCnAgKyBnZW9tX3RleHQobnVkZ2VfeSA9IDQwKQpgYGAKCiMjIyBNb2RlbHMKClNpeCBtb2RlbHMgcmFuZ2UgaW4gY29tcGxleGl0eSBmcm9tIHRoZSBzaW1wbGUgdW5pdmFyaWF0ZSBtb2RlbAoKXGJlZ2lue2FsaWduKn0KXHRleHR7YnJhaW59X2kgJiBcc2ltIFxvcGVyYXRvcm5hbWV7Tm9ybWFsfSAoXG11X2ksIFxzaWdtYSkgXFwKXG11X2kgJiA9IFxiZXRhXzAgKyBcYmV0YV8xIFx0ZXh0e21hc3N9X2ksClxlbmR7YWxpZ24qfQoKdG8gdGhlIGRpenp5aW5nIHNpeHRoLWRlZ3JlZSBwb2x5bm9taWFsIG1vZGVsCgpcYmVnaW57YWxpZ24qfQpcdGV4dHticmFpbn1faSAmIFxzaW0gXG9wZXJhdG9ybmFtZXtOb3JtYWx9IChcbXVfaSwgXHNpZ21hKSBcXApcbXVfaSAmID0gXGJldGFfMCArIFxiZXRhXzEgXHRleHR7bWFzc31faSArIFxiZXRhXzIgXHRleHR7bWFzc31faV4yICsgXGJldGFfMyBcdGV4dHttYXNzfV9pXjMgKyBcYmV0YV80IFx0ZXh0e21hc3N9X2leNCArIFxiZXRhXzUgXHRleHR7bWFzc31faV41ICsgXGJldGFfNiBcdGV4dHttYXNzfV9pXjYuClxlbmR7YWxpZ24qfQoKYGBge3IsIG1lc3NhZ2UgPSBGLCB3YXJuaW5nID0gRn0KZm9ybXVsYXMgPC0gc2FwcGx5KDE6NiwgZnVuY3Rpb24oaSkKICByZXR1cm4oCiAgICAgcGFzdGUwKCJJKG1hc3NeIiwxOmksIikiKSAlPiUgcGFzdGUoY29sbGFwc2U9IiArICIpCiAgICApICAKKQoKZm9ybXVsYXMgPC0gc2FwcGx5KAogIHBhc3RlMCgiYnJhaW4gfiAiLCBmb3JtdWxhcyksCiAgYXMuZm9ybXVsYSkKCm1vZGVscyA8LSBsYXBwbHkoZm9ybXVsYXMsIGxtICwgZGF0YSA9IGJyYWluKQpgYGAKCmBgYHtyfQpkYXRhLmZyYW1lKAogIGZvcm11bGE9Zm9ybXVsYXMgJT4lCiAgICBhcy5jaGFyYWN0ZXIsCiAgcjIgPSBzYXBwbHkoCiAgICBtb2RlbHMsCiAgICBmdW5jdGlvbihtb2QpIHN1bW1hcnkobW9kKSRyLnNxdWFyZWQpCiAgKSAgJT4lCiAgZ2dwbG90KAogICAgYWVzKHggPSByMiwKICAgICAgeSA9IGZvcm11bGEsCiAgICAgIGxhYmVsID0gcjIgJT4lCiAgICAgICAgcm91bmQoMikgJT4lCiAgICAgICAgYXMuY2hhcmFjdGVyKQogICkgKwogIGdlb21fdGV4dCgpCmBgYAoKV2UgcGxvdCB0aGUgZml0IGZvciBlYWNoIG1vZGVsIGluZGl2aWR1YWxseSBhbmQgdGhlbSBhcnJhbmdlIHRoZW0gdG9nZXRoZXIgaW4gb25lIHBsb3QuCgpgYGB7cn0KcGxvdHMgPC0gbGFwcGx5KDE6NiwgZnVuY3Rpb24oaSkKewogIHAgKwogIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsbSIsIGZvcm11bGEgPSB5IH4gcG9seSh4LGkpKSArCiAgZ2d0aXRsZSgKICAgIHBhc3RlMCgKICAgICAgInIyID0gIiwKICAgICAgcm91bmQoc3VtbWFyeShtb2RlbHNbW2ldXSkkci5zcXVhcmVkKjEwMCwxKSwKICAgICAgIiUiKQogICAgKQp9KQoKZG8uY2FsbCgiZ3JpZC5hcnJhbmdlIixjKHBsb3RzLCBuY29sID0gMykpCmBgYAoKLSBXZSBjbGVhcmx5IHNlZSB0aGF0IGluY3JlYXNpbmcgdGhlIG1vZGVsIGNvbXBsZXhpdHkgYWx3YXlzIHByb2R1Y2VzIGEgZml0IHdpdGggYSBzbWFsbGVyIFNTRS4KLSBUaGUgcHJvYmxlbSBvZiBvdmVyZml0dGluZyBpcyB2ZXJ5IG9idmlvdXMuIFRoZSBtb3JlIGNvbXBsZXggcG9seW5vbWlhbCBtb2RlbHMgd2lsbCBub3QgZ2VuZXJhbGlzZSB3ZWxsIGZvciBwcmVkaWN0aW9uIQotIFdlIGV2ZW4gaGF2ZSBhIG1vZGVsIHRoYXQgZml0cyB0aGUgZGF0YSBwZXJmZWN0bHksIGJ1dCB0aGF0IHdpbGwgbWFrZSB2ZXJ5IGFic3VyZCBwcmVkaXRpb25zIQoKLSBUb28gZmV3IHBhcmFtZXRlcnMgaHVydHMsIHRvby4gRml0IHRoZSB1bmRlcmZpdCBpbnRlcmNlcHQtb25seSBtb2RlbC4KCmBgYHtyfQptMCA8LSBsbShicmFpbiB+IDEsIGJyYWluKQpzdW1tYXJ5KG0wKQoKcCArCiAgc3RhdF9zbW9vdGgobWV0aG9kID0gImxtIiwgZm9ybXVsYSA9IHkgfiAxKSArCiAgZ2d0aXRsZSgKICAgIHBhc3RlMCgKICAgICAgInIyID0gIiwKICAgICAgcm91bmQoc3VtbWFyeShtMCkkci5zcXVhcmVkKjEwMCwxKSwKICAgICAgIiUiKQogICAgKQpgYGAKClRoZSB1bmRlcmZpdCBtb2RlbCBkaWQgbm90IGxlYXJuIGFueXRoaW5nIGFib3V0IHRoZSByZWxhdGlvbiBiZXR3ZWVuIG1hc3MgYW5kIGJyYWluLiBJdCB3b3VsZCBhbHNvIGRvIGEgdmVyeSBwb29yIGpvYiBmb3IgcHJlZGljdGluZyBuZXcgZGF0YS4KCiMjIE92ZXJ2aWV3CgpXZSB3aWxsIG1ha2UgYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIGNvbnRpbnVvdXMgYW5kIGRpc2NyZXRlIG91dGNvbWVzLiBJbiB0aGlzIGNvdXJzZSB3ZSBmb2N1cyBvbgoKLSBMaW5lYXIgcmVncmVzc2lvbiBtb2RlbHMgZm9yIGNvbnRpbm91cyBvdXRjb21lcwoKICAtIFBlbmFsaXNlZCByZWdyZXNzaW9uOiBMYXNzbyBhbmQgcmlkZ2UKICAtIFByaW5jaXBhbCBjb21wb25lbnQgcmVncmVzc2lvbiAoUENSKQoKLSBMb2dpc3RpYyByZWdyZXNzaW9uIG1vZGVscyBmb3IgYmluYXJ5IG91dGNvbWVzCgogIC0gUGVuYWxpc2VkIHJlZ3Jlc3Npb246IExhc3NvIGFuZCByaWRnZQoKRm9yIGFsbCB0eXBlcyBvZiBtb2RlbCwgd2Ugd2lsbCBkaXNjdXNzIGZlYXR1cmUgc2VsZWN0aW9uIG1ldGhvZHMuCgojIExpbmVhciBSZWdyZXNzaW9uIGZvciBIaWdoIERpbWVuc2lvbmFsIERhdGEKCkNvbnNpZGVyIGxpbmVhciByZWdyZXNzaW9uIG1vZGVsIChmb3IgZG91YmxlIGNlbnRlcmVkIGRhdGEpClxbCiAgWV9pID0gXGJldGFfMVhfe2kxfSArIFxiZXRhXzIgWF97aTJ9ICsgXGNkb3RzICsgXGJldGFfcFhfe2lwfSArIFxlcHNpbG9uX2kgLApcXQp3aXRoICRcdGV4dHtFfVxsZWZ0W1xlcHNpbG9uIFxtaWQgXG1hdGhiZntYfVxyaWdodF09MCQgYW5kICRcdGV4dHt2YXJ9XGxlZnRbXGVwc2lsb24gXG1pZCBcbWF0aGJme1h9XHJpZ2h0XT1cc2lnbWFeMiQuCgpJbiBtYXRyaXggbm90YXRpb24gdGhlIG1vZGVsIGJlY29tZXMKXFsKICBcbWF0aGJme1l9ID0gXG1hdGhiZntYfVxtYXRoYmZcYmV0YSArIFxtYXRoYmZcZXBzaWxvbi4KXF0KVGhlIGxlYXN0IHNxdWFyZXMgZXN0aW1hdG9yIG9mICRcbWF0aGJmXGJldGEkIGlzIGdpdmVuIGJ5ClxbCiAgXGhhdHtcbWF0aGJmXGJldGF9ID0gKFxtYXRoYmZ7WH1eVFxtYXRoYmZ7WH0pXnstMX1cbWF0aGJme1h9XlRcbWF0aGJme1l9ICwKXF0KYW5kIHRoZSB2YXJpYW5jZSBvZiAkXGhhdHtcbWF0aGJmXGJldGF9JCBlcXVhbHMKXFsKICBcdGV4dHt2YXJ9XGxlZnRbXGhhdHtcbWF0aGJmXGJldGF9XHJpZ2h0XSA9IChcbWF0aGJme1h9XlRcbWF0aGJme1h9KV57LTF9XHNpZ21hXjIuClxdCiRcbG9uZ3JpZ2h0YXJyb3ckIHRoZSAkcCBcdGltZXMgcCQgbWF0cml4ICQoXG1hdGhiZntYfV5UXG1hdGhiZntYfSleey0xfSQgaXMgY3J1Y2lhbAoKTm90ZSwgdGhhdAoKLSB3aXRoIGRvdWJsZSBjZW50ZXJlZCBkYXRhIGl0IGlzIG1lYW50IHRoYXQgYm90aCB0aGUgcmVzcG9uc2VzIGFyZSBjZW50ZXJlZCAobWVhbiBvZiAkXG1hdGhiZntZfSQgaXMgemVybykgYW5kIHRoYXQgYWxsIHByZWRpY3RvcnMgYXJlIGNlbnRlcmVkIChjb2x1bW5zIG9mICRcbWF0aGJme1h9JCBoYXZlIHplcm8gbWVhbikuIFdpdGggZG91YmxlIGNlbnRlcmVkIGRhdGEgdGhlIGludGVyY2VwdCBpbiBhIGxpbmVhciByZWdyZXNzaW9uIG1vZGVsIGlzIGFsd2F5cyBleGFjdGx5IGVxdWFsIHRvIHplcm8gYW5kIGhlbmNlIHRoZSBpbnRlcmNlcHQgbXVzdCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIG1vZGVsLgoKLSB3ZSBkbyBub3QgYXNzdW1lIHRoYXQgdGhlIHJlc2lkdWFscyBhcmUgbm9ybWFsbHkgZGlzdHJpYnV0ZWQuIEZvciBwcmVkaWN0aW9uIHB1cnBvc2VzIHRoaXMgaXMgb2Z0ZW4gbm90IHJlcXVpcmVkIChub3JtYWxpdHkgaXMgcGFydGljdWxhcmx5IGltcG9ydGFudCBmb3Igc3RhdGlzdGljYWwgaW5mZXJlbmNlIGluIHNtYWxsIHNhbXBsZXMpLgoKIyMgTGluZWFyIFJlZ3Jlc3Npb24gZm9yIG11bHRpdmFyaWF0ZSBkYXRhIHZzIEhpZ2ggRGltZW5zaW9uYWwgRGF0YQoKLSAkXG1hdGhiZntYXlRYfSQgYW5kICQoXG1hdGhiZntYXlRYfSleey0xfSQgYXJlICRwIFx0aW1lcyBwJCBtYXRyaWNlcwoKLSAkXG1hdGhiZntYXlRYfSQgY2FuIG9ubHkgYmUgaW52ZXJ0ZWQgaWYgaXQgaGFzIHJhbmsgJHAkCgotIFJhbmsgb2YgYSBtYXRyaXggb2YgZm9ybSAkXG1hdGhiZntYXlRYfSQsIHdpdGggJFxtYXRoYmZ7WH0kIGFuZCAkblx0aW1lcyBwJCBtYXRyaXgsIGNhbiBuZXZlciBiZSBsYXJnZXIgdGhhbiAkXG1pbihuLHApJC4KCi0gaW4gbW9zdCByZWdyZXNzaW9uIHByb2JsZW1zICRuPnAkIGFuZCByYW5rIG9mICQoXG1hdGhiZntYXlRYfSkkIGVxdWFscyAkcCQKCi0gaW4gaGlnaCBkaW1lbnNpb25hbCByZWdyZXNzaW9uIHByb2JsZW1zICRwID4+PiBuJCBhbmQgcmFuayBvZiAkKFxtYXRoYmZ7WF5UWH0pJCBlcXVhbHMgJG48cCQKCi0gaW4gdGhlIHRveGljb2dlbm9taWNzIGV4YW1wbGUgJG49MzA8cD00MDAwJCBhbmQgJFx0ZXh0e3Jhbmt9KFxtYXRoYmZ7WF5UWH0pXGxlcSBuPTMwJC4KICAkXGxvbmdyaWdodGFycm93JCAkKFxtYXRoYmZ7WF5UWH0pXnstMX0kIGRvZXMgbm90IGV4aXN0LCBhbmQgbmVpdGhlciBkb2VzICRcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0kLgoKIyMgQ2FuIFNWRCBoZWxwPwogIC0gU2luY2UgdGhlIGNvbHVtbnMgb2YgJFxtYXRoYmZ7WH0kIGFyZSBjZW50ZXJlZCwgJFxtYXRoYmZ7WF5UWH0gXHByb3B0byBcdGV4dHt2YXJ9XGxlZnRbXG1hdGhiZntYfVxyaWdodF0kLgoKICAtIGlmICRcdGV4dHtyYW5rfShcbWF0aGJme1heVFh9KT1uPTMwJCwgdGhlIFBDQSB3aWxsIGdpdmUgMzAgY29tcG9uZW50cywgZWFjaCBiZWluZyBhIGxpbmVhciBjb21iaW5hdGlvbiBvZiAkcD00MDAwJCB2YXJpYWJsZXMuIFRoZXNlIDMwIFBDcyBjb250YWluIGFsbCBpbmZvcm1hdGlvbiBwcmVzZW50IGluIHRoZSBvcmlnaW5hbCAkXG1hdGhiZntYfSQgZGF0YS4KCiAgLSBpZiAkXHRleHR7cmFua30oXG1hdGhiZntYfSk9bj0zMCQsIHRoZSBTVkQgb2YgJFxtYXRoYmZ7WH0kIGlzIGdpdmVuIGJ5CiAgXFsKICAgXG1hdGhiZntYfSA9IFxzdW1fe2k9MX1ebiBcZGVsdGFfaSBcbWF0aGJme3V9X2kgXG1hdGhiZnt2fV9pXlQgPSBcbWF0aGJme1V9IFxib2xkc3ltYm9se1xEZWx0YX0gXG1hdGhiZntWfV5UID0gXG1hdGhiZntaVn1eVCwKICBcXQogIHdpdGggJFxtYXRoYmZ7Wn0kIHRoZSAkblx0aW1lcyBuJCBtYXRyaXggd2l0aCB0aGUgc2NvcmVzIG9uIHRoZSAkbiQgUENzLgoKICAtIFN0aWxsIHByb2JsZW1hdGljIGJlY2F1c2UgaWYgd2UgdXNlIGFsbCBQQ3MgJG49cCQuCgoKIyBQcmluY2lwYWwgQ29tcG9uZW50IFJlZ3Jlc3Npb24KCkEgcHJpbmNpcGFsIGNvbXBvbmVudCByZWdyZXNzaW9uIChQQ1IpIGNvbnNpc3RzIG9mCgoxLiB0cmFuc2Zvcm1pbmcgJHA9NDAwMCQgZGltZW5zaW9uYWwgJFgkLXZhcmlhYmxlIHRvIHRoZSAkbj0zMCQgZGltZW5zaW9uYWwgJFokLXZhcmlhYmxlIChQQyBzY29yZXMpLiBUaGUgJG4kIFBDcyBhcmUgbXV0dWFsbHkgdW5jb3JyZWxhdGVkLgoKMi4gdXNpbmcgdGhlICRuJCBQQy12YXJpYWJsZXMgYXMgcmVncmVzc29ycyBpbiBhIGxpbmVhciByZWdyZXNzaW9uIG1vZGVsCgozLiBwZXJmb3JtaW5nIGZlYXR1cmUgc2VsZWN0aW9uIHRvIHNlbGVjdCB0aGUgbW9zdCBpbXBvcnRhbnQgcmVncmVzc29ycyAoUEMpLgoKRmVhdHVyZSBzZWxlY3Rpb24gaXMga2V5LCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gaGF2ZSBhcyBtYW55IHJlZ3Jlc3NvcnMgYXMgdGhlcmUgYXJlIG9ic2VydmF0aW9ucyBpbiB0aGUgZGF0YS4gVGhpcyB3b3VsZCByZXN1bHQgaW4gemVybyByZXNpZHVhbCBkZWdyZWVzIG9mIGZyZWVkb20uIChzZWUgbGF0ZXIpCgotLS0KClRvIGtlZXAgdGhlIGV4cG9zaXRpb24gZ2VuZXJhbCBzbyB0aGF0IHdlIGFsbG93IGZvciBhIGZlYXR1cmUgc2VsZWN0aW9uIHRvIGhhdmUgdGFrZW4gcGxhY2UsIEkgdXNlIHRoZSBub3RhdGlvbiAkXG1hdGhiZntVfV9TJCB0byBkZW5vdGUgYSBtYXRyaXggd2l0aCBsZWZ0LXNpbmd1bGFyIGNvbHVtbiB2ZWN0b3JzICRcbWF0aGJme3V9X2kkLCB3aXRoICRpIFxpbiB7XGNhbHtTfX0kICgke1xjYWx7U319JCBhbiBpbmRleCBzZXQgcmVmZXJyaW5nIHRvIHRoZSBQQ3MgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3Jlc3Npb24gbW9kZWwpLgoKRm9yIGV4YW1wbGUsIHN1cHBvc2UgdGhhdCBhIGZlYXR1cmUgc2VsZWN0aW9uIG1ldGhvZCBoYXMgcmVzdWx0ZWQgaW4gdGhlIHNlbGVjdGlvbiBvZiBQQ3MgMSwgMyBhbmQgMTIgZm9yIGluY2x1c2lvbiBpbiB0aGUgcHJlZGljdGlvbiBtb2RlbCwgdGhlbiAke1xjYWx7U319PVx7MSwzLDEyXH0kIGFuZApcWwogXG1hdGhiZntVfV9TID0gXGJlZ2lue3BtYXRyaXh9CiAgXG1hdGhiZnt1fV8xICYgXG1hdGhiZnt1fV8zICYgXG1hdGhiZnt1fV97MTJ9CiBcZW5ke3BtYXRyaXh9LgpcXQoKLS0tCgojIyMgRXhhbXBsZSBtb2RlbCBiYXNlZCBvbiBmaXJzdCA0IFBDcwoKYGBge3J9CmsgPC0gMzAKVWsgPC0gc3ZkWCR1WywxOmtdCkRrIDwtIGRpYWcoc3ZkWCRkWzE6a10pClprIDwtIFVrJSolRGsKWSA8LSB0b3hEYXRhICU+JQogIHB1bGwoQkEpCgptNCA8LSBsbShZflprWywxOjRdKQpzdW1tYXJ5KG00KQpgYGAKCk5vdGU6CgotIHRoZSBpbnRlcmNlcHQgaXMgZXN0aW1hdGVkIGFzIHplcm8uIChXaHk/KSBUaGUgbW9kZWwgY291bGQgaGF2ZSBiZWVuIGZpdHRlZCBhcwoKYGBgCm00IDwtIGxtKFl+LTErWmtbLDE6NF0pCmBgYAoKLSB0aGUgUEMtcHJlZGljdG9ycyBhcmUgdW5jb3JyZWxhdGVkIChieSBjb25zdHJ1Y3Rpb24pCgotIGZpcnN0IFBDLXByZWRpY3RvcnMgYXJlIG5vdCBuZWNlc3NhcmlseSB0aGUgbW9zdCBpbXBvcnRhbnQgcHJlZGljdG9ycwoKLSAkcCQtdmFsdWVzIGFyZSBub3QgdmVyeSBtZWFuaW5nZnVsIHdoZW4gcHJlZGljdGlvbiBpcyB0aGUgb2JqZWN0aXZlCgpNZXRob2RzIGZvciBmZWF0dXJlIHNlbGVjdGlvbiB3aWxsIGJlIGRpc2N1c3NlZCBsYXRlci4KCiMgUmlkZ2UgUmVncmVzc2lvbgoKIyMgUGVuYWx0eQoKIFRoZSByaWRnZSBwYXJhbWV0ZXIgZXN0aW1hdG9yIGlzIGRlZmluZWQgYXMgdGhlIHBhcmFtZXRlciAkXG1hdGhiZlxiZXRhJCB0aGF0IG1pbmltaXNlcyB0aGUgKipwZW5hbGlzZWQgbGVhc3Qgc3F1YXJlcyBjcml0ZXJpb24qKgoKIFxbCiBcdGV4dHtTU0V9X1x0ZXh0e3Blbn09XFZlcnRcbWF0aGJme1l9IC0gXG1hdGhiZntYXGJldGF9XFZlcnRfMl4yICsgXGxhbWJkYSBcVmVydCBcYm9sZHN5bWJvbHtcYmV0YX0gXFZlcnRfMl4yClxdCgotICRcVmVydCBcYm9sZHN5bWJvbHtcYmV0YX0gXFZlcnRfMl4yPVxzdW1fe2o9MX1ecCBcYmV0YV9qXjIkIGlzIHRoZSAqKiRMXzIkIHBlbmFsdHkgdGVybSoqCgotICRcbGFtYmRhPjAkIGlzIHRoZSBwZW5hbHR5IHBhcmFtZXRlciAodG8gYmUgY2hvc2VuIGJ5IHRoZSB1c2VyKS4KCk5vdGUsIHRoYXQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIG1pbmltaXppbmcKXFsKXFZlcnRcbWF0aGJme1l9IC0gXG1hdGhiZntYXGJldGF9XFZlcnRfMl4yIFx0ZXh0eyBzdWJqZWN0IHRvIH0gXFZlcnQgXGJvbGRzeW1ib2x7XGJldGF9XFZlcnReMl8yXGxlcSBzClxdCgpOb3RlLCB0aGF0ICRzJCBoYXMgYSBvbmUtdG8tb25lIGNvcnJlc3BvbmRlbmNlIHdpdGggJFxsYW1iZGEkCgojIyBHcmFwaGljYWwgaW50ZXJwcmV0YXRpb24KCmBgYHtyIGVjaG8gPSBGQUxTRSwgd2FybmluZyA9IEZBTFNFLCBtZXNzYWdlID0gRkFMU0V9CmxpYnJhcnkoZ2dmb3JjZSkKbGlicmFyeShsYXRleDJleHApCmxpYnJhcnkoZ3JpZEV4dHJhKQoKcDEgPC0gZ2dwbG90KCkgKwogIGdlb21fZWxsaXBzZShhZXMoeDAgPSA0LCB5MCA9IDExLCBhID0gMTAsIGIgPSAzLCBhbmdsZSA9IHBpIC8gNCkpICsKICBnZW9tX2VsbGlwc2UoYWVzKHgwID0gNCwgeTAgPSAxMSwgYSA9IDUsIGIgPSAxLjUsIGFuZ2xlID0gcGkgLyA0KSkgKwogIHhsaW0oLTEyLjUsIDEyLjUpICsKICB5bGltKC01LCAyMCkgKwogIGdlb21fcG9pbnQoYWVzKHggPSA0LCB5ID0gMTEpKSArCiAgYW5ub3RhdGUoInRleHQiLCBsYWJlbCA9IFRlWCgiJChcXGhhdHtcXGJldGF9XzFee29sc30sIFxcaGF0e1xcYmV0YX1fMl57b2xzfSkkIiksIHggPSAtNSwgeSA9IDE1LCBzaXplID0gNiwgcGFyc2UgPSBUUlVFKSArCiAgeGxhYihUZVgoIiRcXGJldGFfMSQiKSkgKwogIHlsYWIoVGVYKCIkXFxiZXRhXzIkIikpICsKICBnZW9tX3NlZ21lbnQoCiAgICBhZXMoeCA9IC01LCB5ID0gMTIuNSwgeGVuZCA9IDMuNywgeWVuZCA9IDExLjMpLAogICAgYXJyb3cgPSBhcnJvdyhsZW5ndGggPSB1bml0KDAuMjUsICJjbSIpKQogICAgKSArICAgCiAgY29vcmRfZml4ZWQoKQoKcFJpZGdlIDwtIHAxICsKICBnZW9tX2NpcmNsZShhZXMoeDAgPSAwLCB5MCA9IDAsIHIgPSAzLjkpICwgY29sb3IgPSAicmVkIikgKwogIGdlb21fcG9pbnQoYWVzKHggPSAtMS4xLCB5ID0gMy43NSksIGNvbG9yID0gInJlZCIpICsKICBhbm5vdGF0ZSgidGV4dCIsIGxhYmVsID0gVGVYKCIkKFxcaGF0e1xcYmV0YX1fMV57cmlkZ2V9LCBcXGhhdHtcXGJldGF9XzJee3JpZGdlfSkkIiksIHggPSAtOC4xLCB5ID0gNC40NSwgc2l6ZSA9IDYsIHBhcnNlID0gVFJVRSwgY29sb3IgPSAicmVkIikgKwogIGdndGl0bGUoIlJpZGdlIikgKwogIGdlb21fdmxpbmUoeGludGVyY2VwdCA9IDAsIGNvbG9yID0gImdyZXkiKSArCiAgZ2VvbV9obGluZSh5aW50ZXJjZXB0ID0gMCwgY29sb3IgPSAiZ3JleSIpICsKICB0aGVtZV9taW5pbWFsKCkKCnBSaWRnZQpgYGAKCiMjIFNvbHV0aW9uCgpUaGUgc29sdXRpb24gaXMgZ2l2ZW4gYnkKXFsKICBcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0gPSAoXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0pXnstMX0gXG1hdGhiZntYXlQgWX0uClxdCkl0IGNhbiBiZSBzaG93biB0aGF0ICQoXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0pJCBpcyBhbHdheXMgb2YgcmFuayAkcCQgaWYgJFxsYW1iZGE+MCQuCgpIZW5jZSwgJChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSkkIGlzIGludmVydGlibGUgYW5kICRcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0kIGV4aXN0cyBldmVuIGlmICRwPj4+biQuCgpXZSBhbHNvIGZpbmQKXFsKICBcdGV4dHt2YXJ9XGxlZnRbXGhhdHtcbWF0aGJmXGJldGF9XHJpZ2h0XSA9IChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSleey0xfSBcbWF0aGJme1h9XlRcbWF0aGJme1h9IChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSleey0xfVxzaWdtYV4yClxdCgpIb3dldmVyLCBpdCBjYW4gYmUgc2hvd24gdGhhdCBpbXByb3ZlZCBpbnRlcnZhbHMgdGhhdCBhbHNvIGFjY291bnQgZm9yIHRoZSBiaWFzIGNhbiBiZSBjb25zdHJ1Y3RlZCBieSB1c2luZzoKClxbCiAgXHRleHR7dmFyfVxsZWZ0W1xoYXR7XG1hdGhiZlxiZXRhfVxyaWdodF0gPSAoXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0pXnstMX0gIFxzaWdtYV4yLgpcXQoKIyMjIFByb29mCgpUaGUgY3JpdGVyaW9uIHRvIGJlIG1pbmltaXNlZCBpcwogIFxbCiAgIFx0ZXh0e1NTRX1fXHRleHR7cGVufT1cVmVydFxtYXRoYmZ7WX0gLSBcbWF0aGJme1hcYmV0YX1cVmVydF8yXjIgKyBcbGFtYmRhIFxWZXJ0IFxib2xkc3ltYm9se1xiZXRhfSBcVmVydF8yXjIuCiBcXQogRmlyc3Qgd2UgcmUtZXhwcmVzcyBTU0UgaW4gbWF0cml4IG5vdGF0aW9uOgogXFsKICAgXHRleHR7U1NFfV9cdGV4dHtwZW59ID0gKFxtYXRoYmZ7WX0tXG1hdGhiZntYXGJldGF9KV5UKFxtYXRoYmZ7WX0tXG1hdGhiZntYXGJldGF9KSArIFxsYW1iZGEgXGJvbGRzeW1ib2x7XGJldGF9XlRcYm9sZHN5bWJvbHtcYmV0YX0uCiBcXQogVGhlIHBhcnRpYWwgZGVyaXZhdGl2ZSB3LnIudC4gJFxib2xkc3ltYm9se1xiZXRhfSQgaXMKIFxbCiAgIFxmcmFje1xwYXJ0aWFsfXtccGFydGlhbCBcYm9sZHN5bWJvbHtcYmV0YX19XHRleHR7U1NFfV9cdGV4dHtwZW59ID0gLTJcbWF0aGJme1h9XlQoXG1hdGhiZntZfS1cbWF0aGJme1hcYmV0YX0pKzJcbGFtYmRhXGJvbGRzeW1ib2x7XGJldGF9LgogXF0KIFNvbHZpbmcgJFxmcmFje1xwYXJ0aWFsfXtccGFydGlhbCBcYm9sZHN5bWJvbHtcYmV0YX19XHRleHR7U1NFfV9cdGV4dHtwZW59PTAkIGdpdmVzCiBcWwogICBcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0gPSAoXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0pXnstMX0gXG1hdGhiZntYXlQgWX0uCiBcXQogKGFzc3VtcHRpb246ICQoXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0pJCBpcyBvZiByYW5rICRwJC4gVGhpcyBpcyBhbHdheXMgdHJ1ZSBpZiAkXGxhbWJkYT4wJCkKCiMjIExpbmsgd2l0aCBTVkQKCiMjIyBTVkQgYW5kIGludmVyc2UKV3JpdGUgdGhlIFNWRCBvZiAkXG1hdGhiZntYfSQgKCRwPm4kKSBhcwpcWwogICBcbWF0aGJme1h9ID0gXHN1bV97aT0xfV5uIFxkZWx0YV9pIFxtYXRoYmZ7dX1faSBcbWF0aGJme3Z9X2leVCA9IFxzdW1fe2k9MX1ecCBcZGVsdGFfaSBcbWF0aGJme3V9X2kgXG1hdGhiZnt2fV9pXlQgID0gXG1hdGhiZntVfVxib2xkc3ltYm9se1xEZWx0YX0gXG1hdGhiZntWfV5UICwKXF0Kd2l0aAoKLSAkXGRlbHRhX3tuKzF9PVxkZWx0YV97bisyfT0gXGNkb3RzID0gXGRlbHRhX3A9MCQKCi0gJFxib2xkc3ltYm9se1xEZWx0YX0kIGEgJHBcdGltZXMgcCQgZGlhZ29uYWwgbWF0cml4IG9mIHRoZSAkXGRlbHRhXzEsXGxkb3RzLCBcZGVsdGFfcCQKCi0gICRcbWF0aGJme1V9JCBhbiAkblx0aW1lcyBwJCBtYXRyaXggYW5kICRcbWF0aGJme1Z9JCBhICRwIFx0aW1lcyBwJCBtYXRyaXguIE5vdGUgdGhhdCBvbmx5IHRoZSBmaXJzdCAkbiQgY29sdW1ucyBvZiAkXG1hdGhiZntVfSQgYW5kICRcbWF0aGJme1Z9JCBhcmUgaW5mb3JtYXRpdmUuCgpXaXRoIHRoZSBTVkQgb2YgJFxtYXRoYmZ7WH0kIHdlIHdyaXRlCiBcWwogICBcbWF0aGJme1h9XlRcbWF0aGJme1h9ID0gXG1hdGhiZntWfVxib2xkc3ltYm9se1xEZWx0YQogICAgIH1eMlxtYXRoYmZ7Vn1eVC4KIFxdCiBUaGUgaW52ZXJzZSBvZiAkXG1hdGhiZntYfV5UXG1hdGhiZntYfSQgaXMgdGhlbiBnaXZlbiBieQogXFsKICAgKFxtYXRoYmZ7WH1eVFxtYXRoYmZ7WH0pXnstMX0gPSBcbWF0aGJme1Z9XGJvbGRzeW1ib2x7XERlbHRhfV57LTJ9XG1hdGhiZntWfV5ULgogXF0KIFNpbmNlICRcYm9sZHN5bWJvbHtcRGVsdGF9JCBoYXMgJFxkZWx0YV97bisxfT1cZGVsdGFfe24rMn09IFxjZG90cyA9IFxkZWx0YV9wPTAkLCBpdCBpcyBub3QgaW52ZXJ0aWJsZS4KCiMjIyBTVkQgb2YgcGVuYWxpc2VkIG1hdHJpeCAkXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0kCgpJdCBjYW4gYmUgc2hvd24gdGhhdApcWwogIFxtYXRoYmZ7WF5UWH0rXGxhbWJkYSBcbWF0aGJme0l9ID0gXG1hdGhiZntWfSAoXGJvbGRzeW1ib2x7XERlbHRhfV4yK1xsYW1iZGEgXG1hdGhiZntJfSkgXG1hdGhiZntWfV5UICwKXF0KaS5lLiBhZGRpbmcgYSBjb25zdGFudCB0byB0aGUgZGlhZ29uYWwgZWxlbWVudHMgZG9lcyBub3QgYWZmZWN0IHRoZSBlaWdlbnZlY3RvcnMsIGFuZCBhbGwgZWlnZW52YWx1ZXMgYXJlIGluY3JlYXNlZCBieSB0aGlzIGNvbnN0YW50LgokXGxvbmdyaWdodGFycm93JCB6ZXJvIGVpZ2VudmFsdWVzIGJlY29tZSAkXGxhbWJkYSQuCgpIZW5jZSwKXFsKICAoXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0pXnstMX0gPSBcbWF0aGJme1Z9IChcYm9sZHN5bWJvbHtcRGVsdGF9XjIrXGxhbWJkYSBcbWF0aGJme0l9KV57LTF9IFxtYXRoYmZ7Vn1eVCAsClxdCndoaWNoIGNhbiBiZSBjb21wdXRlZCBldmVuIHdoZW4gc29tZSBlaWdlbnZhbHVlcyBpbiAkXGJvbGRzeW1ib2x7XERlbHRhfV4yJCBhcmUgemVyby4KCk5vdGUsIHRoYXQgZm9yIGhpZ2ggZGltZW5zaW9uYWwgZGF0YSAoJHA+Pj5uJCkgbWFueSBlaWdlbnZhbHVlcyBhcmUgemVybyBiZWNhdXNlICRcbWF0aGJme1heVFh9JCBpcyBhICRwIFx0aW1lcyBwJCBtYXRyaXggYW5kIGhhcyByYW5rICRuJC4gIAoKVGhlIGlkZW50aXR5ICRcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSA9IFxtYXRoYmZ7Vn0gKFxib2xkc3ltYm9se1xEZWx0YX1eMitcbGFtYmRhIFxtYXRoYmZ7SX0pIFxtYXRoYmZ7Vn1eVCQgaXMgZWFzaWx5IGNoZWNrZWQ6ClxbCiAgXG1hdGhiZntWfSAoXGJvbGRzeW1ib2x7XERlbHRhfV4yK1xsYW1iZGEgXG1hdGhiZntJfSkgXG1hdGhiZntWfV5UID0gXG1hdGhiZntWfVxib2xkc3ltYm9se1xEZWx0YX1eMlxtYXRoYmZ7Vn1eVCArIFxsYW1iZGEgXG1hdGhiZntWVn1eVCAgPSBcbWF0aGJme1Z9XGJvbGRzeW1ib2x7XERlbHRhfV4yXG1hdGhiZntWfV5UICsgXGxhbWJkYSBcbWF0aGJme0l9ID0gXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0uClxdCgoKIyMgUHJvcGVydGllcwoKLSBUaGUgUmlkZ2UgZXN0aW1hdG9yIGlzIGJpYXNlZCEgVGhlICRcYm9sZHN5bWJvbHtcYmV0YX0kIGFyZSBzaHJ1bmtlbiB0byB6ZXJvIQpcYmVnaW57ZXFuYXJyYXl9CiBcdGV4dHtFfVtcaGF0e1xib2xkc3ltYm9se1xiZXRhfX1dICY9JiAoXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0pXnstMX0gXG1hdGhiZntYfV5UIFx0ZXh0e0V9W1xtYXRoYmZ7WX1dXFwKJj0mIChcbWF0aGJme1h9XlRcbWF0aGJme1h9K1xsYW1iZGEgXG1hdGhiZntJfSleey0xfSBcbWF0aGJme1h9XlQgXG1hdGhiZntYfVxib2xkc3ltYm9se1xiZXRhfVxcClxlbmR7ZXFuYXJyYXl9CgotIE5vdGUsIHRoYXQgdGhlIHNocmlua2FnZSBpcyBsYXJnZXIgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc21hbGxlciBlaWdlbnZhbHVlcy4KClxiZWdpbntlcW5hcnJheX0KXHRleHR7RX1bXGhhdHtcYm9sZHN5bWJvbHtcYmV0YX19XSY9JlxtYXRoYmZ7Vn0gKFxib2xkc3ltYm9se1xEZWx0YX1eMitcbGFtYmRhIFxtYXRoYmZ7SX0pXnstMX0gXG1hdGhiZntWfV5UIFxtYXRoYmZ7Vn0gXGJvbGRzeW1ib2x7XERlbHRhfV4yIFxtYXRoYmZ7Vn1eVFxib2xkc3ltYm9se1xiZXRhfVxcCiY9JlxtYXRoYmZ7Vn0gKFxib2xkc3ltYm9se1xEZWx0YX1eMitcbGFtYmRhIFxtYXRoYmZ7SX0pXnstMX0gXGJvbGRzeW1ib2x7XERlbHRhfV4yIFxtYXRoYmZ7Vn1eVFxib2xkc3ltYm9se1xiZXRhfVxcCiY9JiBcbWF0aGJme1Z9ClxsZWZ0W1xiZWdpbnthcnJheX17Y2NjfQpcZnJhY3tcZGVsdGFfMV4yfXtcZGVsdGFfMV4yK1xsYW1iZGF9JlxsZG90cyYwIFxcCiZcdmRvdHMmXFwKMCZcbGRvdHMmXGZyYWN7XGRlbHRhX3JeMn17XGRlbHRhX3JeMitcbGFtYmRhfQpcZW5ke2FycmF5fVxyaWdodF0KXG1hdGhiZntWfV5UXGJvbGRzeW1ib2x7XGJldGF9ClxlbmR7ZXFuYXJyYXl9CgotICB0aGUgdmFyaWFuY2Ugb2YgdGhlIHByZWRpY3Rpb24gJFxoYXR7e1l9fShcbWF0aGJme3h9KT1cbWF0aGJme3h9XlRcaGF0XGJldGEkLAogIFxbCiAgICBcdGV4dHt2YXJ9XGxlZnRbXGhhdHt7WX19KFxtYXRoYmZ7eH0pXG1pZCBcbWF0aGJme3h9XHJpZ2h0XSA9IFxtYXRoYmZ7eH1eVChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSleey0xfVxtYXRoYmZ7eH0KICBcXQogIGlzIHNtYWxsZXIgdGhhbiB3aXRoIHRoZSBsZWFzdC1zcXVhcmVzIGVzdGltYXRvci4KCi0gIHRocm91Z2ggdGhlIGJpYXMtdmFyaWFuY2UgdHJhZGUtb2ZmIGl0IGlzIGhvcGVkIHRoYXQgYmV0dGVyIHByZWRpY3Rpb25zIGluIHRlcm1zIG9mIGV4cGVjdGVkIGNvbmRpdGlvbmFsIHRlc3QgZXJyb3IgY2FuIGJlIG9idGFpbmVkLCBmb3IgYW4gYXBwcm9wcmlhdGUgY2hvaWNlIG9mICRcbGFtYmRhJC4KCgpSZWNhbGwgdGhlIGV4cHJlc3Npb24gb2YgdGhlIGV4cGVjdGVkIGNvbmRpdGlvbmFsIHRlc3QgZXJyb3IKXGJlZ2lue2VxbmFycmF5fQogIEVycihcbWF0aGJme3h9KSAmPSYgXHRleHR7RX1cbGVmdFsoXGhhdHtZfSAtIFleKileMlxtaWQgXG1hdGhiZnt4fVxyaWdodF1cXAogICY9JgogIFx0ZXh0e3Zhcn1cbGVmdFtcaGF0e1l9XG1pZCBcbWF0aGJme3h9XHJpZ2h0XSArIFx0ZXh0e2JpYXN9XjIoXG1hdGhiZnt4fSkrCiAgXHRleHR7dmFyfVxsZWZ0W1leKlxtaWQgXG1hdGhiZnt4fVxyaWdodF0KXGVuZHtlcW5hcnJheX0Kd2hlcmUKCi0gJFxoYXR7WX09XGhhdHtZfShcbWF0aGJme3h9KT1cbWF0aGJme3h9XlRcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0kIGlzIHRoZSBwcmVkaWN0aW9uIGF0ICRcbWF0aGJme3h9JAotICRZXiokIGlzIGFuIG91dGNvbWUgYXQgcHJlZGljdG9yICRcbWF0aGJme3h9JAotICRcbXUoXG1hdGhiZnt4fSkgPSBcdGV4dHtFfVxsZWZ0W1xoYXR7WX1cbWlkIFxtYXRoYmZ7eH1ccmlnaHRdIFx0ZXh0eyBhbmQgfSBcbXVeKih4KT1cdGV4dHtFfVxsZWZ0W1leKlxtaWQgXG1hdGhiZnt4fVxyaWdodF0kCi0gJFx0ZXh0e2JpYXN9KFxtYXRoYmZ7eH0pPVxtdShcbWF0aGJme3h9KS1cbXVeKihcbWF0aGJme3h9KSQKLSAkXHRleHR7dmFyfVxsZWZ0W1leKlxtaWQgXG1hdGhiZnt4fVxyaWdodF0kIHRoZSBpcnJlZHVjaWJsZSBlcnJvciB0aGF0IGRvZXMgbm90IGRlcGVuZCBvbiB0aGUgbW9kZWwuIEl0IHNpbXBseSBvcmlnaW5hdGVzIGZyb20gb2JzZXJ2YXRpb25zIHRoYXQgcmFuZG9tbHkgZmx1Y3R1YXRlIGFyb3VuZCB0aGUgdHJ1ZSBtZWFuICRcbXVeKih4KSQuCgojIyBUb3hpY29nZW5vbWljcyBleGFtcGxlCgpgYGB7cn0KbGlicmFyeShnbG1uZXQpCm1SaWRnZSA8LSBnbG1uZXQoCiAgeCA9IHRveERhdGFbLC0xXSAlPiUKICAgIGFzLm1hdHJpeCwKICB5ID0gdG94RGF0YSAlPiUKICAgIHB1bGwoQkEpLAogIGFscGhhID0gMCkgIyByaWRnZTogYWxwaGEgPSAwICAKCnBsb3QobVJpZGdlLCB4dmFyPSJsYW1iZGEiKQpgYGAKCgpUaGUgUiBmdW5jdGlvbiBcdGV4dHNme2dsbW5ldH0gdXNlcyBcdGV4dHNme2xhbWJkYX0gdG8gcmVmZXIgdG8gdGhlIHBlbmFsdHkgcGFyYW1ldGVyLiBJbiB0aGlzIGNvdXJzZSB3ZSB1c2UgJFxsYW1iZGEkLCBiZWNhdXNlICRcbGFtYmRhJCBpcyBvZnRlbiB1c2VkIGFzIGVpZ2VudmFsdWVzLgoKVGhlIGdyYXBoIHNob3dzIHRoYXQgd2l0aCBpbmNyZWFzaW5nIHBlbmFsdHkgcGFyYW1ldGVyLCB0aGUgcGFyYW1ldGVyIGVzdGltYXRlcyBhcmUgc2hydW5rZW4gdG93YXJkcyB6ZXJvLiBUaGUgZXN0aW1hdGVzIHdpbGwgb25seSByZWFjaCB6ZXJvIGZvciAkXGxhbWJkYSBccmlnaHRhcnJvdyBcaW5mdHkkLiBUaGUgc3Ryb25nZXIgdGhlIHNocmlua2FnZSwgdGhlIGxhcmdlciB0aGUgYmlhcyAodG93YXJkcyB6ZXJvKSBhbmQgdGhlIHNtYWxsZXIgdGhlIHZhcmlhbmNlIG9mIHRoZSBwYXJhbWV0ZXIgZXN0aW1hdG9ycyAoYW5kIGhlbmNlIGFsc28gc21hbGxlciB2YXJpYW5jZSBvZiB0aGUgcHJlZGljdGlvbnMpLgoKQW5vdGhlciAoaW5mb3JtYWwpIHZpZXdwb2ludCBpcyB0aGUgZm9sbG93aW5nLiBCeSBzaHJpbmtpbmcgdGhlIGVzdGltYXRlcyB0b3dhcmRzIHplcm8sIHRoZSBlc3RpbWF0ZXMgbG9vc2Ugc29tZSBvZiB0aGVpciBgYGRlZ3JlZXMgb2YgZnJlZWRvbScnIHNvIHRoYXQgdGhlIHBhcmFtZXRlcnMgYmVjb21lIGVzdGltYWJsZSB3aXRoIG9ubHkgJG48cCQgZGF0YSBwb2ludHMuIEV2ZW4gd2l0aCBhIHZlcnkgc21hbGwgJFxsYW1iZGE+MCQsIHRoZSBwYXJhbWV0ZXJzIHJlZ2FpbiB0aGVpciBlc3RpbWFiaWxpdHkuIEhvd2V2ZXIsIG5vdGUgdGhhdCB0aGUgdmFyaWFuY2Ugb2YgdGhlIGVzdGltYXRvciBpcyBnaXZlbiBieQpcWwogIFx0ZXh0e3Zhcn1cbGVmdFtcaGF0e1xtYXRoYmZcYmV0YX1ccmlnaHRdID0gKFxtYXRoYmZ7WF5UWH0rXGxhbWJkYSBcbWF0aGJme0l9KV57LTF9IFxzaWdtYV4yID0gXG1hdGhiZntWfShcYm9sZHN5bWJvbHtcRGVsdGF9XjIrXGxhbWJkYVxtYXRoYmZ7SX0pXnstMX1cbWF0aGJme1Z9XlRcc2lnbWFeMi4KXF0KSGVuY2UsIGEgc21hbGwgJFxsYW1iZGEkIHdpbGwgcmVzdWx0IGluIGxhcmdlIHZhcmlhbmNlcyBvZiB0aGUgcGFyYW1ldGVyIGVzdGltYXRvcnMuIFRoZSBsYXJnZXIgJFxsYW1iZGEkLCB0aGUgc21hbGxlciB0aGUgdmFyaWFuY2VzIGJlY29tZS4gSW4gdGhlIGxpbWl0LCBhcyAkXGxhbWJkYVxyaWdodGFycm93XGluZnR5JCwgdGhlIGVzdGltYXRlcyBhcmUgY29udmVyZ2VkIHRvIHplcm8gYW5kIHNob3cgbm8gdmFyaWFiaWxpdHkgYW55IGxvbmdlci4KCiMgTGFzc28gUmVncmVzc2lvbgoKLSBUaGUgTGFzc28gaXMgYW5vdGhlciBleGFtcGxlIG9mIHBlbmFsaXNlZCByZWdyZXNzaW9uLgoKLSBUaGUgbGFzc28gZXN0aW1hdG9yIG9mICRcYm9sZHN5bWJvbHtcYmV0YX0kIGlzIHRoZSBzb2x1dGlvbiB0byBtaW5pbWlzaW5nIHRoZSBwZW5hbGlzZWQgU1NFClxbCiBcdGV4dHtTU0V9X1x0ZXh0e3Blbn0gPSBcc3VtX3tpPTF9Xm4gKFlfaSAtIFxtYXRoYmZ7eH1faV5UXGJvbGRzeW1ib2x7XGJldGF9KV4yICsgXGxhbWJkYSBcc3VtX3tqPTF9XnAgXHZlcnQgXGJldGFfalx2ZXJ0LgpcXQoKCm9yLCBlcXVpdmFsZW50bHksIG1pbmltaXNpbmcKClxbClx0ZXh0e1NTRX0gID0gXFZlcnQgXG1hdGhiZntZfSAtIFxtYXRoYmZ7WFxiZXRhfVxWZXJ0XzJeMiBcdGV4dHsgc3ViamVjdCB0byB9IFxWZXJ0IFxtYXRoYmZcYmV0YVxWZXJ0XzEgXGxlcSBjClxdCndpdGgKCi0gJFxWZXJ0IFxtYXRoYmZcYmV0YVxWZXJ0XzEgPSBcc3VtXGxpbWl0c197aj0xfV5wIFx2ZXJ0IFxiZXRhX2ogXHZlcnQkCgotIERlc3BpdGUgc3Ryb25nIHNpbWlsYXJpdHkgYmV0d2VlbiByaWRnZSBhbmQgbGFzc28gcmVncmVzc2lvbiAoJExfMiQgdmVyc3VzICRMXzEkIG5vcm0gaW4gcGVuYWx0eSB0ZXJtKSwgdGhlcmUgaXMgbm8gYW5hbHl0aWNhbCBzb2x1dGlvbiBvZiB0aGUgbGFzc28gcGFyYW1ldGVyIGVzdGltYXRlIG9mICRcbWF0aGJmXGJldGEkLgoKLSBGb3J0dW5hdGVseSwgY29tcHV0YXRpb25hbCBlZmZpY2llbnQgYWxnb3JpdGhtcyBoYXZlIGJlZW4gaW1wbGVtZW50ZWQgaW4gc3RhdGlzdGljYWwgc29mdHdhcmUKCi0gVGhlIExhc3NvIGVzdGltYXRvciBvZiAkXGJvbGRzeW1ib2x7XGJldGF9JCBpcyBiaWFzZWQgYW5kIGdlbmVyYWxseSBoYXMgYSBzbWFsbGVyIHZhcmlhbmNlIHRoZW4gdGhlIGxlYXN0LXNxdWFyZXMgZXN0aW1hdG9yLgoKLSBIZW5jZSwgdGhlIGJpYXMtdmFyaWFuY2UgdHJhZGUtb2ZmIG1heSBoZXJlIGFsc28gaGVscCBpbiBmaW5kaW5nIGJldHRlciBwcmVkaWN0aW9ucyB3aXRoIGJpYXNlZCBlc3RpbWF0b3JzLgoKLSBJbiBjb250cmFzdCB0byByaWRnZSByZWdyZXNzaW9uLCBob3dldmVyLCB0aGUgbGFzc28gZXN0aW1hdG9yIGNhbiBnaXZlIGF0IG1vc3QgJFxtaW4ocCxuKSQgbm9uLXplcm8gJFxiZXRhJC1lc3RpbWF0ZXMuCgotIEhlbmNlLCBhdCBmaXJzdCBzaWdodCB0aGUgbGFzc28gaXMgbm90IGRpcmVjdGx5IGFwcHJvcHJpYXRlIGZvciBoaWdoLWRpbWVuc2lvbmFsIHNldHRpbmdzLgoKLSBBbiBpbXBvcnRhbnQgYWR2YW50YWdlIG9mIHRoZSBsYXNzbyBpcyB0aGF0IGNob29zaW5nIGFuIGFwcHJvcHJpYXRlIHZhbHVlIGZvciAkXGxhbWJkYSQgaXMgYSBraW5kIGEgbW9kZWwgYnVpbGRpbmcgb3IgZmVhdHVyZSBzZWxlY3Rpb24gcHJvY2VkdXJlIChzZWUgZnVydGhlcikuCgojIyBHcmFwaGljYWwgaW50ZXJwcmV0YXRpb24gb2YgTGFzc28gdnMgcmlkZ2UKCk5vdGUgdGhhdCB0aGUgbGFzc28gaXMgYSBjb25zdHJhaW5lZCByZWdyZXNzaW9uIHByb2JsZW0gd2l0aAoKXFsKXFZlcnQgXG1hdGhiZntZfSAtIFxtYXRoYmZ7WFxiZXRhfVxWZXJ0XzJeMiBcdGV4dHsgc3ViamVjdCB0byB9IFxWZXJ0IFxtYXRoYmZcYmV0YVxWZXJ0XzEgXGxlcSBjClxdCmFuZCByaWRnZQpcWwpcVmVydCBcbWF0aGJme1l9IC0gXG1hdGhiZntYXGJldGF9XFZlcnRfMl4yIFx0ZXh0eyBzdWJqZWN0IHRvIH0gXFZlcnQgXG1hdGhiZlxiZXRhXFZlcnReMl8yIFxsZXEgYwpcXQoKYGBge3IgZWNobyA9IEZBTFNFLCB3YXJuaW5nID0gRkFMU0UsIG1lc3NhZ2UgPSBGQUxTRX0KcExhc3NvIDwtIHAxICsKICBnZW9tX3NlZ21lbnQoYWVzKHggPSAwLCB5ID0gNC4yICwgeGVuZCA9IDQuMiwgeWVuZCA9IDApLCBjb2xvciA9ICJyZWQiKSArCiAgZ2VvbV9zZWdtZW50KGFlcyh4ID0gMCwgeSA9IDQuMiAsIHhlbmQgPSAtIDQuMiwgeWVuZCA9IDApLCBjb2xvciA9ICJyZWQiKSArCiAgZ2VvbV9zZWdtZW50KGFlcyh4ID0gNC4yLCB5ID0gMCAsIHhlbmQgPSAwLCB5ZW5kID0gLTQuMiksIGNvbG9yID0gInJlZCIpICsKICBnZW9tX3NlZ21lbnQoYWVzKHggPSAwLCB5ID0gLSA0LjIgLCB4ZW5kID0gLSA0LjIsIHllbmQgPSAwKSwgY29sb3IgPSAicmVkIikgKwogIGdlb21fcG9pbnQoYWVzKHggPSAwLCB5ID0gNC4yKSwgY29sb3IgPSAicmVkIikgKwogIGFubm90YXRlKCJ0ZXh0IiwgbGFiZWwgPSBUZVgoIiQoXFxoYXR7XFxiZXRhfV8xXntsYXNzb30sIFxcaGF0e1xcYmV0YX1fMl57bGFzc299KSQiKSwgeCA9IDcsIHkgPSA0LjIsIHNpemUgPSA2LCBwYXJzZSA9IFRSVUUsIGNvbG9yID0gInJlZCIpICsKICBnZ3RpdGxlKCJMYXNzbyIpICsKICBnZW9tX3ZsaW5lKHhpbnRlcmNlcHQgPSAwLCBjb2xvciA9ICJncmV5IikgKwogIGdlb21faGxpbmUoeWludGVyY2VwdCA9IDAsIGNvbG9yID0gImdyZXkiKSArCiAgdGhlbWVfbWluaW1hbCgpCgpncmlkLmFycmFuZ2UocExhc3NvLCBwUmlkZ2UsIG5jb2wgPSAyKQpgYGAKCk5vdGUsIHRoYXQKCi0gcGFyYW1ldGVycyBmb3IgdGhlIGxhc3NvIGNhbiBuZXZlciBzd2l0Y2ggc2lnbiwgdGhleSBhcmUgc2V0IGF0IHplcm8hIFNlbGVjdGlvbiEKLSByaWRnZSByZWdyZXNzaW9uIGNhbiBsZWFkIHRvIHBhcmFtZXRlcnMgdGhhdCBzd2l0Y2ggc2lnbi4KCiMjIFRveGljb2dlbm9taWNzIGV4YW1wbGUKCmBgYHtyfQptTGFzc28gPC0gZ2xtbmV0KAogIHggPSB0b3hEYXRhWywtMV0gJT4lCiAgICBhcy5tYXRyaXgsCiAgeSA9IHRveERhdGEgJT4lCiAgICBwdWxsKEJBKSwKYWxwaGEgPSAxKQpwbG90KG1MYXNzbywgeHZhciA9ICJsYW1iZGEiKQpgYGAKCi0gVGhlIGdyYXBoIHdpdGggdGhlIHBhdGhzIG9mIHRoZSBwYXJhbWV0ZXIgZXN0aW1hdGVzIG5pY2VseSBpbGx1c3RyYXRlcyB0aGUgdHlwaWNhbCBiZWhhdmlvdXIgb2YgdGhlIGxhc3NvIGVzdGltYXRlcyBhcyBhIGZ1bmN0aW9uIG9mICRcbGFtYmRhJDogd2hlbiAkXGxhbWJkYSQgaW5jcmVhc2VzIHRoZSBlc3RpbWF0ZXMgYXJlIHNocnVua2VuIHRvd2FyZHMgemVyby4KCi0gV2hlbiBhbiBlc3RpbWF0ZSBoaXRzIHplcm8sIGl0IHJlbWFpbnMgZXhhY3RseSBlcXVhbCB0byB6ZXJvIHdoZW4gJFxnYW1tYSQgZnVydGhlciBpbmNyZWFzZXMuIEEgcGFyYW1ldGVyIGVzdGltYXRlIGVxdWFsIHRvIHplcm8sIHNheSAkXGhhdFxiZXRhX2o9MCQsIGltcGxpZXMgdGhhdCB0aGUgY29ycmVzcG9uZGluZyBwcmVkaWN0b3IgJHhfaiQgaXMgbm8gbG9uZ2VyIGluY2x1ZGVkIGluIHRoZSBtb2RlbCAoaS5lLiAkXGJldGFfanhfaj0wJCkuCgotIFRoZSBtb2RlbCBmaXQgaXMga25vd24gYXMgYSBzcGFyc2UgbW9kZWwgZml0IChtYW55IHplcm9lcykuIEhlbmNlLCBjaG9vc2luZyBhIGFwcHJvcHJpYXRlIHZhbHVlIGZvciAkXGdhbW1hJCBpcyBsaWtlIGNob29zaW5nIHRoZSBpbXBvcnRhbnQgcHJlZGljdG9ycyBpbiB0aGUgbW9kZWwgKGZlYXR1cmUgc2VsZWN0aW9uKS4KCgojIFNwbGluZXMgYW5kIHRoZSBjb25uZWN0aW9uIHRvIHJpZGdlIHJlZ3Jlc3Npb24uCgojIyBMaWRhciBkYXRhc2V0CgotIExJREFSIChsaWdodCBkZXRlY3Rpb24gYW5kIHJhbmdpbmcpIHVzZXMgdGhlIHJlZmxlY3Rpb24gb2YgbGFzZXItZW1pdHRlZCBsaWdodCB0byBkZXRlY3QgY2hlbWljYWwgY29tcG91bmRzIGluIHRoZSBhdG1vc3BoZXJlLgotIFRoZSBMSURBUiB0ZWNobmlxdWUgaGFzIHByb3ZlbiB0byBiZSBhbiBlZmZpY2llbnQgdG9vbCBmb3IgbW9uaXRvcmluZyB0aGUgZGlzdHJpYnV0aW9uIG9mIHNldmVyYWwgYXRtb3NwaGVyaWMgcG9sbHV0YW50cyBvZiBpbXBvcnRhbmNlOyBzZWUgU2lncmlzdCAoMTk5NCkuCi0gVGhlIHJhbmdlIGlzIHRoZSBkaXN0YW5jZSB0cmF2ZWxlZCBiZWZvcmUgdGhlIGxpZ2h0IGlzIHJlZmxlY3RlZCBiYWNrIHRvIGl0cyBzb3VyY2UuCi0gVGhlIGxvZ3JhdGlvIGlzIHRoZSBsb2dhcml0aG0gb2YgdGhlIHJhdGlvIG9mIHJlY2VpdmVkIGxpZ2h0IGZyb20gdHdvIGxhc2VyIHNvdXJjZXMuCgogIC0gT25lIHNvdXJjZSBoYWQgYSBmcmVxdWVuY3kgZXF1YWwgdG8gdGhlIHJlc29uYW5jZSBmcmVxdWVuY3kgb2YgdGhlIGNvbXBvdW5kIG9mIGludGVyZXN0LCB3aGljaCB3YXMgbWVyY3VyeSBpbiB0aGlzIHN0dWR5LgogIC0gVGhlIG90aGVyIHNvdXJjZSBoYWQgYSBmcmVxdWVuY3kgb2ZmIHRoaXMgcmVzb25hbmNlIGZyZXF1ZW5jeS4KCiAgLSBUaGUgY29uY2VudHJhdGlvbiBvZiBtZXJjdXJ5IGNhbiBiZSBkZXJpdmVkIGZyb20gYSByZWdyZXNzaW9uIG1vZGVsIG9mIHRoZSBsb2dyYXRpbyBpbiBmdW5jdGlvbiBvZiAgdGhlIHJhbmdlIGZvciBlYWNoIHJhbmdlIHguCgpgYGB7cn0KbGlicmFyeSgiU2VtaVBhciIpCmRhdGEobGlkYXIpCnBMaWRhciA8LSBsaWRhciAlPiUKICBnZ3Bsb3QoYWVzKHggPSByYW5nZSwgeSA9IGxvZ3JhdGlvKSkgKwogIGdlb21fcG9pbnQoKSArCiAgeGxhYigicmFuZ2UgKG0pIikKCnBMaWRhciArCiAgZ2VvbV9zbW9vdGgoKQpgYGAKCi0gVGhlIGRhdGEgaXMgbm9uLWxpbmVhcgotIExpbmVhciByZWdyZXNzaW9uIHdpbGwgbm90IHdvcmshCi0gVGhlIGRhdGEgc2hvd3MgYSBzbW9vdGggcmVsYXRpb24gYmV0d2VlbiB0aGUgbG9ncmF0aW8gYW5kIHRoZSByYW5nZQoKIyMgQmFzaXMgZXhwYW5zaW9uCgpcW3lfaT1mKHhfaSkrXGVwc2lsb25faSxcXQp3aXRoClxbZih4KT1cc3VtXGxpbWl0c197az0xfV5LIFx0aGV0YV9rIGJfayh4KVxdCgotICBTZWxlY3Qgc2V0IG9mIGJhc2lzIGZ1bmN0aW9ucyAkYl9rKHgpJAotICBTZWxlY3QgbnVtYmVyIG9mIGJhc2lzIGZ1bmN0aW9ucyAkSyQKLSAgRXhhbXBsZXMKCiAgICAtICBQb2x5bm9taWFsIG1vZGVsOiAkeF5rJAogICAgLSAgT3J0aG9nb25hbCBzZXJpZXM6IEZvdXJpZXIsIExlZ2VuZHJlIHBvbHlub21pYWxzLCBXYXZlbGV0cwogICAgLSAgUG9seW5vbWlhbCBzcGxpbmVzOiAkMSwgeCwgKHgtdF9tKV8rJCB3aXRoICRtPTEsIFxsZG90cywgSy0yJCBrbm90cyAkdF9tJAogICAgLSAgLi4uCgojIyMgVHJ1bmN0YXRlZCBsaW5lIGJhc2lzCgpcW3lfaT1mKHhfaSkrXGVwc2lsb25faSxcXQoKLSAgT25lIG9mIHRoZSBtb3N0IHNpbXBsZSBiYXNpcyBleHBhbnNpb25zCi0gICRmKHhfaSk9XGJldGFfMCtcYmV0YV8xeF9pK1xzdW1cbGltaXRzX3ttPTF9XntLLTJ9XHRoZXRhX20oeF9pLXRfbSlfKyQgd2l0aCAkKC4pXyskIHRoZSBvcGVyYXRvciB0aGF0IHRha2VzIHRoZSBwb3NpdGl2ZSBwYXJ0LgotICBOb3RlLCB0aGF0IGJldHRlciBiYXNpcyBleHBhbnNpb25zIGV4aXN0LCB3aGljaCBhcmUgb3J0aG9nb25hbCwgY29tcHV0YXRpb25hbCBtb3JlIHN0YWJsZSBhbmQvb3IgY29udGludW91cyBkZXJpdmF0aXZlIGJleW9uZCBmaXJzdCBvcmRlcgotICBXZSB3aWxsIHVzZSB0aGlzIGJhc2lzIGZvciBkaWRhY3RpY2FsIHB1cnBvc2VzCi0gV2UgY2FuIHVzZSBPTFMgdG8gZml0IHkgdy5yLnQuIHRoZSBiYXNpcy4KCmBgYHtyfQprbm90cyA8LSBzZXEoNDAwLDcwMCwxMi41KQoKYmFzaXMgPC0gc2FwcGx5KGtub3RzLAogIGZ1bmN0aW9uKGsseSkgKHktaykqKHk+ayksCiAgeT0gbGlkYXIgJT4lIHB1bGwocmFuZ2UpCiAgKQoKYmFzaXNFeHAgPC0gY2JpbmQoMSwgcmFuZ2UgPSBsaWRhciAlPiUgcHVsbChyYW5nZSksIGJhc2lzKQoKc3BsaW5lRml0THMgPC0gbG0obG9ncmF0aW8gfiAtMSArIGJhc2lzRXhwLCBsaWRhcikKCnBCYXNpcyA8LSBiYXNpc0V4cFssLTFdICU+JQogIGRhdGEuZnJhbWUgJT4lCiAgZ2F0aGVyKCJiYXNpcyIsInZhbHVlcyIsLTEpICU+JQogIGdncGxvdChhZXMoeCA9IHJhbmdlLCB5ID0gdmFsdWVzLCBjb2xvciA9IGJhc2lzKSkgKwogIGdlb21fbGluZSgpICsKICB0aGVtZShsZWdlbmQucG9zaXRpb249Im5vbmUiKSArCiAgeWxhYigiYmFzaXMiKQoKZ3JpZC5hcnJhbmdlKAogIHBMaWRhciArCiAgICBnZW9tX2xpbmUoYWVzKHggPSBsaWRhciRyYW5nZSwgeSA9IHNwbGluZUZpdExzJGZpdHRlZCksIGx3ZCA9IDIpLAogIHBCYXNpcywKICBuY29sPTEpCmBgYAoKLSBOb3RlLCB0aGF0IHRoZSBtb2RlbCBpcyBvdmVyZml0dGluZyEKLSBUaGUgZml0IGlzIHZlcnkgd2lnZ2x5IGFuZCBpcyB0dW5lZCB0b28gbXVjaCB0byB0aGUgZGF0YS4KLSBUaGUgZml0IGhhcyBhIGxhcmdlIHZhcmlhbmNlIGFuZCBsb3cgYmlhcy4KLSBJdCB3aWxsIHRoZXJlZm9yZSBub3QgZ2VuZXJhbGlzZSB3ZWxsIHRvIHByZWRpY3QgdGhlIGxvZ3JhdGlvIG9mIGZ1dHVyZSBvYnNlcnZhdGlvbnMuCgojIyMjIFNvbHV0aW9uIGZvciBvdmVyZml0dGluZz8KCi0gV2UgY291bGQgcGVyZm9ybSBtb2RlbCBzZWxlY3Rpb24gb24gdGhlIGJhc2lzIHRvIHNlbGVjdCB0aGUgaW1wb3J0YW50IGJhc2lzIGZ1bmN0aW9ucyB0byBtb2RlbCB0aGUgc2lnbmFsLiBCdXQsIHRoaXMgd2lsbCBoYXZlIHRoZSB1bmRlc2lyZWQgcHJvcGVydHkgdGhhdCB0aGUgZml0IHdpbGwgbm8gbG9uZ2VyIGJlIHNtb290aC4KCi0gV2UgY2FuIGFsc28gYWRvcHQgYSByaWRnZSBwZW5hbHR5IQotIEhvd2V2ZXIsIHdlIGRvIG5vdCB3YW50IHRvIHBlbmFsaXNlIHRoZSBpbnRlcmNlcHQgYW5kIHRoZSBsaW5lYXIgdGVybS4gIAotIFJpZGdlIGNyaXRlcmlvbgoKXFtcVmVydFxtYXRoYmZ7WX0tXG1hdGhiZntYXGJldGF9XFZlcnReMitcbGFtYmRhXGJvbGRzeW1ib2x7XGJldGF9XlRcbWF0aGJme0R9XGJvbGRzeW1ib2x7XGJldGF9ClxdCgpXaXRoICRcbWF0aGJme0R9JCB3aXRoIGRpbWVuc2lvbnMgKEssSyk6ICRcbWF0aGJme0R9PVxsZWZ0W1xiZWdpbnthcnJheX17Y2N9XG1hdGhiZnswfV97Mlx0aW1lczJ9JiBcbWF0aGJmezB9X3syXHRpbWVzIEstMn1cXApcbWF0aGJmezB9X3tLLTJcdGltZXMyfSZcbWF0aGJme0l9X3tLLTJcdGltZXMgSy0yfVxlbmR7YXJyYXl9XHJpZ2h0XSQKCi0gSGVyZSB3ZSB3aWxsIHNldCB0aGUgcGVuYWx0eSBhdCA5MDAuCgpgYGB7cn0KRCA8LSBkaWFnKG5jb2woYmFzaXNFeHApKQpEWzE6MiwxOjJdIDwtIDAKbGFtYmRhIDwtIDkwMApiZXRhUmlkZ2UgPC0gc29sdmUodChiYXNpc0V4cCklKiViYXNpc0V4cCsobGFtYmRhKkQpKSUqJXQoYmFzaXNFeHApJSolbGlkYXIkbG9ncmF0aW8KZ3JpZC5hcnJhbmdlKAogIHBMaWRhciArCiAgICBnZW9tX2xpbmUoYWVzKHggPSBsaWRhciRyYW5nZSwgeSA9IGMoYmFzaXNFeHAgJSolIGJldGFSaWRnZSkpLCBsd2QgPSAyKSwKICBwQmFzaXMsCiAgbmNvbD0xKQpgYGAKCkhvdyBkbyB3ZSBjaG9vc2UgJFxsYW1iZGEkPwoKLS0tCgojIEV2YWx1YXRpb24gb2YgUHJlZGljdGlvbiBNb2RlbHMKCgpQcmVkaWN0aW9ucyBhcmUgY2FsY3VsYXRlZCB3aXRoIHRoZSBmaXR0ZWQgbW9kZWwKIFxbCiAgIFxoYXR7WX0oXG1hdGhiZnt4fSkgPSBcaGF0e219KFxtYXRoYmZ7eH0pPVxtYXRoYmZ7eH1eVFxoYXR7XGJldGF9CiBcXQogd2hlbiBmb2N1c3Npbmcgb24gcHJlZGljdGlvbiwgd2Ugd2FudCB0aGUgcHJlZGljdGlvbiBlcnJvciB0byBiZSBhcyBzbWFsbCBhcyBwb3NzaWJsZS4KClRoZSAqKnByZWRpY3Rpb24gZXJyb3IqKiBmb3IgYSBwcmVkaWN0aW9uIGF0IGNvdmFyaWF0ZSBwYXR0ZXJuICRcbWF0aGJme3h9JCBpcyBnaXZlbiBieQogIFxbCiAgICAgXGhhdHtZfShcbWF0aGJme3h9KSAtIFleKiwKICBcXQp3aGVyZQoKLSAkXGhhdHtZfShcbWF0aGJme3h9KT1cbWF0aGJme3h9XlRcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0kIGlzIHRoZSBwcmVkaWN0aW9uIGF0ICRcbWF0aGJme3h9JAoKLSAgJFleKiQgaXMgYW4gb3V0Y29tZSBhdCBjb3ZhcmlhdGUgcGF0dGVybiAkXG1hdGhiZnt4fSQKClByZWRpY3Rpb24gaXMgdHlwaWNhbGx5IHVzZWQgdG8gcHJlZGljdCBhbiBvdXRjb21lIGJlZm9yZSBpdCBpcyBvYnNlcnZlZC4KCi0gSGVuY2UsIHRoZSBvdXRjb21lICRZXiokIGlzIG5vdCBvYnNlcnZlZCB5ZXQsIGFuZAotIHRoZSBwcmVkaWN0aW9uIGVycm9yIGNhbm5vdCBiZSBjb21wdXRlZC4KCi0tLQoKLSBSZWNhbGwgdGhhdCB0aGUgcHJlZGljdGlvbiBtb2RlbCAkXGhhdHtZfShcbWF0aGJme3h9KSQgaXMgZXN0aW1hdGVkIGJ5IHVzaW5nIGRhdGEgaW4gdGhlIHRyYWluaW5nIGRhdGEgc2V0ICQoXG1hdGhiZntYfSxcbWF0aGJme1l9KSQsIGFuZAotIHRoYXQgdGhlIG91dGNvbWUgJFleKiQgaXMgYW4gb3V0Y29tZSBhdCAkXG1hdGhiZnt4fSQgd2hpY2ggaXMgYXNzdW1lZCB0byBiZSBpbmRlcGVuZGVudCBvZiB0aGUgdHJhaW5pbmcgZGF0YS4KCi0gR29hbCBpcyB0byB1c2UgcHJlZGljdGlvbiBtb2RlbCBmb3IgcHJlZGljdGluZyBhIGZ1dHVyZSBvYnNlcnZhdGlvbiAoJFleKiQpLCBpLmUuIGFuIG9ic2VydmF0aW9uIHRoYXQgc3RpbGwgaGFzIHRvIGJlIHJlYWxpc2VkL29ic2VydmVkIChvdGhlcndpc2UgcHJlZGljdGlvbiBzZWVtcyByYXRoZXIgdXNlbGVzcykuCgotIEhlbmNlLCAkWV4qJCBjYW4gbmV2ZXIgYmUgcGFydCBvZiB0aGUgdHJhaW5pbmcgZGF0YSBzZXQuCgotLS0KCkhlcmUgd2UgcHJvdmlkZSBkZWZpbml0aW9ucyBhbmQgd2Ugc2hvdyBob3cgdGhlIHByZWRpY3Rpb24gcGVyZm9ybWFuY2Ugb2YgYSBwcmVkaWN0aW9uIG1vZGVsIGNhbiBiZSBldmFsdWF0ZWQgZnJvbSBkYXRhLgoKTGV0ICR7XGNhbHtUfX09KFxtYXRoYmZ7WX0sXG1hdGhiZntYfSkkIGRlbm90ZSB0aGUgdHJhaW5pbmcgZGF0YSwgZnJvbSB3aGljaCB0aGUgcHJlZGljdGlvbiBtb2RlbCAkXGhhdHtZfShcY2RvdCkkIGlzIGJ1aWxkLiBUaGlzIGJ1aWxkaW5nIHByb2Nlc3MgdHlwaWNhbGx5IGludm9sdmVzIGZlYXR1cmUgc2VsZWN0aW9uIGFuZCBwYXJhbWV0ZXIgZXN0aW1hdGlvbi4KCiBXZSB3aWxsIHVzZSBhIG1vcmUgZ2VuZXJhbCBub3RhdGlvbiBmb3IgdGhlIHByZWRpY3Rpb24gbW9kZWw6ICRcaGF0e219KFxtYXRoYmZ7eH0pPVxoYXR7WX0oXG1hdGhiZnt4fSkkLgoKLS0tCgojIyBUZXN0IG9yIEdlbmVyYWxpc2F0aW9uIEVycm9yCgogVGhlIHRlc3Qgb3IgZ2VuZXJhbGlzYXRpb24gZXJyb3IgZm9yIHByZWRpY3Rpb24gbW9kZWwgJFxoYXR7bX0oXGNkb3QpJCBpcyBnaXZlbiBieQogIFxbCiAgICBcdGV4dHtFcnJ9X3tcY2Fse1R9fSA9IFx0ZXh0e0V9X3tZXiosWF4qfVxsZWZ0WyhcaGF0e219KFxtYXRoYmZ7WH1eKikgLSBZXiopXjJcbWlkIHtcY2Fse1R9fVxyaWdodF0KICBcXQogIHdoZXJlICQoWV4qLFheKikkIGlzIGluZGVwZW5kZW50IG9mIHRoZSB0cmFpbmluZyBkYXRhLgoKLS0tCgotIE5vdGUgdGhhdCB0aGUgdGVzdCBlcnJvciBpcyBjb25kaXRpb25hbCBvbiB0aGUgdHJhaW5pbmcgZGF0YSAke1xjYWx7VH19JC4KLSBIZW5jZSwgdGhlIHRlc3QgZXJyb3IgZXZhbHVhdGVzIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgc2luZ2xlIG1vZGVsIGJ1aWxkIGZyb20gdGhlIG9ic2VydmVkIHRyYWluaW5nIGRhdGEuCi0gVGhpcyBpcyB0aGUgdWx0aW1hdGUgdGFyZ2V0IG9mIHRoZSBtb2RlbCBhc3Nlc3NtZW50LCBiZWNhdXNlIGl0IGlzIGV4YWN0bHkgdGhpcyBwcmVkaWN0aW9uIG1vZGVsIHRoYXQgd2lsbCBiZSB1c2VkIGluIHByYWN0aWNlIGFuZCBhcHBsaWVkIHRvIGZ1dHVyZSBwcmVkaWN0b3JzICRcbWF0aGJme1h9XiokIHRvIHByZWRpY3QgJFleKiQuCi0gVGhlIHRlc3QgZXJyb3IgaXMgZGVmaW5lZCBhcyBhbiBhdmVyYWdlIG92ZXIgYWxsIHN1Y2ggZnV0dXJlIG9ic2VydmF0aW9ucyAkKFleKixcbWF0aGJme1h9XiopJC4KCi0tLQoKIyMgQ29uZGl0aW9uYWwgdGVzdCBlcnJvcgoKU29tZXRpbWVzIHRoZSBjb25kaXRpb25hbCB0ZXN0IGVycm9yIGlzIHVzZWQ6CgpUaGUgY29uZGl0aW9uYWwgdGVzdCBlcnJvciBpbiAkXG1hdGhiZnt4fSQgZm9yIHByZWRpY3Rpb24gbW9kZWwgJFxoYXR7bX0oXG1hdGhiZnt4fSkkIGlzIGdpdmVuIGJ5CiBcWwogICBcdGV4dHtFcnJ9X3tcY2Fse1R9fShcbWF0aGJme3h9KSA9IFx0ZXh0e0V9X3tZXip9XGxlZnRbKFxoYXR7bX0oXG1hdGhiZnt4fSkgLSBZXiopXjJcbWlkIHtcY2Fse1R9fSwgXG1hdGhiZnt4fVxyaWdodF0KIFxdCiB3aGVyZSAkWV4qJCBpcyBhbiBvdXRjb21lIGF0IHByZWRpY3RvciAkXG1hdGhiZnt4fSQsIGluZGVwZW5kZW50IG9mIHRoZSB0cmFpbmluZyBkYXRhLgoKIEhlbmNlLAogXFsKICAgXHRleHR7RXJyfV97XGNhbHtUfX0gPSBcdGV4dHtFfV97WF4qfVxsZWZ0W1x0ZXh0e0Vycn1fe1xjYWx7VH19KFxtYXRoYmZ7WH1eKilccmlnaHRdLgogXF0KCkEgY2xvc2VseSByZWxhdGVkIGVycm9yIGlzIHRoZSAqKmluc2FtcGxlIGVycm9yKiouCgotLS0KCiMjIEluc2FtcGxlIEVycm9yCgpUaGUgaW5zYW1wbGUgZXJyb3IgZm9yIHByZWRpY3Rpb24gbW9kZWwgJFxoYXR7bX0oXG1hdGhiZnt4fSkkIGlzIGdpdmVuIGJ5CiBcWwogICBcdGV4dHtFcnJ9X3tcdGV4dHtpbn0gXGNhbHtUfX0gPSBcZnJhY3sxfXtufVxzdW1fe2k9MX1ebiBcdGV4dHtFcnJ9X3tcY2Fse1R9fShcbWF0aGJme3h9X2kpLAogXF0KCmkuZS4gdGhlIGluc2FtcGxlIGVycm9yIGlzIHRoZSBzYW1wbGUgYXZlcmFnZSBvZiB0aGUgY29uZGl0aW9uYWwgdGVzdCBlcnJvcnMgZXZhbHVhdGVkIGluIHRoZSAkbiQgdHJhaW5pbmcgZGF0YXNldCBwcmVkaWN0b3JzICRcbWF0aGJme3h9X2kkLgoKU2luY2UgJFx0ZXh0e0Vycn1fe1xjYWx7VH19JCBpcyBhbiBhdmVyYWdlIG92ZXIgYWxsICRcbWF0aGJme1h9JCwgZXZlbiBvdmVyIHRob3NlIHByZWRpY3RvcnMgbm90IG9ic2VydmVkIGluIHRoZSB0cmFpbmluZyBkYXRhc2V0LCBpdCBpcyBzb21ldGltZXMgcmVmZXJyZWQgdG8gYXMgdGhlICoqb3V0c2FtcGxlIGVycm9yKiouCgotLS0KCiMjIEVzdGltYXRpb24gb2YgdGhlIGluc2FtcGxlIGVycm9yCgpXZSBzdGFydCB3aXRoIGludHJvZHVjaW5nIHRoZSB0cmFpbmluZyBlcnJvciByYXRlLCB3aGljaCBpcyBjbG9zZWx5IHJlbGF0ZWQgdG8gdGhlIE1TRSBpbiBsaW5lYXIgbW9kZWxzLgoKIyMjIFRyYWluaW5nIGVycm9yCgogVGhlIHRyYWluaW5nIGVycm9yIGlzIGdpdmVuIGJ5CiBcWwogICBcb3ZlcmxpbmV7XHRleHR7ZXJyfX0gPSBcZnJhY3sxfXtufVxzdW1fe2k9MX1ebiAoWV9pIC0gXGhhdHttfShcbWF0aGJme3h9X2kpKV4yICwKIFxdCiB3aGVyZSB0aGUgJChZX2ksXG1hdGhiZnt4fV9pKSQgZnJvbSB0aGUgdHJhaW5pbmcgZGF0YXNldCB3aGljaCBpcyBhbHNvIHVzZWQgZm9yIHRoZSBjYWxjdWxhdGlvbiBvZiAkXGhhdHttfSQuCgotIFRoZSB0cmFpbmluZyBlcnJvciBpcyBhbiBvdmVybHkgb3B0aW1pc3RpYyBlc3RpbWF0ZSBvZiB0aGUgdGVzdCBlcnJvciAkXHRleHR7RXJyfV97XGNhbHtUfX0kLgoKLSBUaGUgdHJhaW5pbmcgZXJyb3Igd2lsbCBuZXZlciBpbmNyZWFzZXMgd2hlbiB0aGUgbW9kZWwgYmVjb21lcyBtb3JlIGNvbXBsZXguICRcbG9uZ3JpZ2h0YXJyb3ckIGNhbm5vdCBiZSB1c2VkIGRpcmVjdGx5IGFzIGEgbW9kZWwgc2VsZWN0aW9uIGNyaXRlcmlvbi4KCkluZGVlZCwgbW9kZWwgcGFyYW1ldGVycyBhcmUgb2Z0ZW4gZXN0aW1hdGVkIGJ5IG1pbmltaXNpbmcgdGhlIHRyYWluaW5nIGVycm9yIChjZnIuIFNTRSkuCgotIEhlbmNlIHRoZSBmaXR0ZWQgbW9kZWwgYWRhcHRzIHRvIHRoZSB0cmFpbmluZyBkYXRhLCBhbmQKLSB0cmFpbmluZyBlcnJvciB3aWxsIGJlIGFuIG92ZXJseSBvcHRpbWlzdGljIGVzdGltYXRlIG9mIHRoZSB0ZXN0IGVycm9yICRcdGV4dHtFcnJ9X3tcY2Fse1R9fSQuCgotLS0KCkl0IGNhbiBiZSBzaG93biB0aGF0IHRoZSB0cmFpbmluZyBlcnJvciBpcyByZWxhdGVkIHRvIHRoZSBpbnNhbXBsZSB0ZXN0IGVycm9yIHZpYQoKXFsKXHRleHR7RX1fXG1hdGhiZntZfQpcbGVmdFtcdGV4dHtFcnJ9X3tcdGV4dHtpbn17XGNhbHtUfX19XHJpZ2h0XSA9IFx0ZXh0e0V9X1xtYXRoYmZ7WX1cbGVmdFtcb3ZlcmxpbmV7XHRleHR7ZXJyfX1ccmlnaHRdICsgXGZyYWN7Mn17bn1cc3VtX3tpPTF9Xm4gXHRleHR7Y292fV9cbWF0aGJme1l9XGxlZnRbXGhhdHttfShcbWF0aGJme3h9X2kpLFlfaVxyaWdodF0sClxdCgpOb3RlLCB0aGF0IGZvciBsaW5lYXIgbW9kZWxzClxbIFxoYXR7bX0oXG1hdGhiZnt4fV9pKSA9IFxtYXRoYmZ7WH1caGF0e1xib2xkc3ltYm9se1xiZXRhfX09IFxtYXRoYmZ7WH0oXG1hdGhiZntYfV5UXG1hdGhiZntYfSleey0xfVxtYXRoYmZ7WH1eVFxtYXRoYmZ7WX0gPSBcbWF0aGJme0hZfQpcXQp3aXRoCgotICRcbWF0aGJme0h9JCB0aGUgaGF0IG1hdHJpeCBhbmQKLSBhbGwgJFlfaSQgYXJlIGFzc3VtZWQgdG8gYmUgaW5kZXBlbmRlbnRseSBkaXN0cmlidXRlZCAgJE4oXG1hdGhiZntYfVxib2xkc3ltYm9se1xiZXRhfSxcc2lnbWFeMikkICAKCkhlbmNlLCBmb3IgbGluZWFyIG1vZGVscyB3aXRoIGluZGVwZW5kZW50IG9ic2VydmF0aW9ucwoKXGJlZ2lue2VxbmFycmF5fQpcdGV4dHtjb3Z9X1xtYXRoYmZ7WX1cbGVmdFtcaGF0e219KFxtYXRoYmZ7eH1faSksWV9pKVxyaWdodF0gJj0mClx0ZXh0e2Nvdn1fXG1hdGhiZntZfVxsZWZ0W1xtYXRoYmZ7SH1fe2l9XlRcbWF0aGJme1l9LFlfaSlccmlnaHRdXFwKJj0mIFx0ZXh0e2Nvdn1fXG1hdGhiZntZfVxsZWZ0W2hfe2lpfSBZX2ksWV9pXHJpZ2h0XVxcCiY9JiBoX3tpaX0gXHRleHR7Y292fV9cbWF0aGJme1l9XGxlZnRbWV9pLFlfaVxyaWdodF1cXAomPSYgaF97aWl9IFxzaWdtYV4yXFwKXGVuZHtlcW5hcnJheX0KCkFuZCB3ZSBjYW4gdGh1cyBlc3RpbWF0ZSB0aGUgaW5zYW1wbGUgZXJyb3IgYnkgTWFsbG93J3MgJENfcCQKClxiZWdpbntlcW5hcnJheX0KQ19wICY9JiBcb3ZlcmxpbmV7XHRleHR7ZXJyfX0gKyBcZnJhY3syXHNpZ21hXjJ9e259XHRleHR7dHJ9KFxtYXRoYmZ7SH0pXFwKJj0mIFxvdmVybGluZXtcdGV4dHtlcnJ9fSArIFxmcmFjezJcc2lnbWFeMnB9e259ClxlbmR7ZXFuYXJyYXl9Cgp3aXRoICRwJCB0aGUgbnVtYmVyIG9mIHByZWRpY3RvcnMuCgotIE1hbGxvdydzICRDX3AkIGlzIG9mdGVuIHVzZWQgZm9yIG1vZGVsIHNlbGVjdGlvbi4KLSBOb3RlLCB0aGF0IHdlIGNhbiBhbHNvIGNvbnNpZGVyIGl0IGFzIGEga2luZCBvZiBwZW5hbGl6ZWQgbGVhc3Qgc3F1YXJlczoKClxbCm4gXHRpbWVzIENfcCA9IFxWZXJ0IFxtYXRoYmZ7WX0gLSBcbWF0aGJme1h9XGJvbGRzeW1ib2x7XGJldGF9XFZlcnRfMl4yICsgMlxzaWdtYV4yIFxWZXJ0IFxib2xkc3ltYm9se1xiZXRhfSBcVmVydF8wClxdCndpdGggJExfMCQgbm9ybSAkXFZlcnQgXGJvbGRzeW1ib2x7XGJldGF9IFxWZXJ0XzAgPSBcc3VtX3tqPTF9XnAgXGJldGFfcF4wID0gcCQuCgotLS0KCiMjIEV4cGVjdGVkIHRlc3QgZXJyb3IKClRoZSB0ZXN0IG9yIGdlbmVyYWxpc2F0aW9uIGVycm9yIHdhcyBkZWZpbmVkIGNvbmRpdGlvbmFsbHkgb24gdGhlIHRyYWluaW5nIGRhdGEuIEJ5IGF2ZXJhZ2luZyBvdmVyIHRoZSBkaXN0cmlidXRpb24gb2YgdHJhaW5pbmcgZGF0YXNldHMsIHRoZSBleHBlY3RlZCB0ZXN0IGVycm9yIGFyaXNlcy4KClxiZWdpbntlcW5hcnJheSp9CiAgIFx0ZXh0e0V9X3tcY2Fse1R9fVxsZWZ0W1x0ZXh0e0Vycn1fe3tcY2Fse1R9fX1ccmlnaHRdCiAgICAgJj0mIFx0ZXh0e0V9X3tcY2Fse1R9fVxsZWZ0W1x0ZXh0e0V9X3tZXiosWF4qfVxsZWZ0WyhcaGF0e219KFxtYXRoYmZ7WH1eKikgLSBZXiopXjJcbWlkIHtcY2Fse1R9fVxyaWdodF1ccmlnaHRdIFxcCiAgICAgJj0mIFx0ZXh0e0V9X3tZXiosWF4qLHtcY2Fse1R9fX1cbGVmdFsoXGhhdHttfShcbWF0aGJme1h9XiopIC0gWV4qKV4yXHJpZ2h0XS4KIFxlbmR7ZXFuYXJyYXkqfQoKIC0gVGhlIGV4cGVjdGVkIHRlc3QgZXJyb3IgbWF5IG5vdCBiZSBvZiBkaXJlY3QgaW50ZXJlc3Qgd2hlbiB0aGUgZ29hbCBpcyB0byBhc3Nlc3MgdGhlIHByZWRpY3Rpb24gcGVyZm9ybWFuY2Ugb2YgYSBzaW5nbGUgcHJlZGljdGlvbiBtb2RlbCAkXGhhdHttfShcY2RvdCkkLgoKIC0gVGhlIGV4cGVjdGVkIHRlc3QgZXJyb3IgYXZlcmFnZXMgdGhlIHRlc3QgZXJyb3JzIG9mIGFsbCBtb2RlbHMgdGhhdCBjYW4gYmUgYnVpbGQgZnJvbSBhbGwgdHJhaW5pbmcgZGF0YXNldHMsIGFuZCBoZW5jZSB0aGlzIG1heSBiZSBsZXNzIHJlbGV2YW50IHdoZW4gdGhlIGludGVyZXN0IGlzIGluIGV2YWx1YXRpbmcgb25lIHBhcnRpY3VsYXIgbW9kZWwgdGhhdCByZXN1bHRlZCBmcm9tIGEgc2luZ2xlIG9ic2VydmVkIHRyYWluaW5nIGRhdGFzZXQuCgogLSBBbHNvIG5vdGUgdGhhdCBidWlsZGluZyBhIHByZWRpY3Rpb24gbW9kZWwgaW52b2x2ZXMgYm90aCBwYXJhbWV0ZXIgZXN0aW1hdGlvbiBhbmQgZmVhdHVyZSBzZWxlY3Rpb24uCgogLSBIZW5jZSB0aGUgZXhwZWN0ZWQgdGVzdCBlcnJvciBhbHNvIGV2YWx1YXRlcyB0aGUgZmVhdHVyZSBzZWxlY3Rpb24gcHJvY2VkdXJlIChvbiBhdmVyYWdlKS4KCiAtIElmIHRoZSBleHBlY3RlZCB0ZXN0IGVycm9yIGlzIHNtYWxsLCBpdCBpcyBhbiBpbmRpY2F0aW9uIHRoYXQgdGhlIG1vZGVsIGJ1aWxkaW5nIHByb2Nlc3MgZ2l2ZXMgZ29vZCBwcmVkaWN0aW9ucyBmb3IgZnV0dXJlIG9ic2VydmF0aW9ucyAkKFleKixcbWF0aGJme1h9XiopJCBvbiBhdmVyYWdlLgoKIyMjIEVzdGltYXRpbmcgdGhlIEV4cGVjdGVkIHRlc3QgZXJyb3IKClRoZSBleHBlY3RlZCB0ZXN0IGVycm9yIG1heSBiZSBlc3RpbWF0ZWQgYnkgY3Jvc3MgdmFsaWRhdGlvbiAoQ1YpLgoKIyMjIyBMZWF2ZSBvbmUgb3V0IGNyb3NzIHZhbGlkYXRpb24gKExPT0NWKX0KClRoZSBMT09DViBlc3RpbWF0b3Igb2YgdGhlIGV4cGVjdGVkIHRlc3QgZXJyb3IgKG9yIGV4cGVjdGVkIG91dHNhbXBsZSBlcnJvcikgaXMgZ2l2ZW4gYnkKICBcWwogICAgIFx0ZXh0e0NWfSA9IFxmcmFjezF9e259IFxzdW1fe2k9MX1ebiBcbGVmdChZX2kgLSBcaGF0e219XnstaX0oXG1hdGhiZnt4fV9pKVxyaWdodCleMiAsCiAgXF0Kd2hlcmUKCi0gdGhlICQoWV9pLFxtYXRoYmZ7eH1faSkkIGZvcm0gdGhlIHRyYWluaW5nIGRhdGFzZXQKLSAgICRcaGF0e219XnstaX0kIGlzIHRoZSBmaXR0ZWQgbW9kZWwgYmFzZWQgb24gYWxsIHRyYWluaW5nIGRhdGEsIGV4Y2VwdCBvYnNlcnZhdGlvbiAkaSQKLSAgICRcaGF0e219XnstaX0oXG1hdGhiZnt4fV9pKSQgaXMgdGhlIHByZWRpY3Rpb24gYXQgJFxtYXRoYmZ7eH1faSQsIHdoaWNoIGlzIHRoZSBvYnNlcnZhdGlvbiBsZWZ0IG91dCB0aGUgdHJhaW5pbmcgZGF0YSBiZWZvcmUgYnVpbGRpbmcgbW9kZWwgJG0kLgoKU29tZSByYXRpb25hbGUgYXMgdG8gd2h5IExPT0NWIG9mZmVycyBhIGdvb2QgZXN0aW1hdG9yIG9mIHRoZSBvdXRzYW1wbGUgZXJyb3I6CgotIHRoZSBwcmVkaWN0aW9uIGVycm9yICRZXiotXGhhdHttfShcbWF0aGJme3h9KSQgaXMgbWltaWNrZWQgYnkgbm90IHVzaW5nIG9uZSBvZiB0aGUgdHJhaW5pbmcgb3V0Y29tZXMgJFlfaSQgZm9yIHRoZSBlc3RpbWF0aW9uIG9mIHRoZSBtb2RlbCBzbyB0aGF0IHRoaXMgJFlfaSQgcGxheXMgdGhlIHJvbGUgb2YgJFleKiQsIGFuZCwgY29uc2VxdWVudGx5LCB0aGUgZml0dGVkIG1vZGVsICRcaGF0e219XnstaX0kIGlzIGluZGVwZW5kZW50IG9mICRZX2kkCgogLSB0aGUgc3VtIGluICRDViQgaXMgb3ZlciBhbGwgJFxtYXRoYmZ7eH1faSQgaW4gdGhlIHRyYWluaW5nIGRhdGFzZXQsIGJ1dCBlYWNoIHRlcm0gJFxtYXRoYmZ7eH1faSQgd2FzIGxlZnQgb3V0IG9uY2UgZm9yIHRoZSBjYWxjdWxhdGlvbiBvZiAkXGhhdHttfV57LWl9JC4gSGVuY2UsICRcaGF0e219XnstaX0oXG1hdGhiZnt4fV9pKSQgbWltaWNzIGFuIG91dHNhbXBsZSBwcmVkaWN0aW9uLgoKIC0gdGhlIHN1bSBpbiBDViBpcyBvdmVyICRuJCBkaWZmZXJlbnQgdHJhaW5pbmcgZGF0YXNldHMgKGVhY2ggb25lIHdpdGggYSBkaWZmZXJlbnQgb2JzZXJ2YXRpb24gcmVtb3ZlZCksIGFuZCBoZW5jZSBDViBpcyBhbiBlc3RpbWF0b3Igb2YgdGhlICpleHBlY3RlZCogdGVzdCBlcnJvci4KCiAtIEZvciBsaW5lYXIgbW9kZWxzIHRoZSBMT09DViBjYW4gYmUgcmVhZGlseSBvYnRhaW5lZCBmcm9tIHRoZSBmaXR0ZWQgbW9kZWw6IGkuZS4KCiBcW1x0ZXh0e0NWfSA9IFxmcmFjezF9e259XHN1bVxsaW1pdHNfe2k9MX1ebiBcZnJhY3tlX2leMn17KDEtaF97aWl9KV4yfVxdCgogd2l0aCAkZV9pJCB0aGUgcmVzaWR1YWxzIGZyb20gdGhlIG1vZGVsIHRoYXQgaXMgZml0dGVkIGJhc2VkIG9uIGFsbCB0cmFpbmluZyBkYXRhLgoKLS0tCgpBbiBhbHRlcm5hdGl2ZSB0byBMT09DViBpcyB0aGUgJGskLWZvbGQgY3Jvc3MgdmFsaWRhdGlvbiBwcm9jZWR1cmUuIEl0IGFsc28gZ2l2ZXMgYW4gZXN0aW1hdGUgb2YgdGhlIGV4cGVjdGVkIG91dHNhbXBsZSBlcnJvci4KCiMjIyMgJGskLWZvbGQgY3Jvc3MgdmFsaWRhdGlvbgoKLSAgUmFuZG9tbHkgZGl2aWRlIHRoZSB0cmFpbmluZyBkYXRhc2V0IGludG8gJGskIGFwcHJveGltYXRlbHkgZXF1YWwgc3Vic2V0cyAuIExldCAkU19qJCBkZW5vdGUgdGhlIGluZGV4IHNldCBvZiB0aGUgJGokdGggc3Vic2V0IChyZWZlcnJlZCB0byBhcyBhICoqZm9sZCoqKS4gTGV0ICRuX2okIGRlbm90ZSB0aGUgbnVtYmVyIG9mIG9ic2VydmF0aW9ucyBpbiBmb2xkICRqJC4KCi0gVGhlICRrJC1mb2xkIGNyb3NzIHZhbGlkYXRpb24gZXN0aW1hdG9yIG9mIHRoZSBleHBlY3RlZCBvdXRzYW1wbGUgZXJyb3IgaXMgZ2l2ZW4gYnkKIFxbCiAgICAgXHRleHR7Q1Z9X2sgPSBcZnJhY3sxfXtrfVxzdW1fe2o9MX1eayBcZnJhY3sxfXtuX2p9IFxzdW1fe2lcaW4gU19qfSBcbGVmdChZX2kgLSBcaGF0e219XnstU19qfShcbWF0aGJme3h9X2kpXHJpZ2h0KV4yCiBcXQogd2hlcmUgJFxoYXR7bX1eey1TX2p9JCBpcyB0aGUgbW9kZWwgZml0dGVkIHVzaW5nIGFsbCB0cmFpbmluZyBkYXRhLCBleGNlcHQgb2JzZXJ2YXRpb25zIGluIGZvbGQgJGokIChpLmUuIG9ic2VydmF0aW9ucyAkaSBcaW4gU19qJCkuCgotLS0KClRoZSBjcm9zcyB2YWxpZGF0aW9uIGVzdGltYXRvcnMgb2YgdGhlIGV4cGVjdGVkIG91dHNhbXBsZSBlcnJvciBhcmUgbmVhcmx5IHVuYmlhc2VkLiBPbmUgYXJndW1lbnQgdGhhdCBoZWxwcyB0byB1bmRlcnN0YW5kIHdoZXJlIHRoZSBiaWFzIGNvbWVzIGZyb20gaXMgdGhlIGZhY3QgdGhhdCBlLmcuIGluIGRlIExPT0NWIGVzdGltYXRvciB0aGUgbW9kZWwgaXMgZml0IG9uIG9ubHkgJG4tMSQgb2JzZXJ2YXRpb25zLCB3aGVyZWFzIHdlIGFyZSBhaW1pbmcgYXQgZXN0aW1hdGluZyB0aGUgb3V0c2FtcGxlIGVycm9yIG9mIGEgbW9kZWwgZml0IG9uIGFsbCAkbiQgdHJhaW5pbmcgb2JzZXJ2YXRpb25zLiBGb3J0dW5hdGVseSwgdGhlIGJpYXMgaXMgb2Z0ZW4gc21hbGwgYW5kIGlzIGluIHByYWN0aWNlIGhhcmRseSBhIGNvbmNlcm4uCgokayQtZm9sZCBDViBpcyBjb21wdXRhdGlvbmFsbHkgbW9yZSBjb21wbGV4LgoKU2luY2UgQ1YgYW5kIENWJF9rJCBhcmUgZXN0aW1hdG9ycywgdGhleSBhbHNvIHNob3cgc2FtcGxpbmcgdmFyaWFiaWxpdHkuIFN0YW5kYXJkIGVycm9ycyBvZiB0aGUgQ1Ygb3IgQ1YkX2skIGNhbiBiZSBjb21wdXRlZC4gV2UgZG9uJ3Qgc2hvdyB0aGUgZGV0YWlscywgYnV0IGluIHRoZSBleGFtcGxlIHRoaXMgaXMgaWxsdXN0cmF0ZWQuCgojIyMgQmlhcyBWYXJpYW5jZSB0cmFkZS1vZmYKCkZvciB0aGUgZXhwZWN0ZWQgY29uZGl0aW9uYWwgdGVzdCBlcnJvciBpbiAkXG1hdGhiZnt4fSQsIGl0IGhvbGRzIHRoYXQKXGJlZ2lue2VxbmFycmF5Kn0KICBcdGV4dHtFfV97XGNhbHtUfX1cbGVmdFtcdGV4dHtFcnJ9X3tcY2Fse1R9fShcbWF0aGJme3h9KVxyaWdodF0KICAgICY9JiBcdGV4dHtFfV97WV4qLHtcY2Fse1R9fX1cbGVmdFsoXGhhdHttfShcbWF0aGJme3h9KS1ZXiopXjIgXG1pZCBcbWF0aGJme3h9XHJpZ2h0XSBcXAogICAgJj0mICBcdGV4dHt2YXJ9X3tcbWF0aGJme1l9fVxsZWZ0W1xoYXR7WX0oXG1hdGhiZnt4fSlcbWlkIFxtYXRoYmZ7eH1ccmlnaHRdICsoXG11KFxtYXRoYmZ7eH0pLVxtdV4qKFxtYXRoYmZ7eH0pKV4yK1x0ZXh0e3Zhcn1fe1leKn1cbGVmdFtZXipcbWlkIFxtYXRoYmZ7eH1ccmlnaHRdClxlbmR7ZXFuYXJyYXkqfQp3aGVyZSAkXG11KFxtYXRoYmZ7eH0pID0gXHRleHR7RX1fe1xtYXRoYmZ7WX19XGxlZnRbXGhhdHtZfShcbWF0aGJme3h9KVxtaWQgXG1hdGhiZnt4fVxyaWdodF0gXHRleHR7IGFuZCB9IFxtdV4qKFxtYXRoYmZ7eH0pPVx0ZXh0e0V9X3tZXip9XGxlZnRbWV4qXG1pZCBcbWF0aGJme3h9XHJpZ2h0XSQuCgotICoqYmlhcyoqOiAkXHRleHR7Ymlhc30oXG1hdGhiZnt4fSk9XG11KFxtYXRoYmZ7eH0pLVxtdV4qKFxtYXRoYmZ7eH0pJAoKLSAkXHRleHR7dmFyfV97WV4qfVxsZWZ0W1leKlxtaWQgXG1hdGhiZnt4fVxyaWdodF0kIGRvZXMgbm90IGRlcGVuZCBvbiB0aGUgbW9kZWwsIGFuZCBpcyByZWZlcnJlZCB0byBhcyB0aGUgKippcnJlZHVjaWJsZSB2YXJpYW5jZSoqLgoKLS0tCgpUaGUgaW1wb3J0YW5jZSBvZiB0aGUgYmlhcy12YXJpYW5jZSB0cmFkZS1vZmYgY2FuIGJlIHNlZW4gZnJvbSBhIG1vZGVsIHNlbGVjdGlvbiBwZXJzcGVjdGl2ZS4gV2hlbiB3ZSBhZ3JlZSB0aGF0IGEgZ29vZCBtb2RlbCBpcyBhIG1vZGVsIHRoYXQgaGFzIGEgc21hbGwgZXhwZWN0ZWQgY29uZGl0aW9uYWwgdGVzdCBlcnJvciBhdCBzb21lIHBvaW50ICRcbWF0aGJme3h9JCwgdGhlbiB0aGUgYmlhcy12YXJpYW5jZSB0cmFkZS1vZmYgc2hvd3MgdXMgdGhhdCBhIG1vZGVsIG1heSBiZSBiaWFzZWQgYXMgbG9uZyBhcyBpdCBoYXMgYSBzbWFsbCB2YXJpYW5jZSB0byBjb21wZW5zYXRlIGZvciB0aGUgYmlhcy4gIEl0IG9mdGVuIGhhcHBlbnMgdGhhdCBhIGJpYXNlZCBtb2RlbCBoYXMgYSBzdWJzdGFudGlhbCBzbWFsbGVyIHZhcmlhbmNlLiBXaGVuIHRoZXNlIHR3byBhcmUgY29tYmluZWQsIGEgc21hbGwgZXhwZWN0ZWQgdGVzdCBlcnJvciBtYXkgb2NjdXIuCgpBbHNvIG5vdGUgdGhhdCB0aGUgbW9kZWwgJG0kIHdoaWNoIGZvcm1zIHRoZSBiYXNpcyBvZiB0aGUgcHJlZGljdGlvbiBtb2RlbCAkXGhhdHttfShcbWF0aGJme3h9KSQgZG9lcyBOT1QgbmVlZCB0byBzYXRpc2Z5ICRtKFxtYXRoYmZ7eH0pPVxtdShcbWF0aGJme3h9KSQgb3IgJG0oXG1hdGhiZnt4fSk9XG11XiooXG1hdGhiZnt4fSkkLiBUaGUgbW9kZWwgJG0kIGlzIGtub3duIGJ5IHRoZSBkYXRhLWFuYWx5c3QgKGl0cyB0aGUgYmFzaXMgb2YgdGhlIHByZWRpY3Rpb24gbW9kZWwpLCB3aGVyZWFzICRcbXUoXG1hdGhiZnt4fSkkIGFuZCAkXG11XiooXG1hdGhiZnt4fSkkIGFyZSBnZW5lcmFsbHkgdW5rbm93biB0byB0aGUgZGF0YS1hbmFseXN0LiBXZSBvbmx5IGhvcGUgdGhhdCAkbSQgc2VydmVzIHdlbGwgYXMgYSBwcmVkaWN0aW9uIG1vZGVsLgoKLS0tCgojIyMgSW4gcHJhY3RpY2UKCldlIHVzZSBjcm9zcyB2YWxpZGF0aW9uIHRvIGVzdGltYXRlIHRoZSBsYW1iZGEgcGVuYWx0eSBmb3IgcGVuYWxpc2VkIHJlZ3Jlc3Npb246CgotIFJpZGdlIFJlZ3Jlc3Npb24KLSBMYXNzbwotIEJ1aWxkIG1vZGVscywgZS5nLiBzZWxlY3QgdGhlIG51bWJlciBvZiBQQ3MgZm9yIFBDQSByZWdyZXNzaW9uCi0gU3BsaW5lcwoKIyMjIFRveGljb2dlbm9taWNzIGV4YW1wbGUKCiMjIyMgTGFzc28KCmBgYHtyfQpzZXQuc2VlZCgxNSkKbGlicmFyeShnbG1uZXQpCm1Ddkxhc3NvIDwtIGN2LmdsbW5ldCgKICB4ID0gdG94RGF0YVssLTFdICU+JQogICAgYXMubWF0cml4LAogIHkgPSB0b3hEYXRhICU+JQogICAgcHVsbChCQSksCiAgYWxwaGEgPSAxKSAgIyBsYXNzbyBhbHBoYT0xCgpwbG90KG1Ddkxhc3NvKQpgYGAKCkRlZmF1bHQgQ1YgcHJvY2VkdXJlIGluIFx0ZXh0c2Z7Y3YuZ2xtbmV0fSBpcyAkaz0xMCQtZm9sZCBDVi4KClRoZSBHcmFwaHMgc2hvd3MKCi0gMTAtZm9sZCBDViBlc3RpbWF0ZXMgb2YgdGhlIGV4dHJhLXNhbXBsZSBlcnJvciBhcyBhIGZ1bmN0aW9uIG9mIHRoZSBsYXNzbyBwZW5hbHR5IHBhcmFtZXRlciAkXGxhbWJkYSQuCi0gZXN0aW1hdGUgcGx1cyBhbmQgbWludXMgb25jZSB0aGUgZXN0aW1hdGVkIHN0YW5kYXJkIGVycm9yIG9mIHRoZSBDViBlc3RpbWF0ZSAoZ3JleSBiYXJzKQotIE9uIHRvcCB0aGUgbnVtYmVyIG9mIG5vbi16ZXJvIHJlZ3Jlc3Npb24gcGFyYW1ldGVyIGVzdGltYXRlcyBhcmUgc2hvd24uCgpUd28gdmVydGljYWwgcmVmZXJlbmNlIGxpbmVzIGFyZSBhZGRlZCB0byB0aGUgZ3JhcGguIFRoZXkgY29ycmVzcG9uZCB0bwoKLSB0aGUgJFxsb2coXGxhbWJkYSkkIHRoYXQgZ2l2ZXMgdGhlIHNtYWxsZXN0IENWIGVzdGltYXRlIG9mIHRoZSBleHRyYS1zYW1wbGUgZXJyb3IsIGFuZAotIHRoZSBsYXJnZXN0ICRcbG9nKFxsYW1iZGEpJCB0aGF0IGdpdmVzIGEgQ1YgZXN0aW1hdGUgb2YgdGhlIGV4dHJhLXNhbXBsZSBlcnJvciB0aGF0IGlzIHdpdGhpbiBvbmUgc3RhbmRhcmQgZXJyb3IgZnJvbSB0aGUgc21hbGxlc3QgZXJyb3IgZXN0aW1hdGUuCi0gVGhlIGxhdHRlciBjaG9pY2Ugb2YgJFxsYW1iZGEkIGhhcyBubyBmaXJtIHRoZW9yZXRpY2FsIGJhc2lzLCBleGNlcHQgdGhhdCBpdCBzb21laG93IGFjY291bnRzIGZvciB0aGUgaW1wcmVjaXNpb24gb2YgdGhlIGVycm9yIGVzdGltYXRlLiBPbmUgY291bGQgbG9vc2VseSBzYXkgdGhhdCB0aGlzICRcZ2FtbWEkIGNvcnJlc3BvbmRzIHRvIHRoZSBzbWFsbGVzdCBtb2RlbCAoaS5lLiBsZWFzdCBudW1iZXIgb2YgcHJlZGljdG9ycykgdGhhdCBnaXZlcyBhbiBlcnJvciB0aGF0IGlzIHdpdGhpbiBtYXJnaW4gb2YgZXJyb3Igb2YgdGhlIGVycm9yIG9mIHRoZSBiZXN0IG1vZGVsLgoKLS0tCgpgYGB7cn0KbUxhc3NvT3B0IDwtIGdsbW5ldCgKICB4ID0gdG94RGF0YVssLTFdICU+JQogICAgYXMubWF0cml4LAogIHkgPSB0b3hEYXRhICU+JQogICAgcHVsbChCQSksCiAgICBhbHBoYSA9IDEsCiAgICBsYW1iZGEgPSBtQ3ZMYXNzbyRsYW1iZGEubWluKQoKc3VtbWFyeShjb2VmKG1MYXNzb09wdCkpCmBgYAoKCldpdGggdGhlIG9wdGltYWwgJFxsYW1iZGEkIChzbWFsbGVzdCBlcnJvciBlc3RpbWF0ZSkgdGhlIG91dHB1dCBzaG93cyB0aGUgYHIgIG5yb3coc3VtbWFyeShjb2VmKG1MYXNzb09wdCkpKWAgbm9uLXplcm8gZXN0aW1hdGVkIHJlZ3Jlc3Npb24gY29lZmZpY2llbnRzIChzcGFyc2Ugc29sdXRpb24pLgoKLS0tCgpgYGB7cn0KbUxhc3NvMXNlIDwtIGdsbW5ldCgKICB4ID0gdG94RGF0YVssLTFdICU+JQogICAgYXMubWF0cml4LAogICAgeT0gdG94RGF0YSAlPiUKICAgICAgcHVsbChCQSksCiAgICBhbHBoYSA9IDEsCiAgICBsYW1iZGEgPSBtQ3ZMYXNzbyRsYW1iZGEuMXNlKQoKbUxhc3NvMXNlICU+JQogIGNvZWYgJT4lCiAgc3VtbWFyeQpgYGAKClRoaXMgc2hvd3MgdGhlIHNvbHV0aW9uIGZvciB0aGUgbGFyZ2VzdCAkXGxhbWJkYSQgd2l0aGluIG9uZSBzdGFuZGFyZCBlcnJvciBvZiB0aGUgb3B0aW1hbCBtb2RlbC4gTm93IG9ubHkgYHIgIG5yb3coc3VtbWFyeShjb2VmKG1MYXNzbzFzZSkpKWAgbm9uLXplcm8gZXN0aW1hdGVzIHJlc3VsdC4KCi0tLQoKIyMjIyBSaWRnZQoKYGBge3J9Cm1DdlJpZGdlIDwtIGN2LmdsbW5ldCgKICB4ID0gdG94RGF0YVssLTFdICU+JQogICAgYXMubWF0cml4LAogICAgeSA9IHRveERhdGEgJT4lCiAgICAgIHB1bGwoQkEpLAogICAgICBhbHBoYSA9IDApICAjIHJpZGdlIGFscGhhPTAKCnBsb3QobUN2UmlkZ2UpCmBgYAoKLSBSaWRnZSBkb2VzIG5vdCBzZWVtIHRvIGhhdmUgb3B0aW1hbCBzb2x1dGlvbi4KLSAxMC1mb2xkIENWIGlzIGFsc28gbGFyZ2VyIHRoYW4gZm9yIGxhc3NvLgoKLS0tCgojIyMjIFBDQSByZWdyZXNzaW9uCgpgYGB7ciBmaWcua2VlcCA9ICJub25lIiwgd2FybmluZyA9IEZBTFNFfQpzZXQuc2VlZCgxMjY0KQpsaWJyYXJ5KERBQUcpCgp0b3ggPC0gZGF0YS5mcmFtZSgKICBZID0gdG94RGF0YSAlPiUKICAgIHB1bGwoQkEpLAogIFBDID0gWmspCgpQQy5zZXEgPC0gMToyNQpFcnIgPC0gbnVtZXJpYygyNSkKCm1DdlBjYSA8LSBjdi5sbSgKICBZflBDLjEsCiAgZGF0YSA9IHRveCwKICBtID0gNSwKICBwcmludGl0ID0gRkFMU0UpCgpFcnJbMV08LWF0dHIobUN2UGNhLCJtcyIpCgpmb3IoaSBpbiAyOjI1KSB7CiAgbUN2UGNhIDwtIGN2LmxtKAogICAgYXMuZm9ybXVsYSgKICAgICAgcGFzdGUoIlkgfiBQQy4xICsgIiwKICAgICAgICBwYXN0ZSgiUEMuIiwgMjppLCBjb2xsYXBzZSA9ICIrIiwgc2VwPSIiKSwKICAgICAgICBzZXA9IiIKICAgICAgKQogICAgKSwKICAgIGRhdGEgPSB0b3gsCiAgICBtID0gNSwKICAgIHByaW50aXQgPSBGQUxTRSkKICBFcnJbaV08LWF0dHIobUN2UGNhLCJtcyIpCn0KYGBgCgotIEhlcmUgd2UgaWxsdXN0cmF0ZSBwcmluY2lwYWwgY29tcG9uZW50IHJlZ3Jlc3Npb24uCgotIFRoZSBtb3N0IGltcG9ydGFudCBQQ3MgYXJlIHNlbGVjdGVkIGluIGEgZm9yd2FyZCBtb2RlbCBzZWxlY3Rpb24gcHJvY2VkdXJlLgoKLSBXaXRoaW4gdGhlIG1vZGVsIHNlbGVjdGlvbiBwcm9jZWR1cmUgdGhlIG1vZGVscyBhcmUgZXZhbHVhdGVkIHdpdGggNS1mb2xkIENWIGVzdGltYXRlcyBvZiB0aGUgb3V0c2FtcGxlIGVycm9yLgoKLSBJdCBpcyBpbXBvcnRhbnQgdG8gcmVhbGlzZSB0aGF0IGEgZm9yd2FyZCBtb2RlbCBzZWxlY3Rpb24gcHJvY2VkdXJlIHdpbGwgbm90IG5lY2Vzc2FyaWx5IHJlc3VsdCBpbiB0aGUgYmVzdCBwcmVkaWN0aW9uIG1vZGVsLCBwYXJ0aWN1bGFybHkgYmVjYXVzZSB0aGUgb3JkZXIgb2YgdGhlIFBDcyBpcyBnZW5lcmFsbHkgbm90IHJlbGF0ZWQgdG8gdGhlIGltcG9ydGFuY2Ugb2YgdGhlIFBDcyBmb3IgcHJlZGljdGluZyB0aGUgb3V0Y29tZS4KCi0gQSBzdXBlcnZpc2VkIFBDIHdvdWxkIGJlIGJldHRlci4KCmBgYHtyfQpwUENyZWcgPC0gZGF0YS5mcmFtZShQQy5zZXEsIEVycikgJT4lCiAgZ2dwbG90KGFlcyh4ID0gUEMuc2VxLCB5ID0gRXJyKSkgKwogIGdlb21fbGluZSgpICsKICBnZW9tX3BvaW50KCkgKwogIGdlb21faGxpbmUoCiAgICB5aW50ZXJjZXB0ID0gYygKICAgICAgbUN2TGFzc28kY3ZtW21Ddkxhc3NvJGxhbWJkYT09bUN2TGFzc28kbGFtYmRhLm1pbl0sCiAgICAgIG1Ddkxhc3NvJGN2bVttQ3ZMYXNzbyRsYW1iZGE9PW1Ddkxhc3NvJGxhbWJkYS4xc2VdKSwKICAgIGNvbCA9ICJyZWQiKSArCiAgeGxpbSgxLDI2KQoKZ3JpZC5hcnJhbmdlKAogIHBQQ3JlZywKICBwUENyZWcgKyB5bGltKDAsNSksCiAgbmNvbD0yKQpgYGAKCi0gVGhlIGdyYXBoIHNob3dzIHRoZSBDViBlc3RpbWF0ZSBvZiB0aGUgb3V0c2FtcGxlIGVycm9yIGFzIGEgZnVuY3Rpb24gb2YgdGhlIG51bWJlciBvZiBzcGFyc2UgUENzIGluY2x1ZGVkIGluIHRoZSBtb2RlbC4KCi0gQSB2ZXJ5IHNtYWxsIGVycm9yIGlzIG9idGFpbmVkIHdpdGggdGhlIG1vZGVsIHdpdGggb25seSB0aGUgZmlyc3QgUEMuIFRoZSBiZXN0IG1vZGVsIHdpdGggMyBQQ3MuCgotIFRoZSB0d28gdmVydGljYWwgcmVmZXJlbmNlIGxpbmVzIGNvcnJlc3BvbmQgdG8gdGhlIGVycm9yIGVzdGltYXRlcyBvYnRhaW5lZCB3aXRoIGxhc3NvIChvcHRpbWFsICRcbGFtYmRhJCBhbmQgbGFyZ2VzdCAkXGxhbWJkYSQgd2l0aGluIG9uZSBzdGFuZGFyZCBlcnJvcikuCgotIFRodXMgYWx0aG91Z2ggdGhlcmUgd2FzIGEgcHJpb3JpIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBmaXJzdCBQQ3MgYXJlIHRoZSBtb3N0IHByZWRpY3RpdmUsIGl0IHNlZW1zIHRvIGJlIHRoZSBjYXNlIGhlcmUgKHdlIHdlcmUgbHVja3khKS4KCi0gTW9yZW92ZXIsIHRoZSBmaXJzdCBQQyByZXN1bHRlZCBpbiBhIHNtYWxsIG91dHNhbXBsZSBlcnJvci4KCi0gTm90ZSB0aGF0IHRoZSBncmFwaCBkb2VzIG5vdCBpbmRpY2F0ZSB0aGUgdmFyaWFiaWxpdHkgb2YgdGhlIGVycm9yIGVzdGltYXRlcyAobm8gZXJyb3IgYmFycykuCgotIEFsc28gbm90ZSB0aGF0IHRoZSBncmFwaCBjbGVhcmx5IGlsbHVzdHJhdGVzIHRoZSBlZmZlY3Qgb2Ygb3ZlcmZpdHRpbmc6IGluY2x1ZGluZyB0b28gbWFueSBQQ3MgY2F1c2VzIGEgbGFyZ2Ugb3V0c2FtcGxlIGVycm9yLgoKIyMjIExpZGFyIEV4YW1wbGU6IHNwbGluZXMKCi0gV2UgdXNlIHRoZSBtZ2N2IHBhY2thZ2UgdG8gZml0IHRoZSBzcGxpbmUgbW9kZWwgdG8gdGhlIGxpZGFyIGRhdGEuCi0gQSBiZXR0ZXIgYmFzaXMgaXMgdXNlZCB0aGFuIHRoZSB0cnVuY2F0ZWQgc3BsaW5lIGJhc2lzCi0gVGhpbiBwbGF0ZSBzcGxpbmVzIGFyZSBhbHNvIGxpbmVhciBzbW9vdGhlcnMsIGkuZS4gIAokXGhhdHtZfSA9IFxoYXR7bX0oXG1hdGhiZntYfSkgPSBcbWF0aGJme1NZfSQKLSBTbyB0aGVpciB2YXJpYW5jZSBjYW4gYmUgZWFzaWx5IGNhbGN1bGF0ZWQuCi0gVGhlIHJpZGdlL3Ntb290aG5lc3MgcGVuYWx0eSBpcyBjaG9zZW4gYnkgZ2VuZXJhbGl6ZWQgY3Jvc3MgdmFsaWRhdGlvbi4KCmBgYHtyfQpsaWJyYXJ5KG1nY3YpCmdhbWZpdCA8LSBnYW0obG9ncmF0aW8gfiBzKHJhbmdlKSwgZGF0YSA9IGxpZGFyKQpnYW1maXQkc3AKCnBMaWRhciArCiAgZ2VvbV9saW5lKGFlcyh4ID0gbGlkYXIkcmFuZ2UsIHkgPSBnYW1maXQkZml0dGVkKSwgbHdkID0gMikKYGBgCgojIyBNb3JlIGdlbmVyYWwgZXJyb3IgZGVmaW5pdGlvbnMKClNvIGZhciB3ZSBvbmx5IGxvb2tlZCBhdCBjb250aW51b3VzIG91dGNvbWVzICRZJCBhbmQgZXJyb3JzIGRlZmluZWQgaW4gdGVybXMgb2YgdGhlIHNxdWFyZWQgbG9zcyAkKFxoYXR7bX0oXG1hdGhiZnt4fSktWV4qKV4yJC4KCk1vcmUgZ2VuZXJhbGx5LCBhICoqbG9zcyBmdW5jdGlvbioqIG1lYXN1cmVzIGFuIGRpc2NyZXBhbmN5IGJldHdlZW4gdGhlIHByZWRpY3Rpb24gJFxoYXR7bX0oXG1hdGhiZnt4fSkkIGFuZCBhbiBpbmRlcGVuZGVudCBvdXRjb21lICRZXiokIHRoYXQgY29ycmVzcG9uZHMgdG8gJFxtYXRoYmZ7eH0kLgoKClNvbWUgZXhhbXBsZXMgZm9yIGNvbnRpbnVvdXMgJFkkOgpcYmVnaW57ZXFuYXJyYXkqfQogIEwoWV4qLFxoYXR7bX0oXG1hdGhiZnt4fSkpCiAgICAmPSYgKFxoYXR7bX0oXG1hdGhiZnt4fSktWV4qKV4yIFw7XDtcdGV4dHsoc3F1YXJlZCBlcnJvcil9IFxcCiAgTChZXiosXGhhdHttfShcbWF0aGJme3h9KSkKICAgICY9JiBcdmVydFxoYXR7bX0oXG1hdGhiZnt4fSktWV4qXHZlcnQgXDtcO1x0ZXh0eyhhYnNvbHV0ZSBlcnJvcil9IFxcCiAgIEwoWV4qLFxoYXR7bX0oXG1hdGhiZnt4fSkpCiAgICAmPSYgMiBcaW50X3tcY2Fse1l9fSBmX3koeSkgXGxvZ1xmcmFje2ZfeSh5KX17Zl97XGhhdHttfX0oeSl9IGR5IFw7XDtcdGV4dHsoZGV2aWFuY2UpfS4KXGVuZHtlcW5hcnJheSp9CgoKSW4gdGhlIGV4cHJlc3Npb24gb2YgdGhlIGRldmlhbmNlCgotICRmX3kkIGRlbm90ZXMgdGhlIGRlbnNpdHkgZnVuY3Rpb24gb2YgYSBkaXN0cmlidXRpb24gd2l0aCBtZWFuIHNldCB0byAkeSQgKGNmci4gcGVyZmVjdCBmaXQpLCBhbmQKLSAkZl97XGhhdHttfX0kIGlzIHRoZSBkZW5zaXR5IGZ1bmN0aW9uIG9mIHRoZSBzYW1lIGRpc3RyaWJ1dGlvbiBidXQgd2l0aCBtZWFuIHNldCB0byB0aGUgcHJlZGljdGVkIG91dGNvbWUgJFxoYXR7bX0oXG1hdGhiZnt4fSkkLgoKLS0tCgpXaXRoIGEgZ2l2ZW4gbG9zcyBmdW5jdGlvbiwgdGhlIGVycm9ycyBhcmUgZGVmaW5lZCBhcyBmb2xsb3dzOgotIFRlc3Qgb3IgZ2VuZXJhbGlzYXRpb24gb3Igb3V0c2FtcGxlIGVycm9yCiAgICBcWwogICAgICBcdGV4dHtFcnJ9X3tcY2Fse1R9fSA9IFx0ZXh0e0V9X3tZXiosWF4qfVxsZWZ0W0woWV4qLFxoYXR7bX0oXG1hdGhiZntYfV4qKSlccmlnaHRdCiAgICBcXQoKLSBUcmFpbmluZyBlcnJvcgogIFxbCiAgICBcb3ZlcmxpbmV7XHRleHR7ZXJyfX0gPSBcZnJhY3sxfXtufVxzdW1fe2k9MX1ebiBMKFlfaSxcaGF0e219KFxtYXRoYmZ7eH1faSkpCiAgXF0KCi0gJFxsZG90cyQKCi0tLQoKV2hlbiBhbiBleHBvbmVudGlhbCBmYW1pbHkgZGlzdHJpYnV0aW9uIGlzIGFzc3VtZWQgZm9yIHRoZSBvdXRjb21lIGRpc3RyaWJ1dGlvbiwgYW5kIHdoZW4gdGhlIGRldmlhbmNlIGxvc3MgaXMgdXNlZCwgdGhlIGluc2FtcGxlIGVycm9yIGNhbiBiZSBlc3RpbWF0ZWQgYnkgbWVhbnMgb2YgdGhlIEFJQyBhbmQgQklDLgoKIyMjIEFrYWlrZSdzIEluZm9ybWF0aW9uIENyaXRlcmlvbiAoQUlDKQoKVGhlIEFJQyBmb3IgYSBtb2RlbCAkbSQgaXMgZ2l2ZW4gYnkKXFsKXHRleHR7QUlDfSA9IC0yIFxsbiBcaGF0e0x9KG0pICsycApcXQp3aGVyZSAkXGhhdHtMfShtKSQgaXMgdGhlIG1heGltaXNlZCBsaWtlbGlob29kIGZvciBtb2RlbCAkbSQuCgpXaGVuIGFzc3VtaW5nIG5vcm1hbGx5IGRpc3RyaWJ1dGVkIGVycm9yIHRlcm1zIGFuZCBob21vc2NlZGFzdGljaXR5LCB0aGUgQUlDIGJlY29tZXMKXFsKXHRleHR7QUlDfSA9IG5cbG4gXHRleHR7U1NFfShtKSArMnAgPSBuXGxuKG5cb3ZlcmxpbmV7XHRleHR7ZXJyfX0obSkpICsgMnAKXF0Kd2l0aCAkXHRleHR7U1NFfShtKSQgdGhlIHJlc2lkdWFsIHN1bSBvZiBzcXVhcmVzIG9mIG1vZGVsICRtJC4KCkluIGxpbmVhciBtb2RlbHMgd2l0aCBub3JtYWwgZXJyb3IgdGVybXMsIE1hbGxvdydzICRDX3AkIGNyaXRlcmlvbiAoc3RhdGlzdGljKSBpcyBhIGxpbmVhcmlzZWQgdmVyc2lvbiBvZiBBSUMgYW5kIGl0IGlzIGFuIHVuYmlhc2VkIGVzdGltYXRvciBvZiB0aGUgaW4tc2FtcGxlIGVycm9yLgoKLS0tCgojIyMgQmF5ZXNpYW4gSW5mb3JtYXRpb24gQ3JpdGVyaW9uIChCSUMpfQoKVGhlIEJJQyBmb3IgYSBtb2RlbCAkbSQgaXMgZ2l2ZW4gYnkKXFsKXHRleHR7QklDfSA9IC0yIFxsbiBcaGF0e0x9KG0pICtwXGxuKG4pClxdCndoZXJlICRcaGF0e0x9KG0pJCBpcyB0aGUgbWF4aW1pc2VkIGxpa2VsaWhvb2QgZm9yIG1vZGVsICRtJC4KCldoZW4gYXNzdW1pbmcgbm9ybWFsbHkgZGlzdHJpYnV0ZWQgZXJyb3IgdGVybXMgYW5kIGhvbW9zY2VkYXN0aWNpdHksIHRoZSBCSUMgYmVjb21lcwpcWwpcdGV4dHtCSUN9ID0gblxsbiBcdGV4dHtTU0V9KG0pICtwXGxuKG4pID0gblxsbihuXG92ZXJsaW5le1x0ZXh0e2Vycn19KG0pKSArIHBcbG4obikKXF0Kd2l0aCAkXHRleHR7U1NFfShtKSQgdGhlIHJlc2lkdWFsIHN1bSBvZiBzcXVhcmVzIG9mIG1vZGVsICRtJC4KCldoZW4gbGFyZ2UgZGF0YXNldHMgYXJlIHVzZWQsIHRoZSBCSUMgd2lsbCBmYXZvdXIgc21hbGxlciBtb2RlbHMgdGhhbiB0aGUgQUlDLgoKLS0tCgojIyBUcmFpbmluZyBhbmQgdGVzdCBzZXRzCgpTb21ldGltZXMsIHdoZW4gYSBsYXJnZSAodHJhaW5pbmcpIGRhdGFzZXQgaXMgYXZhaWxhYmxlLCBvbmUgbWF5IGRlY2lkZSB0aGUgc3BsaXQgdGhlIGRhdGFzZXQgcmFuZG9tbHkgaW4gYQoKLSAqKnRyYWluaW5nIGRhdGFzZXQqKjoKICAgZGF0YSBhcmUgdXNlZCBmb3IgbW9kZWwgZml0dGluZyBhbmQgZm9yIG1vZGVsIGJ1aWxkaW5nIG9yIGZlYXR1cmUgc2VsZWN0aW9uICh0aGlzIG1heSByZXF1aXJlIGUuZy4gY3Jvc3MgdmFsaWRhdGlvbikKCi0gKip0ZXN0IGRhdGFzZXQqKjoKICAgdGhpcyBkYXRhIGFyZSB1c2VkIHRvIGV2YWx1YXRlIHRoZSBmaW5hbCBtb2RlbCAocmVzdWx0IG9mIG1vZGVsIGJ1aWxkaW5nKS4gQW4gdW5iaWFzZWQgZXN0aW1hdGUgb2YgdGhlIG91dHNhbXBsZSBlcnJvciAoaS5lLiB0ZXN0IG9yIGdlbmVyYWxpc2F0aW9uIGVycm9yKSBiYXNlZCBvbiB0aGlzIHRlc3QgZGF0YSBpcwogIFxbCiAgICAgXGZyYWN7MX17bX0gXHN1bV97aT0xfV5tIFxsZWZ0KFxoYXR7bX0oXG1hdGhiZnt4fV9pKS1ZX2lccmlnaHQpXjIsCiAgXF0KICB3aGVyZQogICAgLSAkKFlfMSxcbWF0aGJme3h9XzEpLCBcbGRvdHMsIChZX20sXG1hdGhiZnt4fV9tKSQgZGVub3RlIHRoZSAkbSQgb2JzZXJ2YXRpb25zIGluIHRoZSB0ZXN0IGRhdGFzZXQKCiAgICAtICRcaGF0e219JCBpcyBlc3RpbWF0ZWQgZnJvbSB1c2luZyB0aGUgdHJhaW5pbmcgZGF0YSAodGhpcyBtYXkgYWxzbyBiZSB0aGUgcmVzdWx0IGZyb20gbW9kZWwgYnVpbGRpbmcsIHVzaW5nIG9ubHkgdGhlIHRyYWluaW5nIGRhdGEpLgoKLS0tCgpOb3RlIHRoYXQgdGhlIHRyYWluaW5nIGRhdGFzZXQgaXMgdXNlZCBmb3IgbW9kZWwgYnVpbGRpbmcgb3IgZmVhdHVyZSBzZWxlY3Rpb24uIFRoaXMgYWxzbyByZXF1aXJlcyB0aGUgZXZhbHVhdGlvbiBvZiBtb2RlbHMuIEZvciB0aGVzZSBldmFsdWF0aW9ucyB0aGUgbWV0aG9kcyBmcm9tIHRoZSBwcmV2aW91cyBzbGlkZXMgY2FuIGJlIHVzZWQgKGUuZy4gY3Jvc3MgdmFsaWRhdGlvbiwgJGskLWZvbGQgQ1YsIE1hbGxvdydzICRDX3AkKS4gVGhlIHRlc3QgZGF0YXNldCBpcyBvbmx5IHVzZWQgZm9yIHRoZSAgZXZhbHVhdGlvbiBvZiB0aGUgZmluYWwgbW9kZWwgKGVzdGltYXRlZCBhbmQgYnVpbGQgZnJvbSB1c2luZyBvbmx5IHRoZSB0cmFpbmluZyBkYXRhKS4gVGhlIGVzdGltYXRlIG9mIHRoZSBvdXRzYW1wbGUgZXJyb3IgYmFzZWQgb24gdGhlIHRlc3QgZGF0YXNldCBpcyB0aGUgYmVzdCBwb3NzaWJsZSBlc3RpbWF0ZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBpcyB1bmJpYXNlZC4gVGhlIG9ic2VydmF0aW9ucyB1c2VkIGZvciB0aGlzIGVzdGltYXRpb24gYXJlIGluZGVwZW5kZW50IG9mIHRoZSBvYnNlcnZhdGlvbnMgaW4gdGhlIHRyYWluaW5nIGRhdGEuCkhvd2V2ZXIsIGlmIHRoZSBudW1iZXIgb2YgZGF0YSBwb2ludHMgaW4gdGhlIHRlc3QgZGF0YXNldCAoJG0kKSBpcyBzbWFsbCwgdGhlIGVzdGltYXRlIG9mIHRoZSBvdXRzYW1wbGUgZXJyb3IgbWF5IHNob3cgbGFyZ2UgdmFyaWFuY2UgYW5kIGhlbmNlIGlzIG5vdCByZWxpYWJsZS4KCiMgTG9naXN0aWMgUmVncmVzc2lvbiBBbmFseXNpcyBmb3IgSGlnaCBEaW1lbnNpb25hbCBEYXRhCgojIyBDYW5jZXIgRXhhbXBsZQoKLSBTY2htaWR0ICpldCBhbC4qLCAyMDA4LCBDYW5jZXIgUmVzZWFyY2gsIHtcYmYgNjh9LCA1NDA1LTU0MTMKCi0gR2VuZSBleHByZXNzaW9uIHBhdHRlcm5zIGluICRuPTIwMCQgYnJlYXN0IHR1bW9ycyB3ZXJlIGludmVzdGlnYXRlZCAoJHA9MjIyODMkIGdlbmVzKQoKLSBBZnRlciBzdXJnZXJ5IHRoZSB0dW1vcnMgd2VyZSBncmFkZWQgYnkgYSBwYXRob2xvZ2lzdCAoc3RhZ2UgMSwyLDMpCgotIEhlcmUgdGhlIG9iamVjdGl2ZSBpcyB0byBwcmVkaWN0IHN0YWdlIDMgZnJvbSB0aGUgZ2VuZSBleHByZXNzaW9uIGRhdGEgKHByZWRpY3Rpb24gb2YgYmluYXJ5IG91dGNvbWUpCgotIElmIHRoZSBwcmVkaWN0aW9uIG1vZGVsIHdvcmtzIHdlbGwsIGl0IGNhbiBiZSB1c2VkIHRvIHByZWRpY3QgdGhlIHN0YWdlIGZyb20gYSBiaW9wc3kgc2FtcGxlLgoKLS0tCgojIyBMb2dpc3RpYyByZWdyZXNzaW9uIG1vZGVscwoKQmluYXJ5IG91dGNvbWVzIGFyZSBvZnRlbiBhbmFseXNlZCB3aXRoICoqbG9naXN0aWMgcmVncmVzc2lvbiBtb2RlbHMqKi4KCkxldCAkWSQgZGVub3RlIHRoZSBiaW5hcnkgKDEvMCwgY2FzZS9jb250cm9sLCBwb3NpdGl2ZS9uZWdhdGl2ZSkgb3V0Y29tZSwgYW5kICRcbWF0aGJme3h9JCB0aGUgJHAkLWRpbWVuc2lvbmFsIHByZWRpY3Rvci4KCkxvZ2lzdGljIHJlZ3Jlc3Npb24gIGFzc3VtZXMKXFsKICAgWSBcbWlkIFxtYXRoYmZ7eH0gXHNpbSBcdGV4dHtCZXJub3VsbGl9KFxwaShcbWF0aGJme3h9KSkKXF0Kd2l0aCAkXHBpKFxtYXRoYmZ7eH0pID0gXHRleHR7UH1cbGVmdFtZPTFcbWlkIFxtYXRoYmZ7eH1ccmlnaHRdJCBhbmQKXFsKICAgXGxuIFxmcmFje1xwaShcbWF0aGJme3h9KX17MS1ccGkoXG1hdGhiZnt4fSl9PVxiZXRhXzAgKyBcYm9sZHN5bWJvbHtcYmV0YX1eVFxtYXRoYmZ7eH0uClxdCgpUaGUgcGFyYW1ldGVycyBhcmUgdHlwaWNhbGx5IGVzdGltYXRlZCBieSBtYXhpbWlzaW5nIHRoZSBsb2ctbGlrZWxpaG9vZCwgd2hpY2ggaXMgZGVub3RlZCBieSAkbChcbWF0aGJmewpcYmV0YX0pJCwgaS5lLgpcWwogICBcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0gPSBcdGV4dHtBcmdNYXh9X1xiZXRhIGwoXGJvbGRzeW1ib2x7XGJldGF9KS4KXF0KCi0gTWF4aW11bSBsaWtlbGlob29kIGlzIG9ubHkgYXBwbGljYWJsZSB3aGVuICRuPnAkLgoKLSBXaGVuICRwPm4kIHBlbmFsaXNlZCBtYXhpbXVtIGxpa2VsaWhvb2QgbWV0aG9kcyBhcmUgYXBwbGljYWJsZS4KCi0tLQoKIyMgUGVuYWxpemVkIG1heGltdW0gbGlrZWxpaG9vZAoKUGVuYWxpc2VkIGVzdGltYXRpb24gbWV0aG9kcyAoZS5nLiBsYXNzbyBhbmQgcmlkZ2UpIGNhbiBhbHMgYmUgYXBwbGllZCB0byBtYXhpbXVtIGxpa2VsaWhvb2QsIHJlc3VsdGluZyBpbiB0aGUgKipwZW5hbGlzZWQgbWF4aW11bSBsaWtlbGlob29kIGVzdGltYXRlKiouCgpMYXNzbzoKXFsKICBcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0gPSBcdGV4dHtBcmdNYXh9X1xiZXRhIGwoXGJvbGRzeW1ib2x7XGJldGF9KSAtXGxhbWJkYSBcVmVydCBcYm9sZHN5bWJvbHtcYmV0YX1cVmVydF8xLgpcXQoKUmlkZ2U6ClxbCiAgXGhhdHtcYm9sZHN5bWJvbHtcYmV0YX19ID0gXHRleHR7QXJnTWF4fV9cYmV0YSBsKFxib2xkc3ltYm9se1xiZXRhfSkgLVxsYW1iZGEgXFZlcnQgXGJvbGRzeW1ib2x7XGJldGF9XFZlcnRfMl4yLgpcXQoKT25jZSB0aGUgcGFyYW1ldGVycyBhcmUgZXN0aW1hdGVkLCB0aGUgbW9kZWwgbWF5IGJlIHVzZWQgdG8gY29tcHV0ZQpcWwogIFxoYXR7XHBpfShcbWF0aGJme3h9KSA9IFxoYXR7XHRleHR7UH19XGxlZnRbWT0xXG1pZCBcbWF0aGJme3h9XHJpZ2h0XS4KXF0KV2l0aCB0aGVzZSBlc3RpbWF0ZWQgcHJvYmFiaWxpdGllcyB0aGUgcHJlZGljdGlvbiBydWxlIGJlY29tZXMKXGJlZ2lue2VxbmFycmF5Kn0KICBcaGF0e1xwaX0oXG1hdGhiZnt4fSkgJlxsZXEgYyYgXHRleHR7cHJlZGljdCB9IFk9MCBcXAogIFxoYXR7XHBpfShcbWF0aGJme3h9KSAmPmMgJiBcdGV4dHtwcmVkaWN0IH0gWT0xClxlbmR7ZXFuYXJyYXkqfQp3aXRoICQwPGM8MSQgYSB0aHJlc2hvbGQgdGhhdCBlaXRoZXIgaXMgZml4ZWQgKGUuZy4gJGM9MS8yJCksIGRlcGVuZHMgb24gcHJpb3IgcHJvYmFiaWxpdGllcywgb3IgaXMgZW1waXJpY2FsbHkgZGV0ZXJtaW5lZCBieSBvcHRpbWlzaW5nIGUuZy4gdGhlIEFyZWEgVW5kZXIgdGhlIFJPQyBDdXJ2ZSAoQVVDKSBvciBieSBmaW5kaW5nIGEgZ29vZCBjb21wcm9taXNlIGJldHdlZW4gc2Vuc2l0aXZpdHkgYW5kIHNwZWNpZmljaXR5LgoKTm90ZSB0aGF0IGxvZ2lzdGljIHJlZ3Jlc3Npb24gZGlyZWN0bHkgbW9kZWxzIHRoZSAqKlBvc3RlcmlvciBwcm9iYWJpbGl0eSoqIHRoYXQgYW4gb2JzZXJ2YXRpb24gYmVsb25ncyB0byBjbGFzcyAkWT0xJCwgZ2l2ZW4gdGhlIHByZWRpY3RvciAkXG1hdGhiZnt4fSQuCgojIyBNb2RlbCBldmFsdWF0aW9uCgpDb21tb24gbW9kZWwgZXZhbHVhdGlvbiBjcml0ZXJpYSBmb3IgYmluYXJ5IHByZWRpY3Rpb24gbW9kZWxzIGFyZToKCi0gc2Vuc2l0aXZpdHkgPSB0cnVlIHBvc2l0aXZlIHJhdGUgKFRQUikKCi0gc3BlY2lmaWNpdHkgPSB0cnVlIG5lZ2F0aXZlIHJhdGUgKFROUikKCi0gbWlzY2xhc3NpZmljYXRpb24gZXJyb3IKCi0gYXJlYSB1bmRlciB0aGUgUk9DIGN1cnZlIChBVUMpCgpUaGVzZSBjcml0ZXJpYSBjYW4gYWdhaW4gYmUgZXN0aW1hdGVkIHZpYSBjcm9zcyB2YWxpZGF0aW9uIG9yIHZpYSBzcGxpdHRpbmcgb2YgdGhlIGRhdGEgaW50byB0cmFpbmluZyBhbmQgdGVzdC92YWxpZGF0aW9uIGRhdGEuCgojIyMgU2Vuc2l0aXZpdHkgb2YgYSBtb2RlbCAkXHBpJCB3aXRoIHRocmVzaG9sZCAkYyQKClNlbnNpdGl2aXR5IGlzIHRoZSBwcm9iYWJpbGl0eSB0byBjb3JyZWN0bHkgcHJlZGljdCBhIHBvc2l0aXZlIG91dGNvbWU6ClxbClx0ZXh0e3NlbnN9KFxwaSxjKT1cdGV4dHtQfV97WF4qfVxsZWZ0W1xoYXRccGkoXG1hdGhiZntYfV4qKT5jIFxtaWQgWV4qPTEgXG1pZCB7XGNhbHtUfX1ccmlnaHRdLgpcXQoKSXQgaXMgYWxzbyBrbm93biBhcyB0aGUgdHJ1ZSBwb3NpdGl2ZSByYXRlIChUUFIpLgoKIyMjIFNwZWNpZmljaXR5IG9mIGEgbW9kZWwgJFxwaSQgd2l0aCB0aHJlc2hvbGQgJGMkCgpTcGVjaWZpY2l0eSBpcyB0aGUgcHJvYmFiaWxpdHkgdG8gY29ycmVjdGx5IHByZWRpY3QgYSBuZWdhdGl2ZSBvdXRjb21lOgpcWwpcdGV4dHtzcGVjfShccGksYyk9XHRleHR7UH1fe1heKn1cbGVmdFtcaGF0XHBpKFxtYXRoYmZ7WH1eKilcbGVxIGMgXG1pZCBZXio9MCBcbWlkIHtcY2Fse1R9fVxyaWdodF0uClxdCgpJdCBpcyBhbHNvIGtub3duIGFzIHRoZSB0cnVlIG5lZ2F0aXZlIHJhdGUgKFROUikuCgotLS0KCiMjIyBNaXNjbGFzc2lmaWNhdGlvbiBlcnJvciBvZiBhIG1vZGVsICRccGkkIHdpdGggdGhyZXNob2xkICRjJAoKVGhlIG1pc2NsYXNzaWZpY2F0aW9uIGVycm9yIGlzIHRoZSBwcm9iYWJpbGl0eSB0byBpbmNvcnJlY3RseSBwcmVkaWN0IGFuIG91dGNvbWU6ClxiZWdpbntlcW5hcnJheSp9Clx0ZXh0e21jZX0oXHBpLGMpICY9Jlx0ZXh0e1B9X3tYXiosWV4qfVxsZWZ0W1xoYXRccGkoXG1hdGhiZntYfSlcbGVxIGMgXHRleHR7IGFuZCB9IFleKj0xIFxtaWQge1xjYWx7VH19XHJpZ2h0XSBcXAomICAmICsgXHRleHR7UH1fe1heKixZXip9XGxlZnRbXGhhdFxwaShcbWF0aGJme1h9KT4gYyBcdGV4dHsgYW5kIH0gWV4qPTAgXG1pZCB7XGNhbHtUfX1ccmlnaHRdLgpcZW5ke2VxbmFycmF5Kn0KCk5vdGUgdGhhdCBpbiB0aGUgZGVmaW5pdGlvbnMgb2Ygc2Vuc2l0aXZpdHksIHNwZWNpZmljaXR5IGFuZCB0aGUgbWlzY2xhc3NpZmljYXRpb24gZXJyb3IsIHRoZSBwcm9iYWJpbGl0aWVzIHJlZmVyIHRvIHRoZSBkaXN0cmlidXRpb24gb2YgdGhlICAkKFxtYXRoYmZ7WH1eKixZXiopJCwgd2hpY2ggaXMgaW5kZXBlbmRlbnQgb2YgdGhlIHRyYWluaW5nIGRhdGEsIGNvbmRpdGlvbmFsIG9uIHRoZSB0cmFpbmluZyBkYXRhLiBUaGlzIGlzIGluIGxpbmUgd2l0aCB0aGUgdGVzdCBvciBnZW5lcmFsaXNhdGlvbiBlcnJvci4gVGhlIG1pc2NsYXNzaWZpY2F0aW9uIGVycm9yIGlzIGFjdHVhbGx5IHRoZSB0ZXN0IGVycm9yIHdoZW4gYSAwLzEgbG9zcyBmdW5jdGlvbiBpcyB1c2VkLiBKdXN0IGFzIGJlZm9yZSwgdGhlIHNlbnNpdGl2aXR5LCBzcGVjaWZpY2l0eSBhbmQgdGhlIG1pc2NsYXNzaWZpY2F0aW9uIGVycm9yIGNhbiBhbHNvIGJlIGF2ZXJhZ2VkIG92ZXIgdGhlIGRpc3RyaWJ1dGlvbiBvZiB0aGUgdHJhaW5pbmcgZGF0YSBzZXQsIHdoaWNoIGlzIGluIGxpbmUgd2l0aCB0aGUgZXhwZWN0ZWQgdGVzdCBlcnJvciB3aGljaCBoYXMgYmVlbiBkaXNjdXNzZWQgZWFybGllci4KCi0tLQoKIyMjIFJPQyBjdXJ2ZSBvZiBhIG1vZGVsICRccGkkCgpUaGUgUmVjZWl2ZXIgT3BlcmF0aW5nIENoYXJhY3RlcmlzdGljIChST0MpIGN1cnZlIGZvciBtb2RlbCAkXHBpJCBpcyBnaXZlbiBieSB0aGUgZnVuY3Rpb24KClxbClx0ZXh0e1JPQ306IFswLDFdIFxyaWdodGFycm93IFswLDFdXHRpbWVzIFswLDFdOiBjIFxtYXBzdG8gKDEtXHRleHR7c3BlY30oXHBpLGMpLCBcdGV4dHtzZW5zfShccGksYykpLgpcXQoKRm9yIHdoZW4gJGMkIG1vdmVzIGZyb20gMSB0byAwLCB0aGUgUk9DIGZ1bmN0aW9uIGRlZmluZXMgYSBjdXJ2ZSBpbiB0aGUgcGxhbmUgJFswLDFdXHRpbWVzIFswLDFdJCwgbW92aW5nIGZyb20gJCgwLDApJCBmb3IgJGM9MSQgdG8gJCgxLDEpJCBmb3IgJGM9MCQuCgpUaGUgaG9yaXpvbnRhbCBheGlzIG9mIHRoZSBST0MgY3VydmUgc2hvd3MgMS1zcGVjaWZpY2l0eS4gVGhpcyBpcyBhbHNvIGtub3duIGFzIHRoZSBGYWxzZSBQb3NpdGl2ZSBSYXRlIChGUFIpLgoKLS0tCgojIyMgQXJlYSB1bmRlciB0aGUgY3VydmUgKEFVQykgb2YgYSBtb2RlbCAkXHBpJAoKVGhlIGFyZWEgdW5kZXIgdGhlIGN1cnZlIChBVUMpIGZvciBtb2RlbCAkXHBpJCBpcyBhcmVhIHVuZGVyIHRoZSBST0MgY3VydmUgYW5kIGlzIGdpdmVuIGJ5ClxbClxpbnRfMF4xIFx0ZXh0e1JPQ30oYykgZGMuClxdCgpTb21lIG5vdGVzIGFib3V0IHRoZSBBVUM6CgotIEFVQz0wLjUgcmVzdWx0cyB3aGVuIHRoZSBST0MgY3VydmUgaXMgdGhlIGRpYWdvbmFsLiBUaGlzIGNvcnJlc3BvbmRzIHRvIGZsaXBwaW5nIGEgY29pbiwgaS5lLiBhIGNvbXBsZXRlIHJhbmRvbSBwcmVkaWN0aW9uLgoKLSBBVUM9MSByZXN1bHRzIGZyb20gdGhlIHBlcmZlY3QgUk9DIGN1cnZlLCB3aGljaCBpcyB0aGUgUk9DIGN1cnZlIHRocm91Z2ggdGhlIHBvaW50cyAkKDAsMCkkLCAkKDAsMSkkIGFuZCAkKDEsMSkkLiBUaGlzIFJPQyBjdXJ2ZSBpbmNsdWRlcyBhIHRocmVzaG9sZCAkYyQgc3VjaCB0aGF0IHNlbnNpdGl2aXR5IGFuZCBzcGVjaWZpY2l0eSBhcmUgZXF1YWwgdG8gb25lLgoKIyMgQnJlYXN0IGNhbmNlciBleGFtcGxlCgojIyMgRGF0YQoKYGBge3IsIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9CmxpYnJhcnkoZ2xtbmV0KQoKI0Jpb2NNYW5hZ2VyOjppbnN0YWxsKCJnZW5lZnUiKQojQmlvY01hbmFnZXI6Omluc3RhbGwoImJyZWFzdENhbmNlck1BSU5aIikKCmxpYnJhcnkoZ2VuZWZ1KQpsaWJyYXJ5KGJyZWFzdENhbmNlck1BSU5aKQpkYXRhKG1haW56KQoKWCA8LSB0KGV4cHJzKG1haW56KSkgIyBnZW5lIGV4cHJlc3Npb25zCm4gPC0gbnJvdyhYKQpIIDwtIGRpYWcobiktMS9uKm1hdHJpeCgxLG5jb2w9bixucm93PW4pClggPC0gSCUqJVgKWSA8LSBpZmVsc2UocERhdGEobWFpbnopJGdyYWRlPT0zLDEsMCkKdGFibGUoWSkKYGBgCgotLS0KCkZyb20gdGhlIHRhYmxlIG9mIHRoZSBvdXRjb21lcyBpbiBZIHdlIHJlYWQgdGhhdAoKLSBgciBzdW0oWT09MSlgIHR1bW9ycyB3ZXJlIGdyYWRlZCBhcyBzdGFnZSAzIGFuZAotIGByIHN1bShZPT0wKWAgdHVtb3JzIHdlcmUgZ3JhZGVkIGFzIHN0YWdlIDEgb3IgMi4KCkluIHRoaXMgdGhlIHN0YWdlIDMgdHVtb3JzIGFyZSByZWZlcnJlZCB0byBhcyBjYXNlcyBvciBwb3N0aXZlcyBhbmQgdGhlIHN0YWdlIDEgYW5kIDIgdHVtb3JzIGFzIGNvbnRyb2xzIG9yIG5lZ2F0aXZlcy4KCi0tLQoKIyMjIFRyYWluaW5nIGFuZCB0ZXN0IGRhdGFzZXQKClRoZSB1c2Ugb2YgdGhlIGxhc3NvIGxvZ2lzdGljIHJlZ3Jlc3Npb24gZm9yIHRoZSBwcmVkaWN0aW9uIG9mIHN0YWdlIDMgYnJlYXN0IGNhbmNlciBpcyBpbGx1c3RyYXRlZCBoZXJlIGJ5CgotIHJhbmRvbWx5IHNwbGl0dGluZyB0aGUgZGF0YXNldCBpbnRvIGEgdHJhaW5pbmcgZGF0YXNldCAoJDgwXCUkIG9mIGRhdGEgPSAxNjAgdHVtb3JzKSBhbmQgYSB0ZXN0IGRhdGFzZXQgKDQwIHR1bW9ycykKCi0gdXNpbmcgdGhlIHRyYWluaW5nIGRhdGEgdG8gc2VsZWN0IGEgZ29vZCAkXGxhbWJkYSQgdmFsdWUgaW4gdGhlIGxhc3NvIGxvZ2lzdGljIHJlZ3Jlc3Npb24gbW9kZWwgKHRocm91Z2ggMTAtZm9sZCBDVikKCi0gZXZhbHVhdGluZyB0aGUgZmluYWwgbW9kZWwgYnkgbWVhbnMgb2YgdGhlIHRlc3QgZGF0YXNldCAoUk9DIEN1cnZlLCBBVUMpLgoKCmBgYHtyfQoKIyMgVXNlZCB0byBwcm92aWRlIHNhbWUgcmVzdWx0cyBhcyBpbiBwcmV2aW91cyBSIHZlcnNpb24KUk5Ha2luZChzYW1wbGUua2luZCA9ICJSb3VuZGluZyIpCnNldC5zZWVkKDY5NzczMjYpCiMjIyMKCm4gPC0gbnJvdyhYKQpuVHJhaW4gPC0gcm91bmQoMC44Km4pCm5UcmFpbgoKaW5kVHJhaW4gPC0gc2FtcGxlKDE6bixuVHJhaW4pClhUcmFpbiA8LSBYW2luZFRyYWluLF0KWVRyYWluIDwtIFlbaW5kVHJhaW5dClhUZXN0IDwtIFhbLWluZFRyYWluLF0KWVRlc3QgPC0gWVstaW5kVHJhaW5dCnRhYmxlKFlUZXN0KQpgYGAKCk5vdGUgdGhhdCB0aGUgcmFuZG9tbHkgc2VsZWN0ZWQgdGVzdCBkYXRhIGhhcyBgciBtZWFuKFlUZXN0PT0xKSoxMDBgJSBjYXNlcyBvZiBzdGFnZSAzIHR1bW9ycy4KVGhpcyBpcyBhIGJpdCBoaWdoZXIgdGhhbiB0aGUgYHIgbWVhbihZPT0xKSoxMDBgJSAgaW4gdGhlIGNvbXBsZXRlIGRhdGEuCgpPbmUgY291bGQgYWxzbyBwZXJmb3JtIHRoZSByYW5kb20gc3BsaXR0aW5nIGFtb25nIHRoZSBwb3NpdGl2ZXMgYW5kIHRoZSBuZWdhdGl2ZXMgc2VwYXJhdGVseSAoc3RyYXRpZmllZCBzcGxpdHRpbmcpLgoKIyMjIE1vZGVsIGZpdHRpbmcgYmFzZWQgb24gdHJhaW5pbmcgZGF0YQoKYGBge3J9Cm1MYXNzbyA8LSBnbG1uZXQoCiAgeCA9IFhUcmFpbiwKICB5ID0gWVRyYWluLAogIGFscGhhID0gMSwKICBmYW1pbHk9ImJpbm9taWFsIikgICMgbGFzc286IGFscGhhID0gMQoKcGxvdChtTGFzc28sIHh2YXIgPSAibGFtYmRhIiwgeGxpbSA9IGMoLTYsLTEuNSkpCmBgYAoKLS0tCgpgYGB7cn0KbUN2TGFzc28gPC0gY3YuZ2xtbmV0KAogIHggPSBYVHJhaW4sCiAgeSA9IFlUcmFpbiwKICBhbHBoYSA9IDEsCiAgdHlwZS5tZWFzdXJlID0gImNsYXNzIiwKCWZhbWlseSA9ICJiaW5vbWlhbCIpICAjIGxhc3NvIGFscGhhID0gMQoKcGxvdChtQ3ZMYXNzbykKbUN2TGFzc28KYGBgCgpUaGUgdG90YWwgbWlzY2xhc3NpZmljYXRpb24gZXJyb3IgaXMgdXNlZCBoZXJlIHRvIHNlbGVjdCBhIGdvb2QgdmFsdWUgZm9yICRcbGFtYmRhJC4KCmBgYHtyfQojIEJpb2NNYW5hZ2VyOjppbnN0YWxsKCJwbG90Uk9DIikKbGlicmFyeShwbG90Uk9DKQoKZGZMYXNzb09wdCA8LSBkYXRhLmZyYW1lKAogIHBpID0gcHJlZGljdChtQ3ZMYXNzbywKICAgIG5ld3ggPSBYVGVzdCwKICAgIHMgPSBtQ3ZMYXNzbyRsYW1iZGEubWluLAogICAgdHlwZSA9ICJyZXNwb25zZSIpICU+JSBjKC4pLAogIGtub3duLnRydXRoID0gWVRlc3QpCgpyb2MgPC0KICBkZkxhc3NvT3B0ICAlPiUKICBnZ3Bsb3QoYWVzKGQgPSBrbm93bi50cnV0aCwgbSA9IHBpKSkgKwogIGdlb21fcm9jKG4uY3V0cyA9IDApICsKICB4bGFiKCIxLXNwZWNpZmljaXR5IChGUFIpIikgKwogIHlsYWIoInNlbnNpdGl2aXR5IChUUFIpIikKCnJvYwoKY2FsY19hdWMocm9jKQpgYGAKCi0gVGhlIFJPQyBjdXJ2ZSBpcyBzaG93biBmb3IgdGhlIG1vZGVsIGJhc2VkIG9uICRcbGFtYmRhJCB3aXRoIHRoZSBzbWFsbGVzdCBtaXNjbGFzc2lmaWNhdGlvbiBlcnJvci4gVGhlIG1vZGVsIGhhcyBhbiBBVUMgb2YgYHIgY2FsY19hdWMocm9jKSAlPiUgcHVsbChBVUMpICU+JSByb3VuZCgyKWAuICAKCi0gQmFzZWQgb24gdGhpcyBST0MgY3VydmUgYW4gYXBwcm9wcmlhdGUgdGhyZXNob2xkICRjJCBjYW4gYmUgY2hvc2VuLiBGb3IgZXhhbXBsZSwgZnJvbSB0aGUgUk9DIGN1cnZlIHdlIHNlZSB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGF0dGFpbiBhIHNwZWNpZmljaXR5IGFuZCBhIHNlbnNpdGl2aXR5IG9mIDc1XCUuCgotIFRoZSBzZW5zaXRpdml0aWVzIGFuZCBzcGVjaWZpY2l0aWVzIGluIHRoZSBST0MgY3VydmUgYXJlIHVuYmlhc2VkIChpbmRlcGVuZGVudCB0ZXN0IGRhdGFzZXQpIGZvciB0aGUgcHJlZGljdGlvbiBtb2RlbCBidWlsZCBmcm9tIHRoZSB0cmFpbmluZyBkYXRhLiBUaGUgZXN0aW1hdGVzIG9mIHNlbnNpdGl2aXR5IGFuZCBzcGVjaWZpY2l0eSwgaG93ZXZlciwgYXJlIGJhc2VkIG9uIG9ubHkgNDAgb2JzZXJ2YXRpb25zLgoKLS0tCgpgYGB7cn0KbUxhbWJkYU9wdCA8LSBnbG1uZXQoeCA9IFhUcmFpbiwKICB5ID0gWVRyYWluLAogIGFscGhhID0gMSwKICBsYW1iZGEgPSBtQ3ZMYXNzbyRsYW1iZGEubWluLAogIGZhbWlseT0iYmlub21pYWwiKQoKcXBsb3QoCiAgc3VtbWFyeShjb2VmKG1MYW1iZGFPcHQpKVstMSwxXSwKICBzdW1tYXJ5KGNvZWYobUxhbWJkYU9wdCkpWy0xLDNdKSArCiAgeGxhYigiZ2VuZSBJRCIpICsKICB5bGFiKCJiZXRhLWhhdCIpICsKICBnZW9tX2hsaW5lKHlpbnRlcmNlcHQgPSAwLCBjb2xvciA9ICJyZWQiKQpgYGAKCi0gVGhlIG1vZGVsIHdpdGggdGhlIG9wdGltYWwgJFxsYW1iZGEkIGhhcyBvbmx5IGByIG1MYW1iZGFPcHQgJT4lIGNvZWYgJT4lIHN1bW1hcnkgJT4lIG5yb3dgIG5vbi16ZXJvIHBhcmFtZXRlciBlc3RpbWF0ZXMuCi0gVGh1cyBvbmx5IGByIG1MYW1iZGFPcHQgJT4lIGNvZWYgJT4lIHN1bW1hcnkgJT4lIG5yb3dgIGdlbmVzIGFyZSBpbnZvbHZlZCBpbiB0aGUgcHJlZGljdGlvbiBtb2RlbC4KLSBUaGVzZSBgciBtTGFtYmRhT3B0ICU+JSBjb2VmICU+JSBzdW1tYXJ5ICU+JSBucm93YCBwYXJhbWV0ZXIgZXN0aW1hdGVzIGFyZSBwbG90dGluZyBpbiB0aGUgZ3JhcGguCkEgbGlzdGluZyBvZiB0aGUgbW9kZWwgb3V0cHV0IHdvdWxkIHNob3cgdGhlIG5hbWVzIG9mIHRoZSBnZW5lcy4KCi0tLQoKYGBge3J9CgpkZkxhc3NvMXNlIDwtIGRhdGEuZnJhbWUoCiAgcGkgPSBwcmVkaWN0KG1Ddkxhc3NvLAogICAgbmV3eCA9IFhUZXN0LAogICAgcyA9IG1Ddkxhc3NvJGxhbWJkYS4xc2UsCiAgICB0eXBlID0gInJlc3BvbnNlIikgJT4lIGMoLiksCiAga25vd24udHJ1dGggPSBZVGVzdCkKCnJvYyA8LQogIHJiaW5kKAogICAgZGZMYXNzb09wdCAlPiUKICAgICAgbXV0YXRlKG1ldGhvZCA9ICJtaW4iKSwKICAgIGRmTGFzc28xc2UgJT4lCiAgICAgIG11dGF0ZShtZXRob2QgPSAiMXNlIikKICApICU+JQogIGdncGxvdChhZXMoZCA9IGtub3duLnRydXRoLCBtID0gcGksIGNvbG9yID0gbWV0aG9kKSkgKwogIGdlb21fcm9jKG4uY3V0cyA9IDApICsKICB4bGFiKCIxLXNwZWNpZmljaXR5IChGUFIpIikgKwogIHlsYWIoInNlbnNpdGl2aXR5IChUUFIpIikKCnJvYwoKY2FsY19hdWMocm9jKQpgYGAKCi0gV2hlbiB1c2luZyB0aGUgJFxsYW1iZGEkIG9mIHRoZSBvcHRpbWFsIG1vZGVsIHVwIHRvIDEgc3RhbmRhcmQgZGV2aWF0aW9uLCBhIGRpYWdvbmFsIFJPQyBjdXJ2ZSBpcyBvYnRhaW5lZCBhbmQgaGVuY2UgQVVDIGlzICQwLjUkLgoKLSBUaGlzIHByZWRpY3Rpb24gbW9kZWwgaXMgdGh1cyBlcXVpdmFsZW50IHRvIGZsaXBwaW5nIGEgY29pbiBmb3IgbWFraW5nIHRoZSBwcmVkaWN0aW9uLgoKLSBUaGUgcmVhc29uIGlzIHRoYXQgd2l0aCB0aGlzIGNob2ljZSBvZiAkXGxhbWJkYSQgKHN0cm9uZyBwZW5hbGlzYXRpb24pIGFsbW9zdCBhbGwgcHJlZGljdG9ycyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBtb2RlbC4KCi0gVGhlcmVmb3JlLCBkbyBuZXZlciBibGluZGx5IGNob29zZSBmb3IgdGhlIGBgb3B0aW1hbCcnICRcbGFtYmRhJCBhcyBkZWZpbmVkIGhlcmUsIGJ1dCBhc3Nlc3MgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBtb2RlbCBmaXJzdC4KCmBgYHtyfQptTGFtYmRhMXNlIDwtIGdsbW5ldCh4ID0gWFRyYWluLAogIHkgPSBZVHJhaW4sCiAgYWxwaGEgPSAxLAogIGxhbWJkYSA9IG1Ddkxhc3NvJGxhbWJkYS4xc2UsCiAgZmFtaWx5PSJiaW5vbWlhbCIpCgptTGFtYmRhMXNlICU+JQogIGNvZWYgJT4lCiAgc3VtbWFyeQpgYGAKCi0tLQoKIyMgVGhlIEVsYXN0aWMgTmV0CgpUaGUgbGFzc28gYW5kIHJpZGdlIHJlZ3Jlc3Npb24gaGF2ZSBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgcHJvcGVydGllcy4KCi0gTGFzc28KCiAgIC0gcG9zaXRpdmU6IHNwYXJzZSBzb2x1dGlvbgoKICAgLSBuZWdhdGl2ZTogYXQgbW9zdCAkXG1pbihuLHApJCBwcmVkaWN0b3JzIGNhbiBiZSBzZWxlY3RlZAoKICAgLSBuZWdhdGl2ZTogdGVuZCB0byBzZWxlY3Qgb25lIHByZWRpY3RvciBhbW9uZyBhIGdyb3VwIG9mIGhpZ2hseSBjb3JyZWxhdGVkIHByZWRpY3RvcnMKCgotIFJpZGdlCgogICAgLSBuZWdhdGl2ZTogbm8gc3BhcnNlIHNvbHV0aW9uCiAgICAtIHBvc2l0aXZlOiBtb3JlIHRoYW4gJFxtaW4obixwKSQgcHJlZGljdG9ycyBjYW4gYmUgc2VsZWN0ZWQKCkEgY29tcHJvbWlzZSBiZXR3ZWVuIGxhc3NvIGFuZCByaWRnZTogdGhlICoqZWxhc3RpYyBuZXQqKjoKXFsKICBcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0gPSBcdGV4dHtBcmdNYXh9X1xiZXRhIGwoXGJvbGRzeW1ib2x7XGJldGF9KSAtXGdhbW1hXzEgXHZlcnQgXGJvbGRzeW1ib2xcYmV0YVx2ZXJ0IC1cZ2FtbWFfMiBcVmVydCBcYm9sZHN5bWJvbFxiZXRhXFZlcnRfMl4yLgpcXQoKVGhlIGVsYXN0aWMgZ2l2ZXMgYSBzcGFyc2Ugc29sdXRpb24gd2l0aCBwb3RlbnRpYWxseSBtb3JlIHRoYW4gJFxtaW4obixwKSQgcHJlZGljdG9ycy4KCi0tLQoKVGhlIGBnbG1uZXRgIFIgZnVuY3Rpb24gdXNlcyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcmlzYXRpb24sClxbCiAgXGhhdHtcYm9sZHN5bWJvbHtcYmV0YX19ID0gXHRleHR7QXJnTWF4fV9cYmV0YSBsKFxib2xkc3ltYm9se1xiZXRhfSkgLVxsYW1iZGFcYWxwaGEgXFZlcnQgXGJvbGRzeW1ib2xcYmV0YVxWZXJ0XzAgLVxsYW1iZGEoMS1cYWxwaGEpIFxWZXJ0IFxib2xkc3ltYm9sXGJldGFcVmVydF8yXjIuClxdCgotICRcYWxwaGEkIHBhcmFtZXRlciBnaXZlcyB3ZWlnaHQgdG8gJExfMSQgcGVuYWx0eSB0ZXJtIChoZW5jZSAkXGFscGhhPTEkIGdpdmVzIHRoZSBsYXNzbywgYW5kICRcYWxwaGE9MCQgZ2l2ZXMgcmlkZ2UpLgoKLSBhICRcbGFtYmRhJCBwYXJhbWV0ZXIgdG8gZ2l2ZSB3ZWlnaHQgdG8gdGhlIHBlbmFsaXNhdGlvbgoKLSBOb3RlIHRoYXQgdGhlIGNvbWJpbmF0aW9uIG9mICRcbGFtYmRhJCBhbmQgJFxhbHBoYSQgZ2l2ZXMgdGhlIHNhbWUgZmxleGliaWxpdHkgYXMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBwYXJhbWV0ZXJzICRcbGFtYmRhXzEkIGFuZCAkXGxhbWJkYV8yJC4KCi0tLQoKIyMjIEJyZWFzdCBjYW5jZXIgZXhhbXBsZQoKYGBge3J9Cm1FbGFzdGljIDwtIGdsbW5ldCgKICB4ID0gWFRyYWluLAogIHkgPSBZVHJhaW4sCiAgYWxwaGEgPSAwLjUsCiAgZmFtaWx5PSJiaW5vbWlhbCIpICAjIGVsYXN0aWMgbmV0CgpwbG90KG1FbGFzdGljLCB4dmFyID0gImxhbWJkYSIseGxpbT1jKC01LjUsLTEpKQpgYGAKCmBgYHtyfQptQ3ZFbGFzdGljIDwtIGN2LmdsbW5ldCh4ID0gWFRyYWluLAogIHkgPSBZVHJhaW4sCiAgYWxwaGEgPSAwLjUsCiAgZmFtaWx5ID0gImJpbm9taWFsIiwKCXR5cGUubWVhc3VyZSA9ICJjbGFzcyIpICAjIGVsYXN0aWMgbmV0CgpwbG90KG1DdkVsYXN0aWMpCm1DdkVsYXN0aWMKYGBgCgpgYGB7cn0KZGZFbGFzdCA8LSBkYXRhLmZyYW1lKAogIHBpID0gcHJlZGljdChtRWxhc3RpYywKICAgIG5ld3ggPSBYVGVzdCwKICAgIHMgPSBtQ3ZFbGFzdGljJGxhbWJkYS5taW4sCiAgICB0eXBlID0gInJlc3BvbnNlIikgJT4lIGMoLiksCiAga25vd24udHJ1dGggPSBZVGVzdCkKCnJvYyA8LSByYmluZCgKICBkZkxhc3NvT3B0ICU+JSBtdXRhdGUobWV0aG9kID0gImxhc3NvIiksCiAgZGZFbGFzdCAlPiUgbXV0YXRlKG1ldGhvZCA9ICJlbGFzdC4gbmV0IikpICU+JQogIGdncGxvdChhZXMoZCA9IGtub3duLnRydXRoLCBtID0gcGksIGNvbG9yID0gbWV0aG9kKSkgKwogIGdlb21fcm9jKG4uY3V0cyA9IDApICsKICB4bGFiKCIxLXNwZWNpZmljaXR5IChGUFIpIikgKwogIHlsYWIoInNlbnNpdGl2aXR5IChUUFIpIikKCnJvYwoKY2FsY19hdWMocm9jKQpgYGAKCi0gTW9yZSBwYXJhbWV0ZXJzIGFyZSB1c2VkIHRoYW4gZm9yIHRoZSBsYXNzbywgYnV0IHRoZSBwZXJmb3JtYW5jZSBkb2VzIG5vdCBpbXByb3ZlLgoKYGBge3J9Cm1FbGFzdGljT3B0IDwtIGdsbW5ldCh4ID0gWFRyYWluLAogIHkgPSBZVHJhaW4sCiAgYWxwaGEgPSAwLjUsCiAgbGFtYmRhID0gbUN2RWxhc3RpYyRsYW1iZGEubWluLAogIGZhbWlseT0iYmlub21pYWwiKQoKcXBsb3QoCiAgc3VtbWFyeShjb2VmKG1FbGFzdGljT3B0KSlbLTEsMV0sCiAgc3VtbWFyeShjb2VmKG1FbGFzdGljT3B0KSlbLTEsM10pICsKICB4bGFiKCJnZW5lIElEIikgKwogIHlsYWIoImJldGEtaGF0IikgKwogIGdlb21faGxpbmUoeWludGVyY2VwdCA9IDAsIGNvbG9yID0gInJlZCIpCmBgYAo=</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("prediction.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
